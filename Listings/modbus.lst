C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN .\Objects\modbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE lib\modbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.\l
                    -ib) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus.lst) OBJECT(.\Objects\modbus.obj)

line level    source

   1          #include "modbus.h"
   2          #include "uart.h"
   3          #include "umath.h"
   4          #include "timer.h"
   5          #include "debug.h"
   6          #include <STRING.H>
   7          #include "const.h"
   8          
   9          MMODBUS pageModbusReg[PAGE_MAX_NUM] = {0};
  10          u8 modbusNum, modbusTreatID; // modbusTreatID,ÓÃÀ´Ö¸Ê¾µ±Ç°ÕýÔÚ´¦ÀíÄÄÒ»Ìõ£¬modbusNum±íÊ¾µ±Ç°»º´æÇøÖÐÒ»¹²ÓÐ¶
             -àÉÙÌõ
  11          MMODBUS *emergencyTreat[EMERTENCY_NUM];
  12          u8 emergencyTail, emergencyHead;
  13          static MMODBUS *pNowOrder;
  14          static u8 ModbusBusy; // Ö¸Ê¾ÊÇ·ñÓÐMODBUSÃüÁîÕýÔÚ·¢ËÍ
  15          
  16          u8 isEmergencyFull(void) // ÓÃÓÚ¼ì²é½ô¼±´¦ÀíÊÇ·ñÊÇÂúµÄ£¬ÂúµÄ²»ÄÜÔÙ´Î×°ÌîÊý¾Ý£¬ÒÔÃâÔì³É´íÂÒ
  17          {
  18   1              u8 tmp;
  19   1      
  20   1              tmp = emergencyHead + 1;
  21   1              if (tmp >= EMERTENCY_NUM)
  22   1                      tmp = 0;
  23   1              if (tmp == emergencyTail)
  24   1                      return 1;
  25   1              else
  26   1                      return 0;
  27   1      }
  28          
  29          u8 isEmergencyEmpty(void)
  30          {
  31   1              if (emergencyHead == emergencyTail)
  32   1                      return 1;
  33   1              else
  34   1                      return 0;
  35   1      }
  36          
  37          void clrEmergency(void)
  38          {
  39   1              emergencyHead = emergencyTail = 0;
  40   1      }
  41          
  42          void pushToEmergency(MMODBUS *modbusOrder) // ÓÃÓÚ¼ÓÔØÒ»¸ö½á¹¹°üÖ¸Õëµ½Êý×éÖÐ
  43          {
  44   1              if (isEmergencyFull())
  45   1                      return;
  46   1              emergencyTreat[emergencyHead] = modbusOrder;
  47   1              emergencyHead++;
  48   1              if (emergencyHead >= EMERTENCY_NUM)
  49   1                      emergencyHead = 0;
  50   1      }
  51          
  52          MMODBUS *popFromEmergency(void)
  53          {
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 2   

  54   1              u8 tmp;
  55   1      
  56   1              if (isEmergencyEmpty())
  57   1                      return NULL;
  58   1              else
  59   1              {
  60   2                      tmp = emergencyTail;
  61   2                      emergencyTail++;
  62   2                      if (emergencyTail >= EMERTENCY_NUM)
  63   2                              emergencyTail = 0;
  64   2                      return emergencyTreat[tmp];
  65   2              }
  66   1      }
  67          
  68          #if 0 // ÆÁÄ»×ö´Ó»ú
              void Uart485RxTreat(void)
              {
                      u16 len,len1,i;
                      u8 tmp[512];
                      u16 headtmp;
                      
                      if(Uart_Struct[UART485].rx_tail != Uart_Struct[UART485].rx_head)
                      {
                              if(Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail]==0)
                              {
                                      EA = 0;
                                      headtmp = Uart_Struct[UART485].rx_head;
                                      EA = 1;
                          if(headtmp < Uart_Struct[UART485].rx_tail)
                          {
                              len = (headtmp+SERIAL_SIZE) - Uart_Struct[UART485].rx_tail;
                          }
                          else
                          {
                              len = headtmp - Uart_Struct[UART485].rx_tail;
                          }
                                      if(len >= START_TREAT_LENGTH)
                                      {
                                              if(Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail+1)&SERIAL_COUNT] == READ_REGISTER)
                                              {
                                                      if(len>=8)
                                                      {
                                                              for(i=0;i<8;i++)
                                                              {
                                                                      tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
                                                                      Uart_Struct[UART485].rx_tail++;
                                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                                                              }
                                                              if(Calculate_CRC16(tmp,8)==0)
                                                              {
                                              
                                                              }
                                                      }
                                              }
                                              else if(Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail+1)&SERIAL_COUNT] == WRITE_REGISTER)
                                              {
                                                      len1 = Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail+6)&SERIAL_COUNT]+9;
                                                      if(len >= len1)
                                                      {
                                                              for(i=0;i<len1;i++)
                                                              {
                                                                      tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 3   

                                                                      Uart_Struct[UART485].rx_tail++;
                                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                                                              }
                                                              if(Calculate_CRC16(tmp,len1)==0)
                                                              {
                                                                              Calculate_CRC16(tmp,6);
                                                                              Uatr_Send_Data(UART485,8,tmp);
                                                              }
                                                      }
                                              }
                                              else 
                                              {
                                                      Uart_Struct[UART485].rx_tail++;
                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                                              }
                                      }
                              }
                              else
                              {
                                      Uart_Struct[UART485].rx_tail++;
                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                              }
                      }
              }
              #else // ÆÁÄ»×öÖ÷»ú
 141          void modbusRxTreat(void)
 142          {
 143   1              u16 len, len1, i, lentmp;
 144   1              u8 tmp[512];
 145   1              u16 headtmp;
 146   1              u8 tmp8;
 147   1      
 148   1              EA = 0;
 149   1              headtmp = Uart_Struct[UART485].rx_head;
 150   1              EA = 1;
 151   1              if (Uart_Struct[UART485].rx_tail != headtmp)
 152   1              {
 153   2                      if (Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail] == pNowOrder->SlaveAddr) // ²éÕÒµ±Ç°ÕýÔÚ·¢
             -ËÍÃüÁîµÄmodbusµØÖ·
 154   2                      {
 155   3                              if (headtmp < Uart_Struct[UART485].rx_tail)
 156   3                              {
 157   4                                      len = (headtmp + SERIAL_SIZE) - Uart_Struct[UART485].rx_tail;
 158   4                              }
 159   3                              else
 160   3                              {
 161   4                                      len = headtmp - Uart_Struct[UART485].rx_tail;
 162   4                              }
 163   3                              if (len >= START_TREAT_LENGTH) // »º´æµ½Ò»¶¨³¤¶Èºó²Å¿ªÊ¼´¦ÀíÊý¾Ý
 164   3                              {
 165   4                                      if (Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail + 1) & SERIAL_COUNT] == pNowOrder->Order
             -) // ²éÕÒµ½ÁËµØÖ·£¬²¢ÇÒºóÃæÊÇÏìÓ¦µÄÖ¸Áî
 166   4                                      {
 167   5                                              if (pNowOrder->Order == 0x01 || pNowOrder->Order == 0x02)
 168   5                                              {
 169   6                                                      len1 = Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail + 2) & SERIAL_COUNT];
 170   6                                                      lentmp = pNowOrder->Length / 8;
 171   6                                                      if ((pNowOrder->Length % 8) != 0)
 172   6                                                              lentmp++;
 173   6                                                      if (len1 == lentmp)
 174   6                                                      {
 175   7                                                              if (len >= len1 + 5)
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 4   

 176   7                                                              {
 177   8                                                                      for (i = 0; i < len1 + 5; i++)
 178   8                                                                      {
 179   9                                                                              tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
 180   9                                                                              Uart_Struct[UART485].rx_tail++;
 181   9                                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
 182   9                                                                      }
 183   8                                                                      if (Calculate_CRC16(tmp, len1 + 5, 0) == 0) // Ð£ÑéÕýÈ·
 184   8                                                                      {
 185   9                                                                              ModbusBusy = 0; // ±êÖ¾Î»±ä³É¿ÕÏÐ£¬¿ÉÒÔ¼ÌÐø·¢ËÍÏÂÒ»°üÊý¾Ý
 186   9                                                                              for (i = 0; i < pNowOrder->Length; i++)
 187   9                                                                              {
 188  10                                                                                      tmp8 = 0x01 << (i % 8);
 189  10                                                                                      if (tmp[3 + i / 8] & tmp8)
 190  10                                                                                              headtmp = 1;
 191  10                                                                                      else
 192  10                                                                                              headtmp = 0;
 193  10                                                                                      write_dgus_vp(pNowOrder->VPaddr + i, (u8 *)&headtmp, 1);
 194  10                                                                              }
 195   9                                                                              if (pNowOrder->databuff != NULL)
 196   9                                                                              {
 197  10                                                                                      memcpy(pNowOrder->databuff, tmp + 3, tmp[2]);
 198  10                                                                              }
 199   9                                                                      }
 200   8                                                              }
 201   7                                                      }
 202   6                                                      else
 203   6                                                      {
 204   7                                                              Uart_Struct[UART485].rx_tail++;
 205   7                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 206   7                                                      }
 207   6                                              }
 208   5                                              else if (0x03 == pNowOrder->Order)
 209   5                                              {
 210   6                                                      len1 = Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail + 2) & SERIAL_COUNT];
 211   6                                                      lentmp = pNowOrder->Length << 1;
 212   6                                                      if (len1 == lentmp)
 213   6                                                      {
 214   7                                                              if (len >= len1 + 5)
 215   7                                                              {
 216   8                                                                      for (i = 0; i < len1 + 5; i++)
 217   8                                                                      {
 218   9                                                                              tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
 219   9                                                                              Uart_Struct[UART485].rx_tail++;
 220   9                                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
 221   9                                                                      }
 222   8                                                                      if (Calculate_CRC16(tmp, len1 + 5, 0) == 0) // Ð£ÑéÕýÈ·
 223   8                                                                      {
 224   9                                                                              ModbusBusy = 0; // ±êÖ¾Î»±ä³É¿ÕÏÐ£¬¿ÉÒÔ¼ÌÐø·¢ËÍÏÂÒ»°üÊý¾Ý
 225   9                                                                              write_dgus_vp(pNowOrder->VPaddr, &tmp[3], pNowOrder->Length);
 226   9                                                                              if (pNowOrder->databuff != NULL)
 227   9                                                                              {
 228  10                                                                                      // DEBUGINFO("memcpy");
 229  10                                                                                      memcpy(pNowOrder->databuff, tmp + 3, tmp[2]);
 230  10                                                                              }
 231   9                                                                      }
 232   8                                                              }
 233   7                                                      }
 234   6                                                      else
 235   6                                                      {
 236   7                                                              Uart_Struct[UART485].rx_tail++;
 237   7                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 5   

 238   7                                                      }
 239   6                                              }
 240   5                                              else if ((0x05 == pNowOrder->Order) || (0x06 == pNowOrder->Order) || (0x10 == pNowOrder->Order))
 241   5                                              {
 242   6                                                      if (len >= 8)
 243   6                                                      {
 244   7                                                              for (i = 0; i < 8; i++)
 245   7                                                              {
 246   8                                                                      tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
 247   8                                                                      Uart_Struct[UART485].rx_tail++;
 248   8                                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
 249   8                                                              }
 250   7                                                              if (Calculate_CRC16(tmp, 8, 0) == 0) // Ð£ÑéÕýÈ·
 251   7                                                              {
 252   8                                                                      if (*(u16 *)&tmp[2] == pNowOrder->ModbusReg)
 253   8                                                                      {
 254   9                                                                              ModbusBusy = 0; // ±êÖ¾Î»±ä³É¿ÕÏÐ£¬¿ÉÒÔ¼ÌÐø·¢ËÍÏÂÒ»°üÊý¾Ý
 255   9                                                                      }
 256   8                                                              }
 257   7                                                      }
 258   6                                              }
 259   5                                              else
 260   5                                              {
 261   6                                                      Uart_Struct[UART485].rx_tail++;
 262   6                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 263   6                                              }
 264   5                                      }
 265   4                                      else
 266   4                                      {
 267   5                                              Uart_Struct[UART485].rx_tail++;
 268   5                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 269   5                                      }
 270   4                              }
 271   3                      }
 272   2                      else
 273   2                      {
 274   3                              Uart_Struct[UART485].rx_tail++;
 275   3                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 276   3                      }
 277   2              }
 278   1      }
 279          #endif
 280          
 281          u8 AnalysisMosbusOrder(u8 *pBuf) // ¸ù¾Ýµ±Ç°Ö¸ÁîµÄ¸ñÊ½½«Òª·¢ËÍµÄÊý¾Ý·Åµ½PbufÀïÃæ£¬²¢·µ»Ø·¢ËÍ³¤¶È
 282          {
 283   1              u8 len;
 284   1              u8 tmp[4];
 285   1      
 286   1              if (pNowOrder->mode == 0)
 287   1              {
 288   2              }
 289   1              else if (pNowOrder->mode == 1)
 290   1              {
 291   2                      if (pNowOrder->flag == 0x5a)
 292   2                      {
 293   3                              pNowOrder->flag = 0x00;
 294   3                      }
 295   2                      else
 296   2                      {
 297   3                              return 0;
 298   3                      }
 299   2              }
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 6   

 300   1              else
 301   1              {
 302   2                      return 0;
 303   2              }
 304   1              len = 0;
 305   1              switch (pNowOrder->Order)
 306   1              {
 307   2              case 0x01: // ¶ÁÎ»×´Ì¬¼Ä´æÆ÷
 308   2                      if (pNowOrder->Length)
 309   2                      {
 310   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 311   3                              pBuf[1] = 0x01;                                 // ¹¦ÄÜÂë
 312   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 313   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // Î»¼Ä´æÆ÷ÆðÊ¼µØÖ·
 314   3                              pBuf[4] = 0;
 315   3                              pBuf[5] = pNowOrder->Length; // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö255
 316   3                              len = 6;
 317   3                      }
 318   2                      else
 319   2                      {
 320   3                              len = 0;
 321   3                      }
 322   2                      break;
 323   2              case 0x02: // ¶ÁÎ»×´Ì¬¼Ä´æÆ÷
 324   2                      if (pNowOrder->Length)
 325   2                      {
 326   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 327   3                              pBuf[1] = 0x02;                                 // ¹¦ÄÜÂë
 328   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 329   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // Î»¼Ä´æÆ÷ÆðÊ¼µØÖ·
 330   3                              pBuf[4] = 0;
 331   3                              pBuf[5] = pNowOrder->Length; // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö255
 332   3                              len = 6;
 333   3                      }
 334   2                      else
 335   2                      {
 336   3                              len = 0;
 337   3                      }
 338   2                      break;
 339   2              case 0x03: // ¶Á±£³Ö¼Ä´æÆ÷
 340   2                      if (pNowOrder->Length)
 341   2                      {
 342   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 343   3                              pBuf[1] = 0x03;                                 // ¹¦ÄÜÂë
 344   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 345   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 346   3                              pBuf[4] = 0;
 347   3                              pBuf[5] = pNowOrder->Length; // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö255
 348   3                              len = 6;
 349   3                      }
 350   2                      else
 351   2                      {
 352   3                              len = 0;
 353   3                      }
 354   2                      break;
 355   2              case 0x05:                                                      // Ð´µ¥¸öÎ»¼Ä´æÆ÷
 356   2                      pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 357   2                      pBuf[1] = 0x05;                                 // ¹¦ÄÜÂë
 358   2                      pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 359   2                      pBuf[3] = (u8)(pNowOrder->ModbusReg); // Î»¼Ä´æÆ÷ÆðÊ¼µØÖ·
 360   2                      if (pNowOrder->databuff != NULL)
 361   2                      {
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 7   

 362   3                              memcpy(tmp, (uint8_t *)pNowOrder->databuff, 2);
 363   3                      }
 364   2                      else if (pNowOrder->VPaddr != 0)
 365   2                      {
 366   3                              read_dgus_vp(pNowOrder->VPaddr, tmp, 1);
 367   3                      }
 368   2                      if (tmp[1])
 369   2                              pBuf[4] = 0xff; // Î»×ªÌ¬ÎªON
 370   2                      else
 371   2                              pBuf[4] = 0; // Î»×´Ì¬ÎªOFF
 372   2                      pBuf[5] = 0x00;
 373   2                      len = 6;
 374   2                      break;
 375   2              case 0x06:                                                      // Ð´µ¥¸ö¼Ä´æÆ÷
 376   2                      pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 377   2                      pBuf[1] = 0x06;                                 // ¹¦ÄÜÂë
 378   2                      pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 379   2                      pBuf[3] = (u8)(pNowOrder->ModbusReg); // ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 380   2                      if (pNowOrder->databuff != NULL)
 381   2                      {
 382   3                              memcpy(&pBuf[4], (uint8_t *)pNowOrder->databuff, 2);
 383   3                      }
 384   2                      else if (pNowOrder->VPaddr != 0)
 385   2                      {
 386   3                              read_dgus_vp(pNowOrder->VPaddr, &pBuf[4], 1);
 387   3                      }
 388   2                      len = 6;
 389   2                      break;
 390   2              case 0x10: // Ð´¶à¸ö¼Ä´æÆ÷
 391   2                      if ((pNowOrder->Length > 0) && (pNowOrder->Length < 0x7b))
 392   2                      {
 393   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 394   3                              pBuf[1] = 0x10;                                 // ¹¦ÄÜÂë
 395   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 396   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 397   3                              pBuf[4] = 0;
 398   3                              pBuf[5] = pNowOrder->Length;      // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö0x7b
 399   3                              pBuf[6] = pNowOrder->Length << 1; // Ð´Èë¼Ä´æÆ÷×Ö½ÚÊý
 400   3                              len = pBuf[6] + 7;
 401   3                              if (pNowOrder->databuff != NULL)
 402   3                              {
 403   4                                      memcpy(&pBuf[7], (uint8_t *)pNowOrder->databuff, pNowOrder->Length * 2);
 404   4                              }
 405   3                              else if (pNowOrder->VPaddr != 0)
 406   3                              {
 407   4                                      read_dgus_vp(pNowOrder->VPaddr, &pBuf[7], pNowOrder->Length); // Êµ¼ÊÊý¾Ý
 408   4                              }
 409   3                      }
 410   2                      else
 411   2                      {
 412   3                              len = 0;
 413   3                      }
 414   2                      break;
 415   2              default:
 416   2                      break;
 417   2              }
 418   1              if (len)
 419   1              {
 420   2                      Calculate_CRC16(pBuf, len, 1);
 421   2                      return len + 2; // ·µ»Ø·¢ËÍ³¤¶È+2×Ö½ÚCRC
 422   2              }
 423   1              return 0; // 0±íÊ¾±¾ÌõÖ¸ÁîÎÞÐ§
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 8   

 424   1      }
 425          
 426          void modbusTxTreat(void)
 427          {
 428   1              u8 sendbuf[512];
 429   1              u8 len;
 430   1      
 431   1              if (ModbusBusy) // ÓÐÊý¾ÝÕýÔÚ´¦ÀíµÄÊ±ºò£¬²»´¦Àí·¢ËÍ
 432   1                      return;
 433   1              pNowOrder = popFromEmergency();
 434   1              if (pNowOrder != NULL)
 435   1              {
 436   2                      len = AnalysisMosbusOrder(sendbuf);
 437   2                      if (len)
 438   2                      {
 439   3                              ModbusBusy = 1;
 440   3                              Uart_Send_Data(UART485, len, sendbuf);
 441   3                              StartTimer(MODBUS_TIMER, pNowOrder->waitTime);
 442   3                      }
 443   2              }
 444   1              else
 445   1              {
 446   2                      if (modbusNum == 0) // µ±Ç°Ò³µÄ¼Ä´æÆ÷¸öÊýÎª0µÄÊ±ºò£¬²»´¦Àí·¢ËÍ
 447   2                      {
 448   3                              modbusTreatID = 0;
 449   3                              return;
 450   3                      }
 451   2                      pNowOrder = &pageModbusReg[modbusTreatID];
 452   2                      modbusTreatID++;
 453   2                      if (modbusTreatID >= modbusNum)
 454   2                              modbusTreatID = 0;
 455   2                      len = AnalysisMosbusOrder(sendbuf);
 456   2                      if (len)
 457   2                      {
 458   3                              ModbusBusy = 1;
 459   3                              Uart_Send_Data(UART485, len, sendbuf);
 460   3                              StartTimer(MODBUS_TIMER, pNowOrder->waitTime);
 461   3                      }
 462   2              }
 463   1      }
 464          
 465          void modbusTreat(void)
 466          {
 467   1              if (ModbusBusy)
 468   1              {
 469   2                      if (GetTimeOutFlag(MODBUS_TIMER)) // ³¬Ê±ºó£¬Ç¿ÖÆ´¦ÀíÏÂÒ»°ü
 470   2                      {
 471   3                              ModbusBusy = 0;
 472   3                              EA = 0;
 473   3                              Uart_Struct[UART485].rx_tail = Uart_Struct[UART485].rx_head;
 474   3                              EA = 1;
 475   3                      }
 476   2              }
 477   1              modbusTxTreat();
 478   1              modbusRxTreat();
 479   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3072    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1016    1043
C51 COMPILER V9.60.7.0   MODBUS                                                            04/28/2023 11:12:22 PAGE 9   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
