C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN .\Objects\modbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE lib\modbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.\l
                    -ib) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus.lst) OBJECT(.\Objects\modbus.obj)

line level    source

   1          #include "modbus.h"
   2          #include "uart.h"
   3          #include "umath.h"
   4          #include "timer.h"
   5          #include "debug.h"
   6          #include <STRING.H>
   7          #include "const.h"
   8          
   9          MMODBUS pageModbusReg[PAGE_MAX_NUM] = {0};
  10          u8 modbusNum, modbusTreatID; // modbusTreatID,ÓÃÀ´Ö¸Ê¾µ±Ç°ÕýÔÚ´¦ÀíÄÄÒ»Ìõ£¬modbusNum±íÊ¾µ±Ç°»º´æÇøÖÐÒ»¹²ÓÐ¶
             -àÉÙÌõ
  11          MMODBUS *emergencyTreat[EMERTENCY_NUM];
  12          u8 emergencyTail, emergencyHead;
  13          static MMODBUS *pNowOrder;
  14          static u8 ModbusBusy; // Ö¸Ê¾ÊÇ·ñÓÐMODBUSÃüÁîÕýÔÚ·¢ËÍ
  15          
  16          u8 isEmergencyFull(void) // ÓÃÓÚ¼ì²é½ô¼±´¦ÀíÊÇ·ñÊÇÂúµÄ£¬ÂúµÄ²»ÄÜÔÙ´Î×°ÌîÊý¾Ý£¬ÒÔÃâÔì³É´íÂÒ
  17          {
  18   1              u8 tmp;
  19   1      
  20   1              tmp = emergencyHead + 1;
  21   1              if (tmp >= EMERTENCY_NUM)
  22   1                      tmp = 0;
  23   1              if (tmp == emergencyTail)
  24   1                      return 1;
  25   1              else
  26   1                      return 0;
  27   1      }
  28          
  29          u8 isEmergencyEmpty(void)
  30          {
  31   1              if (emergencyHead == emergencyTail)
  32   1                      return 1;
  33   1              else
  34   1                      return 0;
  35   1      }
  36          
  37          void clrEmergency(void)
  38          {
  39   1              emergencyHead = emergencyTail = 0;
  40   1      }
  41          
  42          void pushToEmergency(MMODBUS *modbusOrder) // ÓÃÓÚ¼ÓÔØÒ»¸ö½á¹¹°üÖ¸Õëµ½Êý×éÖÐ
  43          {
  44   1              if (isEmergencyFull())
  45   1                      return;
  46   1              emergencyTreat[emergencyHead] = modbusOrder;
  47   1              emergencyHead++;
  48   1              if (emergencyHead >= EMERTENCY_NUM)
  49   1                      emergencyHead = 0;
  50   1      }
  51          
  52          MMODBUS *popFromEmergency(void)
  53          {
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 2   

  54   1              u8 tmp;
  55   1      
  56   1              if (isEmergencyEmpty())
  57   1                      return NULL;
  58   1              else
  59   1              {
  60   2                      tmp = emergencyTail;
  61   2                      emergencyTail++;
  62   2                      if (emergencyTail >= EMERTENCY_NUM)
  63   2                              emergencyTail = 0;
  64   2                      return emergencyTreat[tmp];
  65   2              }
  66   1      }
  67          
  68          #if 0 // ÆÁÄ»×ö´Ó»ú
              void Uart485RxTreat(void)
              {
                      u16 len,len1,i;
                      u8 tmp[512];
                      u16 headtmp;
                      
                      if(Uart_Struct[UART485].rx_tail != Uart_Struct[UART485].rx_head)
                      {
                              if(Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail]==0)
                              {
                                      EA = 0;
                                      headtmp = Uart_Struct[UART485].rx_head;
                                      EA = 1;
                          if(headtmp < Uart_Struct[UART485].rx_tail)
                          {
                              len = (headtmp+SERIAL_SIZE) - Uart_Struct[UART485].rx_tail;
                          }
                          else
                          {
                              len = headtmp - Uart_Struct[UART485].rx_tail;
                          }
                                      if(len >= START_TREAT_LENGTH)
                                      {
                                              if(Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail+1)&SERIAL_COUNT] == READ_REGISTER)
                                              {
                                                      if(len>=8)
                                                      {
                                                              for(i=0;i<8;i++)
                                                              {
                                                                      tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
                                                                      Uart_Struct[UART485].rx_tail++;
                                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                                                              }
                                                              if(Calculate_CRC16(tmp,8)==0)
                                                              {
                                              
                                                              }
                                                      }
                                              }
                                              else if(Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail+1)&SERIAL_COUNT] == WRITE_REGISTER)
                                              {
                                                      len1 = Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail+6)&SERIAL_COUNT]+9;
                                                      if(len >= len1)
                                                      {
                                                              for(i=0;i<len1;i++)
                                                              {
                                                                      tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 3   

                                                                      Uart_Struct[UART485].rx_tail++;
                                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                                                              }
                                                              if(Calculate_CRC16(tmp,len1)==0)
                                                              {
                                                                              Calculate_CRC16(tmp,6);
                                                                              Uatr_Send_Data(UART485,8,tmp);
                                                              }
                                                      }
                                              }
                                              else 
                                              {
                                                      Uart_Struct[UART485].rx_tail++;
                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                                              }
                                      }
                              }
                              else
                              {
                                      Uart_Struct[UART485].rx_tail++;
                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
                              }
                      }
              }
              #else // ÆÁÄ»×öÖ÷»ú
 141          void modbusRxTreat(void)
 142          {
 143   1              u16 len, len1, i, lentmp;
 144   1              u8 tmp[512];
 145   1              u16 headtmp;
 146   1              u8 tmp8;
 147   1      
 148   1              EA = 0;
 149   1              headtmp = Uart_Struct[UART485].rx_head;
 150   1              EA = 1;
 151   1              if (Uart_Struct[UART485].rx_tail != headtmp)
 152   1              {
 153   2                      if (Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail] == pNowOrder->SlaveAddr) // ²éÕÒµ±Ç°ÕýÔÚ·¢
             -ËÍÃüÁîµÄmodbusµØÖ·
 154   2                      {
 155   3                              if (headtmp < Uart_Struct[UART485].rx_tail)
 156   3                              {
 157   4                                      len = (headtmp + SERIAL_SIZE) - Uart_Struct[UART485].rx_tail;
 158   4                              }
 159   3                              else
 160   3                              {
 161   4                                      len = headtmp - Uart_Struct[UART485].rx_tail;
 162   4                              }
 163   3                              if (len >= START_TREAT_LENGTH) // »º´æµ½Ò»¶¨³¤¶Èºó²Å¿ªÊ¼´¦ÀíÊý¾Ý
 164   3                              {
 165   4                                      if (Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail + 1) & SERIAL_COUNT] == pNowOrder->Order
             -) // ²éÕÒµ½ÁËµØÖ·£¬²¢ÇÒºóÃæÊÇÏìÓ¦µÄÖ¸Áî
 166   4                                      {
 167   5                                              if (pNowOrder->Order == 0x01 || pNowOrder->Order == 0x02)
 168   5                                              {
 169   6                                                      len1 = Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail + 2) & SERIAL_COUNT];
 170   6                                                      lentmp = pNowOrder->Length / 8;
 171   6                                                      if ((pNowOrder->Length % 8) != 0)
 172   6                                                              lentmp++;
 173   6                                                      if (len1 == lentmp)
 174   6                                                      {
 175   7                                                              if (len >= len1 + 5)
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 4   

 176   7                                                              {
 177   8                                                                      for (i = 0; i < len1 + 5; i++)
 178   8                                                                      {
 179   9                                                                              tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
 180   9                                                                              Uart_Struct[UART485].rx_tail++;
 181   9                                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
 182   9                                                                      }
 183   8                                                                      if (Calculate_CRC16(tmp, len1 + 5, 0) == 0) // Ð£ÑéÕýÈ·
 184   8                                                                      {
 185   9                                                                              ModbusBusy = 0; // ±êÖ¾Î»±ä³É¿ÕÏÐ£¬¿ÉÒÔ¼ÌÐø·¢ËÍÏÂÒ»°üÊý¾Ý
 186   9                                                                              for (i = 0; i < pNowOrder->Length; i++)
 187   9                                                                              {
 188  10                                                                                      tmp8 = 0x01 << (i % 8);
 189  10                                                                                      if (tmp[3 + i / 8] & tmp8)
 190  10                                                                                              headtmp = 1;
 191  10                                                                                      else
 192  10                                                                                              headtmp = 0;
 193  10                                                                                      write_dgus_vp(pNowOrder->VPaddr + i, (u8 *)&headtmp, 1);
 194  10                                                                              }
 195   9                                                                              if (pNowOrder->databuff != NULL)
 196   9                                                                              {
 197  10                                                                                      memcpy(pNowOrder->databuff, tmp + 3, tmp[2]);
 198  10                                                                              }
 199   9                                                                      }
 200   8                                                              }
 201   7                                                      }
 202   6                                                      else
 203   6                                                      {
 204   7                                                              Uart_Struct[UART485].rx_tail++;
 205   7                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 206   7                                                      }
 207   6                                              }
 208   5                                              else if (0x03 == pNowOrder->Order)
 209   5                                              {
 210   6                                                      len1 = Uart_Struct[UART485].rx_buf[(Uart_Struct[UART485].rx_tail + 2) & SERIAL_COUNT];
 211   6                                                      lentmp = pNowOrder->Length << 1;
 212   6                                                      if (len1 == lentmp)
 213   6                                                      {
 214   7                                                              if (len >= len1 + 5)
 215   7                                                              {
 216   8                                                                      for (i = 0; i < len1 + 5; i++)
 217   8                                                                      {
 218   9                                                                              tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
 219   9                                                                              Uart_Struct[UART485].rx_tail++;
 220   9                                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
 221   9                                                                      }
 222   8                                                                      if (Calculate_CRC16(tmp, len1 + 5, 0) == 0) // Ð£ÑéÕýÈ·
 223   8                                                                      {
 224   9                                                                              ModbusBusy = 0; // ±êÖ¾Î»±ä³É¿ÕÏÐ£¬¿ÉÒÔ¼ÌÐø·¢ËÍÏÂÒ»°üÊý¾Ý
 225   9                                                                              if (pNowOrder->VPaddr != 0)
 226   9                                                                              {
 227  10                                                                                      write_dgus_vp(pNowOrder->VPaddr, &tmp[3], pNowOrder->Length);
 228  10                                                                              }
 229   9                                                                              if (pNowOrder->databuff != NULL)
 230   9                                                                              {
 231  10                                                                                      memcpy(pNowOrder->databuff, tmp + 3, tmp[2]);
 232  10                                                                              }
 233   9                                                                      }
 234   8                                                              }
 235   7                                                      }
 236   6                                                      else
 237   6                                                      {
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 5   

 238   7                                                              Uart_Struct[UART485].rx_tail++;
 239   7                                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 240   7                                                      }
 241   6                                              }
 242   5                                              else if ((0x05 == pNowOrder->Order) || (0x06 == pNowOrder->Order) || (0x10 == pNowOrder->Order))
 243   5                                              {
 244   6                                                      if (len >= 8)
 245   6                                                      {
 246   7                                                              for (i = 0; i < 8; i++)
 247   7                                                              {
 248   8                                                                      tmp[i] = Uart_Struct[UART485].rx_buf[Uart_Struct[UART485].rx_tail];
 249   8                                                                      Uart_Struct[UART485].rx_tail++;
 250   8                                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT;
 251   8                                                              }
 252   7                                                              if (Calculate_CRC16(tmp, 8, 0) == 0) // Ð£ÑéÕýÈ·
 253   7                                                              {
 254   8                                                                      if (*(u16 *)&tmp[2] == pNowOrder->ModbusReg)
 255   8                                                                      {
 256   9                                                                              ModbusBusy = 0; // ±êÖ¾Î»±ä³É¿ÕÏÐ£¬¿ÉÒÔ¼ÌÐø·¢ËÍÏÂÒ»°üÊý¾Ý
 257   9                                                                      }
 258   8                                                              }
 259   7                                                      }
 260   6                                              }
 261   5                                              else
 262   5                                              {
 263   6                                                      Uart_Struct[UART485].rx_tail++;
 264   6                                                      Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 265   6                                              }
 266   5                                      }
 267   4                                      else
 268   4                                      {
 269   5                                              Uart_Struct[UART485].rx_tail++;
 270   5                                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 271   5                                      }
 272   4                              }
 273   3                      }
 274   2                      else
 275   2                      {
 276   3                              Uart_Struct[UART485].rx_tail++;
 277   3                              Uart_Struct[UART485].rx_tail &= SERIAL_COUNT; // ¼ÌÐøËÑË÷
 278   3                      }
 279   2              }
 280   1      }
 281          #endif
 282          
 283          u8 AnalysisMosbusOrder(u8 *pBuf) // ¸ù¾Ýµ±Ç°Ö¸ÁîµÄ¸ñÊ½½«Òª·¢ËÍµÄÊý¾Ý·Åµ½PbufÀïÃæ£¬²¢·µ»Ø·¢ËÍ³¤¶È
 284          {
 285   1              u8 len;
 286   1              u8 tmp[4];
 287   1      
 288   1              if (pNowOrder->mode == 0)
 289   1              {
 290   2              }
 291   1              else if (pNowOrder->mode == 1)
 292   1              {
 293   2                      if (pNowOrder->flag == 0x5a)
 294   2                      {
 295   3                              pNowOrder->flag = 0x00;
 296   3                      }
 297   2                      else
 298   2                      {
 299   3                              return 0;
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 6   

 300   3                      }
 301   2              }
 302   1              else
 303   1              {
 304   2                      return 0;
 305   2              }
 306   1              len = 0;
 307   1              switch (pNowOrder->Order)
 308   1              {
 309   2              case 0x01: // ¶ÁÎ»×´Ì¬¼Ä´æÆ÷
 310   2                      if (pNowOrder->Length)
 311   2                      {
 312   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 313   3                              pBuf[1] = 0x01;                                 // ¹¦ÄÜÂë
 314   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 315   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // Î»¼Ä´æÆ÷ÆðÊ¼µØÖ·
 316   3                              pBuf[4] = 0;
 317   3                              pBuf[5] = pNowOrder->Length; // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö255
 318   3                              len = 6;
 319   3                      }
 320   2                      else
 321   2                      {
 322   3                              len = 0;
 323   3                      }
 324   2                      break;
 325   2              case 0x02: // ¶ÁÎ»×´Ì¬¼Ä´æÆ÷
 326   2                      if (pNowOrder->Length)
 327   2                      {
 328   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 329   3                              pBuf[1] = 0x02;                                 // ¹¦ÄÜÂë
 330   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 331   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // Î»¼Ä´æÆ÷ÆðÊ¼µØÖ·
 332   3                              pBuf[4] = 0;
 333   3                              pBuf[5] = pNowOrder->Length; // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö255
 334   3                              len = 6;
 335   3                      }
 336   2                      else
 337   2                      {
 338   3                              len = 0;
 339   3                      }
 340   2                      break;
 341   2              case 0x03: // ¶Á±£³Ö¼Ä´æÆ÷
 342   2                      if (pNowOrder->Length)
 343   2                      {
 344   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 345   3                              pBuf[1] = 0x03;                                 // ¹¦ÄÜÂë
 346   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 347   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 348   3                              pBuf[4] = 0;
 349   3                              pBuf[5] = pNowOrder->Length; // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö255
 350   3                              len = 6;
 351   3                      }
 352   2                      else
 353   2                      {
 354   3                              len = 0;
 355   3                      }
 356   2                      break;
 357   2              case 0x05:                                                      // Ð´µ¥¸öÎ»¼Ä´æÆ÷
 358   2                      pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 359   2                      pBuf[1] = 0x05;                                 // ¹¦ÄÜÂë
 360   2                      pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 361   2                      pBuf[3] = (u8)(pNowOrder->ModbusReg); // Î»¼Ä´æÆ÷ÆðÊ¼µØÖ·
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 7   

 362   2                      if (pNowOrder->databuff != NULL)
 363   2                      {
 364   3                              memcpy(tmp, (uint8_t *)pNowOrder->databuff, 2);
 365   3                      }
 366   2                      else if (pNowOrder->VPaddr != 0)
 367   2                      {
 368   3                              read_dgus_vp(pNowOrder->VPaddr, tmp, 1);
 369   3                      }
 370   2                      if (tmp[1])
 371   2                              pBuf[4] = 0xff; // Î»×ªÌ¬ÎªON
 372   2                      else
 373   2                              pBuf[4] = 0; // Î»×´Ì¬ÎªOFF
 374   2                      pBuf[5] = 0x00;
 375   2                      len = 6;
 376   2                      break;
 377   2              case 0x06:                                                      // Ð´µ¥¸ö¼Ä´æÆ÷
 378   2                      pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 379   2                      pBuf[1] = 0x06;                                 // ¹¦ÄÜÂë
 380   2                      pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 381   2                      pBuf[3] = (u8)(pNowOrder->ModbusReg); // ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 382   2                      if (pNowOrder->databuff != NULL)
 383   2                      {
 384   3                              memcpy(&pBuf[4], (uint8_t *)pNowOrder->databuff, 2);
 385   3                      }
 386   2                      else if (pNowOrder->VPaddr != 0)
 387   2                      {
 388   3                              read_dgus_vp(pNowOrder->VPaddr, &pBuf[4], 1);
 389   3                      }
 390   2                      len = 6;
 391   2                      break;
 392   2              case 0x10: // Ð´¶à¸ö¼Ä´æÆ÷
 393   2                      if ((pNowOrder->Length > 0) && (pNowOrder->Length < 0x7b))
 394   2                      {
 395   3                              pBuf[0] = pNowOrder->SlaveAddr; // ´Ó»úµØÖ·
 396   3                              pBuf[1] = 0x10;                                 // ¹¦ÄÜÂë
 397   3                              pBuf[2] = (u8)(pNowOrder->ModbusReg >> 8);
 398   3                              pBuf[3] = (u8)(pNowOrder->ModbusReg); // ¼Ä´æÆ÷ÆðÊ¼µØÖ·
 399   3                              pBuf[4] = 0;
 400   3                              pBuf[5] = pNowOrder->Length;      // Î»¼Ä´æÆ÷³¤¶È£¬×î´óÖ§³Ö0x7b
 401   3                              pBuf[6] = pNowOrder->Length << 1; // Ð´Èë¼Ä´æÆ÷×Ö½ÚÊý
 402   3                              len = pBuf[6] + 7;
 403   3                              if (pNowOrder->databuff != NULL)
 404   3                              {
 405   4                                      memcpy(&pBuf[7], (uint8_t *)pNowOrder->databuff, pNowOrder->Length * 2);
 406   4                              }
 407   3                              else if (pNowOrder->VPaddr != 0)
 408   3                              {
 409   4                                      read_dgus_vp(pNowOrder->VPaddr, &pBuf[7], pNowOrder->Length); // Êµ¼ÊÊý¾Ý
 410   4                              }
 411   3                      }
 412   2                      else
 413   2                      {
 414   3                              len = 0;
 415   3                      }
 416   2                      break;
 417   2              default:
 418   2                      break;
 419   2              }
 420   1              if (len)
 421   1              {
 422   2                      Calculate_CRC16(pBuf, len, 1);
 423   2                      return len + 2; // ·µ»Ø·¢ËÍ³¤¶È+2×Ö½ÚCRC
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 8   

 424   2              }
 425   1              return 0; // 0±íÊ¾±¾ÌõÖ¸ÁîÎÞÐ§
 426   1      }
 427          
 428          void modbusTxTreat(void)
 429          {
 430   1              u8 sendbuf[512];
 431   1              u8 len;
 432   1      
 433   1              if (ModbusBusy) // ÓÐÊý¾ÝÕýÔÚ´¦ÀíµÄÊ±ºò£¬²»´¦Àí·¢ËÍ
 434   1                      return;
 435   1              pNowOrder = popFromEmergency();
 436   1              if (pNowOrder != NULL)
 437   1              {
 438   2                      len = AnalysisMosbusOrder(sendbuf);
 439   2                      if (len)
 440   2                      {
 441   3                              ModbusBusy = 1;
 442   3                              Uart_Send_Data(UART485, len, sendbuf);
 443   3                              StartTimer(MODBUS_TIMER, pNowOrder->waitTime);
 444   3                      }
 445   2              }
 446   1              else
 447   1              {
 448   2                      if (modbusNum == 0) // µ±Ç°Ò³µÄ¼Ä´æÆ÷¸öÊýÎª0µÄÊ±ºò£¬²»´¦Àí·¢ËÍ
 449   2                      {
 450   3                              modbusTreatID = 0;
 451   3                              return;
 452   3                      }
 453   2                      pNowOrder = &pageModbusReg[modbusTreatID];
 454   2                      modbusTreatID++;
 455   2                      if (modbusTreatID >= modbusNum)
 456   2                              modbusTreatID = 0;
 457   2                      len = AnalysisMosbusOrder(sendbuf);
 458   2                      if (len)
 459   2                      {
 460   3                              ModbusBusy = 1;
 461   3                              Uart_Send_Data(UART485, len, sendbuf);
 462   3                              StartTimer(MODBUS_TIMER, pNowOrder->waitTime);
 463   3                      }
 464   2              }
 465   1      }
 466          
 467          void modbusTreat(void)
 468          {
 469   1              if (ModbusBusy)
 470   1              {
 471   2                      if (GetTimeOutFlag(MODBUS_TIMER)) // ³¬Ê±ºó£¬Ç¿ÖÆ´¦ÀíÏÂÒ»°ü
 472   2                      {
 473   3                              ModbusBusy = 0;
 474   3                              EA = 0;
 475   3                              Uart_Struct[UART485].rx_tail = Uart_Struct[UART485].rx_head;
 476   3                              EA = 1;
 477   3                      }
 478   2              }
 479   1              modbusTxTreat();
 480   1              modbusRxTreat();
 481   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3088    ----
C51 COMPILER V9.60.7.0   MODBUS                                                            05/06/2023 10:07:16 PAGE 9   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1016    1043
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
