C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UI
OBJECT MODULE PLACED IN .\Objects\ui.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\ui.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.\li
                    -b) DEBUG OBJECTEXTEND PRINT(.\Listings\ui.lst) OBJECT(.\Objects\ui.obj)

line level    source

   1          #include "ui.h"
   2          #include "modbus.h"
   3          #include <STRING.H>
   4          #include "permission.h"
   5          #include "debug.h"
   6          #include "norflash.h"
   7          #include <STDLIB.H>
   8          #include "rtc.h"
   9          #include "const.h"
  10          #include "data.h"
  11          #include "umath.h"
  12          #include "timer.h"
  13          #include "alarm.h"
  14          
  15          #define testDis 0
  16          void testDisplayNum(u16 addr, u16 num)
  17          {
  18   1      #if testDis
              
              #else
  21   1              write_dgus_vp(addr, (u8 *)&num, 1);
  22   1      #endif
  23   1      }
  24          
  25          // 读取按键0x1000的值
  26          u8 getTouch(void)
  27          {
  28   1              u8 tmp;
  29   1              // EA = 0;
  30   1              ADR_H = 0x00;
  31   1              ADR_M = 0x08; // 0x1000
  32   1              ADR_L = 0x00;
  33   1              ADR_INC = 1;
  34   1              RAMMODE = 0xAF;
  35   1              while (!APP_ACK)
  36   1                      ;
  37   1              APP_EN = 1;
  38   1              while (APP_EN)
  39   1                      ;
  40   1              // str[0] = DATA3;
  41   1              tmp = DATA2;
  42   1              // EA = 1;
  43   1              RAMMODE = 0;
  44   1              return tmp;
  45   1      }
  46          
  47          // 清除按键0x1000的值
  48          void clrTouch(void)
  49          {
  50   1              // EA = 0;
  51   1              ADR_H = 0x00;
  52   1              ADR_M = 0x08; // 0x1000
  53   1              ADR_L = 0x00;
  54   1              ADR_INC = 1;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 2   

  55   1              RAMMODE = 0x8C;
  56   1              while (!APP_ACK)
  57   1                      ;
  58   1              DATA3 = 0;
  59   1              DATA2 = 0;
  60   1              APP_EN = 1;
  61   1              while (APP_EN)
  62   1                      ;
  63   1              RAMMODE = 0;
  64   1              // EA = 1;
  65   1      }
  66          
  67          void P0Func(void)
  68          {
  69   1              VariableChangedIndicationTypeDef variableChangedIndication;
  70   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
  71   1              if (variableChangedIndication.flag == 0x5A)
  72   1              {
  73   2                      uint16_t variable[5];
  74   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
  75   2                      switch (variableChangedIndication.addr)
  76   2                      {
  77   3                      case 0x8000:
  78   3                              if (variable[0] == 1)
  79   3                              {
  80   4                                      if (manager.loginFlag || admin.loginFlag)
  81   4                                      {
  82   5                                              Page_Change(SYS_FUNCTION_TABLE_PAGE);
  83   5                                      }
  84   4                                      else
  85   4                                      {
  86   5                                              passwordLogin(SYS_FUNCTION_TABLE_PAGE);
  87   5                                      }
  88   4                              }
  89   3                              break;
  90   3                      case 0x8001:
  91   3                              if (variable[0] == 1)
  92   3                              {
  93   4                                      if (manager.loginFlag || admin.loginFlag)
  94   4                                      {
  95   5                                              Page_Change(BATTERY_MANAGER_PAGE);
  96   5                                      }
  97   4                                      else
  98   4                                      {
  99   5                                              passwordLogin(BATTERY_MANAGER_PAGE);
 100   5                                      }
 101   4                              }
 102   3                              break;
 103   3                      case 0x8006:
 104   3                              if (variable[0] == 1)
 105   3                              {
 106   4                                      if (chargeModuleSet.moduleNum > 0)
 107   4                                      {
 108   5                                              Page_Change(CHARGE_DATA_PAGE);
 109   5                                      }
 110   4                              }
 111   3                              break;
 112   3                      case 0x8007:
 113   3                              if (variable[0] == 1)
 114   3                              {
 115   4                                      if (batterySet.batteryType == XJ24)
 116   4                                      {
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 3   

 117   5                                              if (batterySet.xj24.batteryModuleNum > 0)
 118   5                                              {
 119   6                                                      Page_Change(BATTERY_DATA_PAGE);
 120   6                                              }
 121   5                                      }
 122   4                                      else if (batterySet.batteryType == XJ55)
 123   4                                      {
 124   5                                              if (batterySet.xj55.batteryModuleNum > 0)
 125   5                                              {
 126   6                                                      Page_Change(BATTERY_DATA_PAGE);
 127   6                                              }
 128   5                                      }
 129   4                              }
 130   3                              break;
 131   3                      case 0x8008:
 132   3                              if (variable[0] == 1)
 133   3                              {
 134   4                                      if (switchModuleSet.switchModule.switchNum > 0)
 135   4                                      {
 136   5                                              Page_Change(SWITCH_MODULE_DATA_PAGE);
 137   5                                      }
 138   4                              }
 139   3                              break;
 140   3                      case 0x800A:
 141   3                              if (variable[0] == 1)
 142   3                              {
 143   4                                      if (UPS_INV_Set.UPS_Num > 0)
 144   4                                      {
 145   5                                              Page_Change(UPS_DATA_PAGE);
 146   5                                      }
 147   4                              }
 148   3                              break;
 149   3                      case 0x800B:
 150   3                              if (variable[0] == 1)
 151   3                              {
 152   4                                      if (DC_ConverterSet.Num > 0)
 153   4                                      {
 154   5                                              Page_Change(DC_CONVERTER_DATA_PAGE);
 155   5                                      }
 156   4                              }
 157   3                              break;
 158   3                      case 0x800C:
 159   3                              if (variable[0] == 1)
 160   3                              {
 161   4                                      if (insulationSet.DC.Num > 0)
 162   4                                      {
 163   5                                              Page_Change(INSULATION_DATA_PAGE);
 164   5                                      }
 165   4                                      else
 166   4                                      {
 167   5                                              Page_Change(NON_INSULATION_DATA_PAGE);
 168   5                                      }
 169   4                              }
 170   3                              break;
 171   3                      default:
 172   3                              break;
 173   3                      }
 174   2                      memset(variable, 0, 5);
 175   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 176   2                      variableChangedIndication.flag = 0;
 177   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 178   2              }
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 4   

 179   1      
 180   1              if (manager.loginFlag)
 181   1              {
 182   2                      manager.loginFlag = 0;
 183   2              }
 184   1              if (admin.loginFlag)
 185   1              {
 186   2                      admin.loginFlag = 0;
 187   2              }
 188   1      }
 189          
 190          void P2Func(void)
 191          {
 192   1              VariableChangedIndicationTypeDef variableChangedIndication;
 193   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 194   1              if (variableChangedIndication.flag == 0x5A)
 195   1              {
 196   2                      uint16_t variable[5];
 197   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 198   2                      switch (variableChangedIndication.addr)
 199   2                      {
 200   3                      case 0x8020:
 201   3                              if (variable[0] == 1)
 202   3                              {
 203   4                                      if (manager.loginFlag || admin.loginFlag)
 204   4                                      {
 205   5                                              Page_Change(SYS_INFO_PAGE);
 206   5                                      }
 207   4                                      else
 208   4                                      {
 209   5                                              passwordLogin(SYS_INFO_PAGE);
 210   5                                      }
 211   4                              }
 212   3                              break;
 213   3                      case 0x8021:
 214   3                              if (variable[0] == 1)
 215   3                              {
 216   4                                      if (manager.loginFlag || admin.loginFlag)
 217   4                                      {
 218   5                                              Page_Change(SWITCH_MODULE_SET_PAGE);
 219   5                                      }
 220   4                                      else
 221   4                                      {
 222   5                                              passwordLogin(SWITCH_MODULE_SET_PAGE);
 223   5                                      }
 224   4                              }
 225   3                              break;
 226   3                      case 0x8022:
 227   3                              if (variable[0] == 1)
 228   3                              {
 229   4                                      if (manager.loginFlag || admin.loginFlag)
 230   4                                      {
 231   5                                              Page_Change(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 232   5                                      }
 233   4                                      else
 234   4                                      {
 235   5                                              passwordLogin(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 236   5                                      }
 237   4                              }
 238   3                              break;
 239   3                      case 0x8023:
 240   3                              if (variable[0] == 1)
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 5   

 241   3                              {
 242   4                                      if (manager.loginFlag || admin.loginFlag)
 243   4                                      {
 244   5                                              Page_Change(INSULATION_SET_PAGE);
 245   5                                      }
 246   4                                      else
 247   4                                      {
 248   5                                              passwordLogin(INSULATION_SET_PAGE);
 249   5                                      }
 250   4                              }
 251   3                              break;
 252   3                      case 0x8024:
 253   3                              if (variable[0] == 1)
 254   3                              {
 255   4                                      if (manager.loginFlag || admin.loginFlag)
 256   4                                      {
 257   5                                              Page_Change(CHARGER_MODULE_SET_PAGE);
 258   5                                      }
 259   4                                      else
 260   4                                      {
 261   5                                              passwordLogin(CHARGER_MODULE_SET_PAGE);
 262   5                                      }
 263   4                              }
 264   3                              break;
 265   3                      case 0x8025:
 266   3                              if (variable[0] == 1)
 267   3                              {
 268   4                                      if (manager.loginFlag || admin.loginFlag)
 269   4                                      {
 270   5                                              Page_Change(DC_MODULE_SET_PAGE);
 271   5                                      }
 272   4                                      else
 273   4                                      {
 274   5                                              passwordLogin(DC_MODULE_SET_PAGE);
 275   5                                      }
 276   4                              }
 277   3                              break;
 278   3                      case 0x8026:
 279   3                              if (variable[0] == 1)
 280   3                              {
 281   4                                      if (manager.loginFlag || admin.loginFlag)
 282   4                                      {
 283   5                                              Page_Change(UPS_INV_SET_PAGE);
 284   5                                      }
 285   4                                      else
 286   4                                      {
 287   5                                              passwordLogin(UPS_INV_SET_PAGE);
 288   5                                      }
 289   4                              }
 290   3                              break;
 291   3                      case 0x8027:
 292   3                              if (variable[0] == 1)
 293   3                              {
 294   4                                      if (admin.loginFlag)
 295   4                                      {
 296   5                                              Page_Change(RECOVERY_PAGE);
 297   5                                      }
 298   4                                      else
 299   4                                      {
 300   5                                              passwordLogin(RECOVERY_PAGE);
 301   5                                      }
 302   4                              }
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 6   

 303   3                              break;
 304   3      
 305   3                      default:
 306   3                              break;
 307   3                      }
 308   2                      memset(variable, 0, 5);
 309   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 310   2                      variableChangedIndication.flag = 0;
 311   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 312   2              }
 313   1      }
 314          
 315          void P11Func(void)
 316          {
 317   1              VariableChangedIndicationTypeDef variableChangedIndication;
 318   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 319   1              if (variableChangedIndication.flag == 0x5A)
 320   1              {
 321   2                      uint16_t variable[5];
 322   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 323   2                      switch (variableChangedIndication.addr)
 324   2                      {
 325   3                      case 0x8041:
 326   3                              if (variable[0] == 1)
 327   3                              {
 328   4                                      read_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE);
 329   4                                      dgusToNorFlash(SYS_INFO_NORFLASH_ADDR, SYS_INFO_VP, SYS_INFO_SIZE);
 330   4                                      modbusCenerate();
 331   4                                      // DEBUGINFO("save sysInfo");
 332   4                              }
 333   3                              break;
 334   3                      default:
 335   3                              break;
 336   3                      }
 337   2                      memset(variable, 0, 5);
 338   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 339   2      
 340   2                      variableChangedIndication.flag = 0;
 341   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 342   2              }
 343   1      }
 344          
 345          void P12Func()
 346          {
 347   1              VariableChangedIndicationTypeDef variableChangedIndication;
 348   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 349   1              if (variableChangedIndication.flag == 0x5A)
 350   1              {
 351   2                      uint16_t variable[5];
 352   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 353   2                      switch (variableChangedIndication.addr)
 354   2                      {
 355   3                      case 0x8060:
 356   3                              if (variable[0] == 1)
 357   3                              {
 358   4                                      read_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
 359   4                                      dgusToNorFlash(AC_INFO_NORFLASH_ADDR, AC_INFO_VP, AC_INFO_SIZE);
 360   4                                      modbusCenerate();
 361   4                              }
 362   3                              break;
 363   3                      default:
 364   3                              break;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 7   

 365   3                      }
 366   2                      memset(variable, 0, 5);
 367   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 368   2      
 369   2                      variableChangedIndication.flag = 0;
 370   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 371   2              }
 372   1      }
 373          
 374          void P18Func()
 375          {
 376   1              VariableChangedIndicationTypeDef variableChangedIndication;
 377   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 378   1              if (variableChangedIndication.flag == 0x5A)
 379   1              {
 380   2                      uint16_t variable[5];
 381   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 382   2                      switch (variableChangedIndication.addr)
 383   2                      {
 384   3                      case 0x8060:
 385   3                              if (variable[0] == 1)
 386   3                              {
 387   4                                      read_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
 388   4                                      dgusToNorFlash(DC_INFO_NORFLASH_ADDR, DC_INFO_VP, DC_INFO_SIZE);
 389   4                                      modbusCenerate();
 390   4                              }
 391   3                              break;
 392   3                      case 0x90B1:
 393   3                      {
 394   4                              if (sysInfoSet.siliconChain == 0)
 395   4                              {
 396   5                                      write_dgus_vp(0x90A1, (uint8_t *)&variable, 1);
 397   5                              }
 398   4                              else
 399   4                              {
 400   5                                      write_dgus_vp(0x90A5, (uint8_t *)&variable, 1);
 401   5                              }
 402   4                      }
 403   3                      break;
 404   3                      case 0x90B2:
 405   3                      {
 406   4                              if (sysInfoSet.siliconChain == 0)
 407   4                              {
 408   5                                      write_dgus_vp(0x90A2, (uint8_t *)&variable, 1);
 409   5                              }
 410   4                              else
 411   4                              {
 412   5                                      write_dgus_vp(0x90A6, (uint8_t *)&variable, 1);
 413   5                              }
 414   4                      }
 415   3                      break;
 416   3                      case 0x90B3:
 417   3                      {
 418   4                              if (sysInfoSet.siliconChain == 0)
 419   4                              {
 420   5                                      write_dgus_vp(0x90A3, (uint8_t *)&variable, 1);
 421   5                              }
 422   4                              else
 423   4                              {
 424   5                                      write_dgus_vp(0x90A7, (uint8_t *)&variable, 1);
 425   5                              }
 426   4                      }
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 8   

 427   3                      break;
 428   3                      case 0x90B4:
 429   3                      {
 430   4                              if (sysInfoSet.siliconChain == 0)
 431   4                              {
 432   5                                      write_dgus_vp(0x90A4, (uint8_t *)&variable, 1);
 433   5                              }
 434   4                              else
 435   4                              {
 436   5                                      write_dgus_vp(0x90A8, (uint8_t *)&variable, 1);
 437   5                              }
 438   4                      }
 439   3                      break;
 440   3                      default:
 441   3                              break;
 442   3                      }
 443   2                      memset(variable, 0, 5);
 444   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)variable, variableChangedIndication.len);
 445   2      
 446   2                      variableChangedIndication.flag = 0;
 447   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 448   2              }
 449   1      
 450   1              {
 451   2                      if (sysInfoSet.sysVoltageGrade == SYSTEM_220V)
 452   2                      {
 453   3                              uint16_t sp; // 描述指针
 454   3                              sp = 0x90A1;
 455   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 456   3                              sp = 0x90A2;
 457   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 458   3                              sp = 0x90A3;
 459   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 460   3                              sp = 0x90A4;
 461   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 462   3                      }
 463   2                      else if (sysInfoSet.sysVoltageGrade == SYSTEM_110V)
 464   2                      {
 465   3                              uint16_t sp; // 描述指针
 466   3                              sp = 0x90A5;
 467   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 468   3                              sp = 0x90A6;
 469   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 470   3                              sp = 0x90A7;
 471   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 472   3                              sp = 0x90A8;
 473   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 474   3                      }
 475   2              }
 476   1      }
 477          
 478          void P22Func()
 479          {
 480   1              VariableChangedIndicationTypeDef variableChangedIndication;
 481   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 482   1              if (variableChangedIndication.flag == 0x5A)
 483   1              {
 484   2                      uint16_t variable[5];
 485   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 486   2                      switch (variableChangedIndication.addr)
 487   2                      {
 488   3                      case 0x8080:
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 9   

 489   3                              if (variable[0] == 1)
 490   3                              {
 491   4                                      read_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
 492   4                                      dgusToNorFlash(BATTERY_INFO_NORFLASH_ADDR, BATTERY_INFO_VP, BATTERY_SET_SIZE);
 493   4                                      modbusCenerate();
 494   4                              }
 495   3                              break;
 496   3                      case 0x9120:
 497   3                              if (variable[0] == 1)
 498   3                              {
 499   4                                      chargeModeSwitch(FLOAT_CHARGE);
 500   4                              }
 501   3                              break;
 502   3                      case 0x9121:
 503   3                              if (variable[0] == 1)
 504   3                              {
 505   4                                      chargeModeSwitch(EQUALIZE_CHARGE);
 506   4                              }
 507   3                              break;
 508   3                      default:
 509   3                              break;
 510   3                      }
 511   2                      memset(variable, 0, 5);
 512   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 513   2      
 514   2                      variableChangedIndication.flag = 0;
 515   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 516   2              }
 517   1      }
 518          void P24Func()
 519          {
 520   1              VariableChangedIndicationTypeDef variableChangedIndication;
 521   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 522   1              if (variableChangedIndication.flag == 0x5A)
 523   1              {
 524   2                      uint16_t variable[5];
 525   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 526   2                      switch (variableChangedIndication.addr)
 527   2                      {
 528   3                      case 0x9151:
 529   3                      {
 530   4                              extern uint16_t slaveID[2];
 531   4                              // DEBUGINFO("slaveID = %d ", slaveID[0]);
 532   4                              read_dgus_vp(0x9151, (uint8_t *)slaveID, 1);
 533   4                              // DEBUGINFO("slaveID = %d ", slaveID[0]);
 534   4                              Nor_Flash_write(SLAVE_ID_NORFLASH_ADDR, (uint8_t *)slaveID, 2);
 535   4                      }
 536   3                      break;
 537   3                      default:
 538   3                              break;
 539   3                      }
 540   2      
 541   2                      variableChangedIndication.flag = 0;
 542   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 543   2              }
 544   1      }
 545          
 546          void P26Func()
 547          {
 548   1              VariableChangedIndicationTypeDef variableChangedIndication;
 549   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 550   1              if (variableChangedIndication.flag == 0x5A)
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 10  

 551   1              {
 552   2                      uint16_t variable[5];
 553   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 554   2                      switch (variableChangedIndication.addr)
 555   2                      {
 556   3                      case 0x9150:
 557   3                              if (variable[0] == 1)
 558   3                              {
 559   4                                      passwordLogin(26);
 560   4                              }
 561   3                              break;
 562   3                      case 0x9152:
 563   3                              if (variable[0] == 1)
 564   3                              {
 565   4                                      manager.loginFlag = 0;
 566   4                                      admin.loginFlag = 0;
 567   4                              }
 568   3                              break;
 569   3                      default:
 570   3                              break;
 571   3                      }
 572   2                      memset(variable, 0, 5);
 573   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 574   2                      variableChangedIndication.flag = 0;
 575   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 576   2              }
 577   1      
 578   1              { // 当前登录用户显示
 579   2                      int16_t userNum;
 580   2                      if (admin.loginFlag)
 581   2                      {
 582   3                              userNum = 2;
 583   3                      }
 584   2                      else if (manager.loginFlag)
 585   2                      {
 586   3                              userNum = 1;
 587   3                      }
 588   2                      else
 589   2                      {
 590   3                              userNum = 0;
 591   3                      }
 592   2                      write_dgus_vp(0x9160, (uint8_t *)&userNum, 1);
 593   2              }
 594   1      }
 595          
 596          void P29Func()
 597          {
 598   1              VariableChangedIndicationTypeDef variableChangedIndication;
 599   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 600   1              if (variableChangedIndication.flag == 0x5A)
 601   1              {
 602   2                      uint16_t variable[5];
 603   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 604   2                      switch (variableChangedIndication.addr)
 605   2                      {
 606   3                      case 0x80C0:
 607   3                              if (variable[0] == 1)
 608   3                              {
 609   4                                      read_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, SPECIAL_PARA_SIZE);
 610   4                                      dgusToNorFlash(SPECIAL_PARA_NORFLASH_ADDR, SPECIAL_PARA_VP, SPECIAL_PARA_SIZE);
 611   4                                      modbusCenerate();
 612   4                              }
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 11  

 613   3                              break;
 614   3                      case 0x91B2:
 615   3                      {
 616   4                              static MMODBUS closeBusVoltRectify;
 617   4                              closeBusVoltRectify.SlaveAddr = 0x61;
 618   4                              closeBusVoltRectify.mode = 0x00;
 619   4                              closeBusVoltRectify.flag = 0x00;
 620   4                              closeBusVoltRectify.Order = 0x06;
 621   4                              closeBusVoltRectify.Length = 0x01;
 622   4                              closeBusVoltRectify.reserved = 0x00;
 623   4                              closeBusVoltRectify.waitTime = 1000;
 624   4                              closeBusVoltRectify.VPaddr = 0x91B2;
 625   4                              closeBusVoltRectify.ModbusReg = 0x0000;
 626   4                              closeBusVoltRectify.databuff = NULL;
 627   4                              pushToEmergency(&closeBusVoltRectify);
 628   4                      }
 629   3                      break;
 630   3                      case 0x91B3:
 631   3                      {
 632   4                              static MMODBUS controlBusVoltRectify;
 633   4                              controlBusVoltRectify.SlaveAddr = 0x61;
 634   4                              controlBusVoltRectify.mode = 0x00;
 635   4                              controlBusVoltRectify.flag = 0x00;
 636   4                              controlBusVoltRectify.Order = 0x06;
 637   4                              controlBusVoltRectify.Length = 0x01;
 638   4                              controlBusVoltRectify.reserved = 0x00;
 639   4                              controlBusVoltRectify.waitTime = 1000;
 640   4                              controlBusVoltRectify.VPaddr = 0x91B3;
 641   4                              controlBusVoltRectify.ModbusReg = 0x0001;
 642   4                              controlBusVoltRectify.databuff = NULL;
 643   4                              pushToEmergency(&controlBusVoltRectify);
 644   4                      }
 645   3                      break;
 646   3                      case 0x91B4:
 647   3                      {
 648   4                              static MMODBUS busToGroundVoltRectify;
 649   4                              busToGroundVoltRectify.SlaveAddr = 0x61;
 650   4                              busToGroundVoltRectify.mode = 0x00;
 651   4                              busToGroundVoltRectify.flag = 0x00;
 652   4                              busToGroundVoltRectify.Order = 0x06;
 653   4                              busToGroundVoltRectify.Length = 0x01;
 654   4                              busToGroundVoltRectify.reserved = 0x00;
 655   4                              busToGroundVoltRectify.waitTime = 1000;
 656   4                              busToGroundVoltRectify.VPaddr = 0x91B4;
 657   4                              busToGroundVoltRectify.ModbusReg = 0x0002;
 658   4                              busToGroundVoltRectify.databuff = NULL;
 659   4                              pushToEmergency(&busToGroundVoltRectify);
 660   4                      }
 661   3                      break;
 662   3                      case 0x91B5:
 663   3                      {
 664   4                              static MMODBUS batteryVoltRectify;
 665   4                              batteryVoltRectify.SlaveAddr = 0x61;
 666   4                              batteryVoltRectify.mode = 0x00;
 667   4                              batteryVoltRectify.flag = 0x00;
 668   4                              batteryVoltRectify.Order = 0x06;
 669   4                              batteryVoltRectify.Length = 0x01;
 670   4                              batteryVoltRectify.reserved = 0x00;
 671   4                              batteryVoltRectify.waitTime = 1000;
 672   4                              batteryVoltRectify.VPaddr = 0x91B5;
 673   4                              batteryVoltRectify.ModbusReg = 0x0003;
 674   4                              batteryVoltRectify.databuff = NULL;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 12  

 675   4                              pushToEmergency(&batteryVoltRectify);
 676   4                      }
 677   3                      break;
 678   3      
 679   3                      case 0x91B6:
 680   3                      {
 681   4                              static MMODBUS AC1_Ua_Rectify;
 682   4                              AC1_Ua_Rectify.SlaveAddr = 0x61;
 683   4                              AC1_Ua_Rectify.mode = 0x00;
 684   4                              AC1_Ua_Rectify.flag = 0x00;
 685   4                              AC1_Ua_Rectify.Order = 0x06;
 686   4                              AC1_Ua_Rectify.Length = 0x01;
 687   4                              AC1_Ua_Rectify.reserved = 0x00;
 688   4                              AC1_Ua_Rectify.waitTime = 1000;
 689   4                              AC1_Ua_Rectify.VPaddr = 0x91B6;
 690   4                              AC1_Ua_Rectify.ModbusReg = 0x0006;
 691   4                              AC1_Ua_Rectify.databuff = NULL;
 692   4                              pushToEmergency(&AC1_Ua_Rectify);
 693   4                      }
 694   3                      break;
 695   3      
 696   3                      case 0x91B7:
 697   3                      {
 698   4                              static MMODBUS AC1_Ub_Rectify;
 699   4                              AC1_Ub_Rectify.SlaveAddr = 0x61;
 700   4                              AC1_Ub_Rectify.mode = 0x00;
 701   4                              AC1_Ub_Rectify.flag = 0x00;
 702   4                              AC1_Ub_Rectify.Order = 0x06;
 703   4                              AC1_Ub_Rectify.Length = 0x01;
 704   4                              AC1_Ub_Rectify.reserved = 0x00;
 705   4                              AC1_Ub_Rectify.waitTime = 1000;
 706   4                              AC1_Ub_Rectify.VPaddr = 0x91B7;
 707   4                              AC1_Ub_Rectify.ModbusReg = 0x0007;
 708   4                              AC1_Ub_Rectify.databuff = NULL;
 709   4                              pushToEmergency(&AC1_Ub_Rectify);
 710   4                      }
 711   3                      break;
 712   3                      case 0x91B8:
 713   3                      {
 714   4                              static MMODBUS AC1_Uc_Rectify;
 715   4                              AC1_Uc_Rectify.SlaveAddr = 0x61;
 716   4                              AC1_Uc_Rectify.mode = 0x00;
 717   4                              AC1_Uc_Rectify.flag = 0x00;
 718   4                              AC1_Uc_Rectify.Order = 0x06;
 719   4                              AC1_Uc_Rectify.Length = 0x01;
 720   4                              AC1_Uc_Rectify.reserved = 0x00;
 721   4                              AC1_Uc_Rectify.waitTime = 1000;
 722   4                              AC1_Uc_Rectify.VPaddr = 0x91B8;
 723   4                              AC1_Uc_Rectify.ModbusReg = 0x0008;
 724   4                              AC1_Uc_Rectify.databuff = NULL;
 725   4                              pushToEmergency(&AC1_Uc_Rectify);
 726   4                      }
 727   3                      break;
 728   3                      case 0x91B9:
 729   3                      {
 730   4                              static MMODBUS AC2_Ua_Rectify;
 731   4                              AC2_Ua_Rectify.SlaveAddr = 0x61;
 732   4                              AC2_Ua_Rectify.mode = 0x00;
 733   4                              AC2_Ua_Rectify.flag = 0x00;
 734   4                              AC2_Ua_Rectify.Order = 0x06;
 735   4                              AC2_Ua_Rectify.Length = 0x01;
 736   4                              AC2_Ua_Rectify.reserved = 0x00;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 13  

 737   4                              AC2_Ua_Rectify.waitTime = 1000;
 738   4                              AC2_Ua_Rectify.VPaddr = 0x91B9;
 739   4                              AC2_Ua_Rectify.ModbusReg = 0x0009;
 740   4                              AC2_Ua_Rectify.databuff = NULL;
 741   4                              pushToEmergency(&AC2_Ua_Rectify);
 742   4                      }
 743   3                      break;
 744   3                      case 0x91BA:
 745   3                      {
 746   4                              static MMODBUS AC2_Ub_Rectify;
 747   4                              AC2_Ub_Rectify.SlaveAddr = 0x61;
 748   4                              AC2_Ub_Rectify.mode = 0x00;
 749   4                              AC2_Ub_Rectify.flag = 0x00;
 750   4                              AC2_Ub_Rectify.Order = 0x06;
 751   4                              AC2_Ub_Rectify.Length = 0x01;
 752   4                              AC2_Ub_Rectify.reserved = 0x00;
 753   4                              AC2_Ub_Rectify.waitTime = 1000;
 754   4                              AC2_Ub_Rectify.VPaddr = 0x91BA;
 755   4                              AC2_Ub_Rectify.ModbusReg = 0x000A;
 756   4                              AC2_Ub_Rectify.databuff = NULL;
 757   4                              pushToEmergency(&AC2_Ub_Rectify);
 758   4                      }
 759   3                      break;
 760   3                      case 0x91BB:
 761   3                      {
 762   4                              static MMODBUS AC2_Uc_Rectify;
 763   4                              AC2_Uc_Rectify.SlaveAddr = 0x61;
 764   4                              AC2_Uc_Rectify.mode = 0x00;
 765   4                              AC2_Uc_Rectify.flag = 0x00;
 766   4                              AC2_Uc_Rectify.Order = 0x06;
 767   4                              AC2_Uc_Rectify.Length = 0x01;
 768   4                              AC2_Uc_Rectify.reserved = 0x00;
 769   4                              AC2_Uc_Rectify.waitTime = 1000;
 770   4                              AC2_Uc_Rectify.VPaddr = 0x91BB;
 771   4                              AC2_Uc_Rectify.ModbusReg = 0x000B;
 772   4                              AC2_Uc_Rectify.databuff = NULL;
 773   4                              pushToEmergency(&AC2_Uc_Rectify);
 774   4                      }
 775   3                      break;
 776   3      
 777   3                      default:
 778   3                              break;
 779   3                      }
 780   2                      variableChangedIndication.flag = 0;
 781   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 782   2              }
 783   1              {
 784   2                      write_dgus_vp(0x91A2, (uint8_t *)&synthesisCollection.closeBusVolt, 1);
 785   2                      write_dgus_vp(0x91A3, (uint8_t *)&synthesisCollection.controlBusVolt, 1);
 786   2                      write_dgus_vp(0x91A4, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
 787   2                      write_dgus_vp(0x91A5, (uint8_t *)&synthesisCollection.batteryVolt, 1);
 788   2                      write_dgus_vp(0x91A6, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
 789   2                      write_dgus_vp(0x91A7, (uint8_t *)&synthesisCollection.AC_channel_1_Ubc, 1);
 790   2                      write_dgus_vp(0x91A8, (uint8_t *)&synthesisCollection.AC_channel_1_Uca, 1);
 791   2                      write_dgus_vp(0x91A9, (uint8_t *)&synthesisCollection.AC_channel_2_Uab, 1);
 792   2                      write_dgus_vp(0x91AA, (uint8_t *)&synthesisCollection.AC_channel_2_Ubc, 1);
 793   2                      write_dgus_vp(0x91AB, (uint8_t *)&synthesisCollection.AC_channel_2_Uca, 1);
 794   2              }
 795   1      }
 796          
 797          void P33Func()
 798          {
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 14  

 799   1              static uint8_t timeModifyFlag = 0; // 时间修改标记
 800   1              VariableChangedIndicationTypeDef variableChangedIndication;
 801   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 802   1              if (variableChangedIndication.flag == 0x5A)
 803   1              {
 804   2                      uint16_t variable[5];
 805   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 806   2                      switch (variableChangedIndication.addr)
 807   2                      {
 808   3                      case 0x009D:
 809   3                      case 0x009E:
 810   3                      case 0x009F:
 811   3                              timeModifyFlag = 1;
 812   3                              break;
 813   3      
 814   3                      case 0x80E0:
 815   3                              if (variable[0] == 1)
 816   3                              {
 817   4                                      if (timeModifyFlag == 1) // 由于时间会不断变化，故仅在修改时间的情况下保存时间，避免修改屏保时写入时间
 818   4                                      {
 819   5                                              uint8_t rtcSetData[6];
 820   5                                              read_dgus_vp(0x9D, rtcSetData, 4);
 821   5                                              Write_RTC(rtcSetData);
 822   5                                              timeModifyFlag = 0;
 823   5                                      }
 824   4                                      read_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
 825   4                                      Nor_Flash_write(BACKLIGHT_TIME_NORFLASH_ADDR, (uint8_t *)&backLightTime, 2);
 826   4                                      write_dgus_vp(0x83, (uint8_t *)&backLightTime, 1);
 827   4                              }
 828   3                              break;
 829   3      
 830   3                      default:
 831   3                              break;
 832   3                      }
 833   2                      variableChangedIndication.flag = 0;
 834   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 835   2              }
 836   1      }
 837          
 838          void P35Func()
 839          {
 840   1              VariableChangedIndicationTypeDef variableChangedIndication;
 841   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 842   1              if (variableChangedIndication.flag == 0x5A)
 843   1              {
 844   2                      uint16_t variable[5];
 845   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 846   2                      switch (variableChangedIndication.addr)
 847   2                      {
 848   3                      case 0x8100:
 849   3                              if (variable[0] == 1)
 850   3                              {
 851   4                                      read_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
 852   4                                      dgusToNorFlash(SWITCH_MODULE_NORFLASH_ADDR, SWITCH_MODULE_SET_VP, SWITCH_MODULE_SIZE);
 853   4                                      modbusCenerate();
 854   4                              }
 855   3                              break;
 856   3      
 857   3                      default:
 858   3                              break;
 859   3                      }
 860   2                      memset(variable, 0, 5);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 15  

 861   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 862   2                      variableChangedIndication.flag = 0;
 863   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 864   2              }
 865   1      }
 866          
 867          void P39Func()
 868          {
 869   1              VariableChangedIndicationTypeDef variableChangedIndication;
 870   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 871   1              if (variableChangedIndication.flag == 0x5A)
 872   1              {
 873   2                      uint16_t variable[5];
 874   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 875   2                      switch (variableChangedIndication.addr)
 876   2                      {
 877   3                      case 0x8120:
 878   3                              if (variable[0] == 1)
 879   3                              {
 880   4                                      read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
 881   4                                      dgusToNorFlash(BATTERY_SET_NORFLASH_ADDR, BATTERY_SET_VP, BATTERY_SET_SIZE);
 882   4                                      modbusCenerate();
 883   4                              }
 884   3                              break;
 885   3                      case 0x9250:
 886   3                              read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet.batteryType, 1);
 887   3                              break;
 888   3                      case 0x9280:
 889   3                      {
 890   4                              if (batterySet.batteryType == XJ24)
 891   4                              {
 892   5                                      if (0 <= variable[0] && variable[0] <= 5)
 893   5                                      {
 894   6                                              uint16_t batteryModuleNum = variable[0];
 895   6                                              uint16_t cellNum;
 896   6                                              write_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 897   6      
 898   6                                              // 根据巡检数量设置电池节数上限
 899   6                                              read_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 900   6                                              if (cellNum > batteryModuleNum * 24)
 901   6                                              {
 902   7                                                      cellNum = batteryModuleNum * 24;
 903   7                                              }
 904   6                                              write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 905   6                                      }
 906   5                              }
 907   4                              else if (batterySet.batteryType == XJ55)
 908   4                              {
 909   5                                      if (0 <= variable[0] && variable[0] <= 2)
 910   5                                      {
 911   6                                              uint16_t batteryModuleNum = variable[0];
 912   6                                              uint16_t cellNum;
 913   6                                              write_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 914   6      
 915   6                                              // 根据巡检数量设置电池节数上限
 916   6                                              read_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 917   6                                              if (cellNum > batteryModuleNum * 55)
 918   6                                              {
 919   7                                                      cellNum = batteryModuleNum * 55;
 920   7                                              }
 921   6                                              write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 922   6                                      }
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 16  

 923   5                              }
 924   4                      }
 925   3                      break;
 926   3                      case 0x9281:
 927   3                      {
 928   4                              if (batterySet.batteryType == XJ24)
 929   4                              {
 930   5                                      uint16_t batteryModuleNum;
 931   5                                      uint16_t cellNum = variable[0];
 932   5                                      read_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 933   5                                      if (cellNum > batteryModuleNum * 24)
 934   5                                      {
 935   6                                              cellNum = batteryModuleNum * 24;
 936   6                                      }
 937   5                                      write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 938   5                              }
 939   4                              else if (batterySet.batteryType == XJ55)
 940   4                              {
 941   5                                      uint16_t batteryModuleNum;
 942   5                                      uint16_t cellNum = variable[0];
 943   5                                      read_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 944   5                                      if (cellNum > batteryModuleNum * 55)
 945   5                                      {
 946   6                                              cellNum = batteryModuleNum * 55;
 947   6                                      }
 948   5                                      write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 949   5                              }
 950   4                      }
 951   3                      break;
 952   3                      case 0x9282:
 953   3                      {
 954   4                              if (batterySet.batteryType == XJ24)
 955   4                              {
 956   5                                      write_dgus_vp(0x9262, (uint8_t *)variable, 1);
 957   5                              }
 958   4                              else if (batterySet.batteryType == XJ55)
 959   4                              {
 960   5                                      write_dgus_vp(0x9272, (uint8_t *)variable, 1);
 961   5                              }
 962   4                      }
 963   3                      break;
 964   3                      case 0x9283:
 965   3                      {
 966   4                              if (batterySet.batteryType == XJ24)
 967   4                              {
 968   5                                      write_dgus_vp(0x9263, (uint8_t *)variable, 1);
 969   5                              }
 970   4                              else if (batterySet.batteryType == XJ55)
 971   4                              {
 972   5                                      write_dgus_vp(0x9273, (uint8_t *)variable, 1);
 973   5                              }
 974   4                      }
 975   3                      break;
 976   3                      case 0x9284:
 977   3                      {
 978   4                              if (batterySet.batteryType == XJ24)
 979   4                              {
 980   5                                      write_dgus_vp(0x9264, (uint8_t *)variable, 1);
 981   5                              }
 982   4                              else if (batterySet.batteryType == XJ55)
 983   4                              {
 984   5                                      write_dgus_vp(0x9274, (uint8_t *)variable, 1);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 17  

 985   5                              }
 986   4                      }
 987   3                      break;
 988   3                      case 0x9285:
 989   3                      {
 990   4                              if (batterySet.batteryType == XJ24)
 991   4                              {
 992   5                                      write_dgus_vp(0x9265, (uint8_t *)variable, 1);
 993   5                              }
 994   4                              else if (batterySet.batteryType == XJ55)
 995   4                              {
 996   5                                      write_dgus_vp(0x9275, (uint8_t *)variable, 1);
 997   5                              }
 998   4                      }
 999   3                      break;
1000   3                      case 0x9286:
1001   3                      {
1002   4                              if (batterySet.batteryType == XJ24)
1003   4                              {
1004   5                                      write_dgus_vp(0x9266, (uint8_t *)variable, 1);
1005   5                              }
1006   4                              else if (batterySet.batteryType == XJ55)
1007   4                              {
1008   5                                      write_dgus_vp(0x9276, (uint8_t *)variable, 1);
1009   5                              }
1010   4                      }
1011   3                      break;
1012   3                      default:
1013   3                              break;
1014   3                      }
1015   2                      // memset(variable, 0, 5);
1016   2                      // write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1017   2                      variableChangedIndication.flag = 0;
1018   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1019   2              }
1020   1              {
1021   2                      if (batterySet.batteryType == XJ24)
1022   2                      {
1023   3                              uint16_t sp; // 描述指针
1024   3                              sp = 0x9260;
1025   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
1026   3                              sp = 0x9261;
1027   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
1028   3                              sp = 0x9262;
1029   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
1030   3                              sp = 0x9263;
1031   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
1032   3                              sp = 0x9264;
1033   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
1034   3                              sp = 0x9265;
1035   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
1036   3                              sp = 0x9266;
1037   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
1038   3                      }
1039   2                      else if (batterySet.batteryType == XJ55)
1040   2                      {
1041   3                              uint16_t sp; // 描述指针
1042   3                              sp = 0x9270;
1043   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
1044   3                              sp = 0x9271;
1045   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
1046   3                              sp = 0x9272;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 18  

1047   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
1048   3                              sp = 0x9273;
1049   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
1050   3                              sp = 0x9274;
1051   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
1052   3                              sp = 0x9275;
1053   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
1054   3                              sp = 0x9276;
1055   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
1056   3                      }
1057   2              }
1058   1      }
1059          
1060          void p42Func()
1061          {
1062   1              VariableChangedIndicationTypeDef variableChangedIndication;
1063   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1064   1              if (variableChangedIndication.flag == 0x5A)
1065   1              {
1066   2                      uint16_t variable[5];
1067   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1068   2                      switch (variableChangedIndication.addr)
1069   2                      {
1070   3                      case 0x8140:
1071   3                              if (variable[0] == 1)
1072   3                              {
1073   4                                      read_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
1074   4                                      dgusToNorFlash(INSULATION_SET_NORFLASH_ADDR, INSULATION_SET_VP, INSULATION_SET_SIZE);
1075   4                                      modbusCenerate();
1076   4                              }
1077   3                              break;
1078   3      
1079   3                      case 0x92C1:
1080   3                      {
1081   4                              static MMODBUS AC_BusAlarm;
1082   4                              AC_BusAlarm.SlaveAddr = 0x32;
1083   4                              AC_BusAlarm.mode = 0x00;
1084   4                              AC_BusAlarm.flag = 0x00;
1085   4                              AC_BusAlarm.Order = 0x06;
1086   4                              AC_BusAlarm.Length = 1;
1087   4                              AC_BusAlarm.reserved = 0;
1088   4                              AC_BusAlarm.waitTime = 1000;
1089   4                              AC_BusAlarm.VPaddr = 0x92C1;
1090   4                              AC_BusAlarm.ModbusReg = 0x03;
1091   4                              AC_BusAlarm.databuff = NULL;
1092   4                              pushToEmergency(&AC_BusAlarm);
1093   4                      }
1094   3      
1095   3                      default:
1096   3                              break;
1097   3                      }
1098   2                      memset(variable, 0, 5);
1099   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1100   2                      variableChangedIndication.flag = 0;
1101   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1102   2              }
1103   1              {
1104   2                      write_dgus_vp(0x92C0, (uint8_t *)&AC_Insulation.alarmValue, 1);
1105   2              }
1106   1      }
1107          
1108          void p44Func()
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 19  

1109          {
1110   1              VariableChangedIndicationTypeDef variableChangedIndication;
1111   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1112   1              if (variableChangedIndication.flag == 0x5A)
1113   1              {
1114   2                      uint16_t variable[5];
1115   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1116   2                      switch (variableChangedIndication.addr)
1117   2                      {
1118   3                      case 0x8160:
1119   3                              if (variable[0] == 1)
1120   3                              {
1121   4                                      read_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
1122   4                                      dgusToNorFlash(CHARGE_MODULE_SET_NORFLASH_ADDR, CHARGE_MODULE_SET_VP, CHARGE_MODULE_SET_SIZE);
1123   4                                      modbusCenerate();
1124   4                              }
1125   3                              break;
1126   3      
1127   3                      default:
1128   3                              break;
1129   3                      }
1130   2                      memset(variable, 0, 5);
1131   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1132   2                      variableChangedIndication.flag = 0;
1133   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1134   2              }
1135   1      }
1136          
1137          void p48Func()
1138          {
1139   1              VariableChangedIndicationTypeDef variableChangedIndication;
1140   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1141   1              if (variableChangedIndication.flag == 0x5A)
1142   1              {
1143   2                      uint16_t variable[5];
1144   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1145   2                      switch (variableChangedIndication.addr)
1146   2                      {
1147   3                      case 0x8180:
1148   3                              if (variable[0] == 1)
1149   3                              {
1150   4                                      read_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
1151   4                                      dgusToNorFlash(DC_CONVERTER_SET_NORFLASH_ADDR, DC_CONVERTER_SET_VP, DC_CONVERTER_SET_SIZE);
1152   4                                      modbusCenerate();
1153   4                              }
1154   3                              break;
1155   3                      case 0x9360:
1156   3                              if (variable[0] == 1)
1157   3                              {
1158   4                                      if (DC_ConverterSet.Num > 0)
1159   4                                      {
1160   5                                              static MMODBUS DC_moduleOnOffCmd;
1161   5                                              static uint16_t DC_module_DI;
1162   5                                              dc_4850_Module[0].DI.onOffState = !dc_4850_Module[0].DI.onOffState;
1163   5                                              DC_module_DI = dc_4850_Module[0].DI.onOffState;
1164   5                                              DC_moduleOnOffCmd.SlaveAddr = 0xFE;
1165   5                                              DC_moduleOnOffCmd.mode = 0x00;
1166   5                                              DC_moduleOnOffCmd.flag = 0x00;
1167   5                                              DC_moduleOnOffCmd.Order = 0x06;
1168   5                                              DC_moduleOnOffCmd.Length = 1;
1169   5                                              DC_moduleOnOffCmd.reserved = 0x00;
1170   5                                              DC_moduleOnOffCmd.waitTime = 1000;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 20  

1171   5                                              DC_moduleOnOffCmd.VPaddr = 0;
1172   5                                              DC_moduleOnOffCmd.ModbusReg = 0x0005;
1173   5                                              DC_moduleOnOffCmd.databuff = &DC_module_DI;
1174   5                                              pushToEmergency(&DC_moduleOnOffCmd);
1175   5                                      }
1176   4                              }
1177   3                              break;
1178   3      
1179   3                      default:
1180   3                              break;
1181   3                      }
1182   2                      memset(variable, 0, 5);
1183   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1184   2                      variableChangedIndication.flag = 0;
1185   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1186   2              }
1187   1              {
1188   2                      uint16_t DC_Module_OnOffState = dc_4850_Module[0].DI.onOffState ? 1 : 0;
1189   2                      write_dgus_vp(0x9361, (uint8_t *)&DC_Module_OnOffState, 1);
1190   2              }
1191   1      }
1192          
1193          void p50Func()
1194          {
1195   1              VariableChangedIndicationTypeDef variableChangedIndication;
1196   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1197   1              if (variableChangedIndication.flag == 0x5A)
1198   1              {
1199   2                      uint16_t variable[5];
1200   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1201   2                      switch (variableChangedIndication.addr)
1202   2                      {
1203   3                      case 0x81A0:
1204   3                              if (variable[0] == 1)
1205   3                              {
1206   4                                      read_dgus_vp(UPS_INV_SET_VP, (uint8_t *)&UPS_INV_Set, UPS_INV_SET_SIZE);
1207   4                                      dgusToNorFlash(UPS_INV_SET_NORFLASH_ADDR, UPS_INV_SET_VP, UPS_INV_SET_SIZE);
1208   4                                      modbusCenerate();
1209   4                              }
1210   3                              break;
1211   3      
1212   3                      default:
1213   3                              break;
1214   3                      }
1215   2                      memset(variable, 0, 5);
1216   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1217   2                      variableChangedIndication.flag = 0;
1218   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1219   2              }
1220   1      }
1221          
1222          void recovery(void)
1223          {
1224   1              AC_InfoSet.AC_InputChannel = 1;
1225   1              AC_InfoSet.threePhaseAC_VolMax = 4500;
1226   1              AC_InfoSet.threePhaseAC_VolMin = 3230;
1227   1              AC_InfoSet.singlePhaseAC_VolMax = 2800;
1228   1              AC_InfoSet.singlePhaseAC_VolMin = 1870;
1229   1              Nor_Flash_write(AC_INFO_NORFLASH_ADDR, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1230   1              write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1231   1      
1232   1              // DC_InfoSet.busVoltMax_220V = 2600;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 21  

1233   1              // DC_InfoSet.busVoltMin_220V = 2000;
1234   1              // DC_InfoSet.moduleVoltMax_220V = 2420;
1235   1              // DC_InfoSet.moduleVoltMin_220V = 2000;
1236   1              // DC_InfoSet.busVoltMax_110V = 1300;
1237   1              // DC_InfoSet.busVoltMin_110V = 1000;
1238   1              // DC_InfoSet.moduleVoltMax_110V = 1200;
1239   1              // DC_InfoSet.moduleVoltMin_110V = 1000;
1240   1              DC_InfoSet.loadHallRatio = 1000;
1241   1              DC_InfoSet.batteryHallRatio = 1000;
1242   1              Nor_Flash_write(DC_INFO_NORFLASH_ADDR, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1243   1              write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1244   1      }
1245          
1246          void p52Func()
1247          {
1248   1              VariableChangedIndicationTypeDef variableChangedIndication;
1249   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1250   1              if (variableChangedIndication.flag == 0x5A)
1251   1              {
1252   2                      uint16_t variable[5];
1253   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1254   2                      switch (variableChangedIndication.addr)
1255   2                      {
1256   3                      case 0x9400:
1257   3                              if (variable[0] == 1)
1258   3                              {
1259   4                                      recovery();
1260   4                              }
1261   3                              break;
1262   3                      case 0x9401:
1263   3                              if (variable[0] == 1)
1264   3                              {
1265   4                                      extern struct
1266   4                                      {
1267   4                                              uint16_t head;
1268   4                                              uint16_t tail;
1269   4                                      } pHistoryAlarm;
1270   4                                      pHistoryAlarm.head = pHistoryAlarm.tail = 0;
1271   4                                      Nor_Flash_write(P_HISTORY_ALARM_NORFLASH_ADDR, (uint8_t *)&pHistoryAlarm, 2);
1272   4                              }
1273   3                              break;
1274   3                      case 0x9402:
1275   3                              if (variable[0] == 1)
1276   3                              {
1277   4                                      // 重启触摸屏
1278   4                                      write_dgus_vp(0x04, (uint8_t *)"\x55\xAA\x5A\xA5", 2);
1279   4                              }
1280   3                              break;
1281   3      
1282   3                      default:
1283   3                              break;
1284   3                      }
1285   2                      memset(variable, 0, 5);
1286   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1287   2                      variableChangedIndication.flag = 0;
1288   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1289   2              }
1290   1      }
1291          
1292          void p68Func(void)
1293          {
1294   1      
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 22  

1295   1              if (AC_InfoSet.singlePhaseThreePhaseSelection == THREE_PHASE)
1296   1              {
1297   2                      uint16_t sp;
1298   2                      sp = 0x94A0;
1299   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1300   2                      // sp = 0x94A0;
1301   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1302   2                      sp = 0x94A1;
1303   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1304   2                      sp = 0x94A3;
1305   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1306   2                      // sp = 0x94A4;
1307   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1308   2                      sp = 0x94A5;
1309   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
1310   2      
1311   2                      write_dgus_vp(0x94A0, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 6);
1312   2              }
1313   1              else if (AC_InfoSet.singlePhaseThreePhaseSelection == SINGLE_PHASE)
1314   1              {
1315   2                      uint16_t sp;
1316   2                      sp = 0xFFFF;
1317   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1318   2                      // sp = 0x94A0;
1319   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1320   2                      sp = 0xFFFF;
1321   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1322   2                      sp = 0xFFFF;
1323   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1324   2                      // sp = 0x94A4;
1325   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1326   2                      sp = 0xFFFF;
1327   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
1328   2      
1329   2                      write_dgus_vp(0x94A1, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1330   2                      write_dgus_vp(0x94A4, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1331   2              }
1332   1      }
1333          
1334          void p70Func(void)
1335          {
1336   1              {
1337   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1338   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1339   2                      if (variableChangedIndication.flag == 0x5A)
1340   2                      {
1341   3                              uint16_t variable[5];
1342   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1343   3                              switch (variableChangedIndication.addr)
1344   3                              {
1345   4                              case 0x9530:
1346   4                                      if (variable[0] == 1)
1347   4                                      {
1348   5                                              if (chargeModuleSet.moduleNum >= 1)
1349   5                                              {
1350   6                                                      static MMODBUS chargeModuleOnOff = {0x01, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9540, 0x06, NULL};
1351   6                                                      chargeModule[0].DI.onOffState = !chargeModule[0].DI.onOffState;
1352   6                                                      write_dgus_vp(0x9540, (uint8_t *)&chargeModule[0].DI, 1);
1353   6                                                      pushToEmergency(&chargeModuleOnOff);
1354   6                                              }
1355   5                                      }
1356   4                                      break;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 23  

1357   4                              case 0x9531:
1358   4                                      if (variable[0] == 1)
1359   4                                      {
1360   5                                              if (chargeModuleSet.moduleNum >= 2)
1361   5                                              {
1362   6                                                      static MMODBUS chargeModuleOnOff = {0x02, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9541, 0x06, NULL};
1363   6                                                      chargeModule[1].DI.onOffState = !chargeModule[1].DI.onOffState;
1364   6                                                      write_dgus_vp(0x9541, (uint8_t *)&chargeModule[1].DI, 1);
1365   6                                                      pushToEmergency(&chargeModuleOnOff);
1366   6                                              }
1367   5                                      }
1368   4                                      break;
1369   4                              case 0x9532:
1370   4                                      if (variable[0] == 1)
1371   4                                      {
1372   5                                              if (chargeModuleSet.moduleNum >= 3)
1373   5                                              {
1374   6                                                      static MMODBUS chargeModuleOnOff = {0x03, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9542, 0x06, NULL};
1375   6                                                      chargeModule[2].DI.onOffState = !chargeModule[2].DI.onOffState;
1376   6                                                      write_dgus_vp(0x9542, (uint8_t *)&chargeModule[2].DI, 1);
1377   6                                                      pushToEmergency(&chargeModuleOnOff);
1378   6                                              }
1379   5                                      }
1380   4                                      break;
1381   4                              case 0x9533:
1382   4                                      if (variable[0] == 1)
1383   4                                      {
1384   5                                              if (chargeModuleSet.moduleNum >= 4)
1385   5                                              {
1386   6                                                      static MMODBUS chargeModuleOnOff = {0x04, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9543, 0x06, NULL};
1387   6                                                      chargeModule[3].DI.onOffState = !chargeModule[3].DI.onOffState;
1388   6                                                      write_dgus_vp(0x9543, (uint8_t *)&chargeModule[3].DI, 1);
1389   6                                                      pushToEmergency(&chargeModuleOnOff);
1390   6                                              }
1391   5                                      }
1392   4                                      break;
1393   4                              case 0x9534:
1394   4                                      if (variable[0] == 1)
1395   4                                      {
1396   5                                              if (chargeModuleSet.moduleNum >= 5)
1397   5                                              {
1398   6                                                      static MMODBUS chargeModuleOnOff = {0x05, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9544, 0x06, NULL};
1399   6                                                      chargeModule[4].DI.onOffState = !chargeModule[4].DI.onOffState;
1400   6                                                      write_dgus_vp(0x9544, (uint8_t *)&chargeModule[4].DI, 1);
1401   6                                                      pushToEmergency(&chargeModuleOnOff);
1402   6                                              }
1403   5                                      }
1404   4                                      break;
1405   4                              case 0x9535:
1406   4                                      if (variable[0] == 1)
1407   4                                      {
1408   5                                              if (chargeModuleSet.moduleNum >= 6)
1409   5                                              {
1410   6                                                      static MMODBUS chargeModuleOnOff = {0x06, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9545, 0x06, NULL};
1411   6                                                      chargeModule[5].DI.onOffState = !chargeModule[5].DI.onOffState;
1412   6                                                      write_dgus_vp(0x9545, (uint8_t *)&chargeModule[5].DI, 1);
1413   6                                                      pushToEmergency(&chargeModuleOnOff);
1414   6                                              }
1415   5                                      }
1416   4                                      break;
1417   4                              case 0x9536:
1418   4                                      if (variable[0] == 1)
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 24  

1419   4                                      {
1420   5                                              if (chargeModuleSet.moduleNum >= 7)
1421   5                                              {
1422   6                                                      static MMODBUS chargeModuleOnOff = {0x07, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9546, 0x06, NULL};
1423   6                                                      chargeModule[6].DI.onOffState = !chargeModule[6].DI.onOffState;
1424   6                                                      write_dgus_vp(0x9546, (uint8_t *)&chargeModule[6].DI, 1);
1425   6                                                      pushToEmergency(&chargeModuleOnOff);
1426   6                                              }
1427   5                                      }
1428   4                                      break;
1429   4                              case 0x9537:
1430   4                                      if (variable[0] == 1)
1431   4                                      {
1432   5                                              if (chargeModuleSet.moduleNum >= 8)
1433   5                                              {
1434   6                                                      static MMODBUS chargeModuleOnOff = {0x08, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9547, 0x06, NULL};
1435   6                                                      chargeModule[7].DI.onOffState = !chargeModule[7].DI.onOffState;
1436   6                                                      write_dgus_vp(0x9547, (uint8_t *)&chargeModule[7].DI, 1);
1437   6                                                      pushToEmergency(&chargeModuleOnOff);
1438   6                                              }
1439   5                                      }
1440   4                                      break;
1441   4      
1442   4                              default:
1443   4                                      break;
1444   4                              }
1445   3                              memset(variable, 0, 5);
1446   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1447   3                              variableChangedIndication.flag = 0;
1448   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1449   3                      }
1450   2              }
1451   1              {
1452   2                      if (chargeModuleSet.moduleNum >= 1)
1453   2                      {
1454   3                              write_dgus_vp(0x9500, (uint8_t *)&chargeModule[0].outputVolt, 3);
1455   3                              write_dgus_vp(0x9503, (uint8_t *)&chargeModule[0].DI, 1);
1456   3                              // {
1457   3                              //      uint16_t temp = chargeModule.onOffState;
1458   3                              //      write_dgus_vp(0x9503, (uint8_t *)&temp, 1);
1459   3                              // }
1460   3                              {
1461   4                                      uint16_t temp = 0;
1462   4                                      write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1463   4                              }
1464   3                      }
1465   2                      else
1466   2                      {
1467   3                              uint16_t temp = 1;
1468   3                              write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1469   3                      }
1470   2                      if (chargeModuleSet.moduleNum >= 2)
1471   2                      {
1472   3                              write_dgus_vp(0x9504, (uint8_t *)&chargeModule[1].outputVolt, 3);
1473   3                              write_dgus_vp(0x9507, (uint8_t *)&chargeModule[1].DI, 1);
1474   3                              // {
1475   3                              //      uint16_t temp = chargeModule[1].DI.onOffState;
1476   3                              //      write_dgus_vp(0x9507, (uint8_t *)&temp, 1);
1477   3                              // }
1478   3                              {
1479   4                                      uint16_t temp = 0;
1480   4                                      write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 25  

1481   4                              }
1482   3                      }
1483   2                      else
1484   2                      {
1485   3                              uint16_t temp = 1;
1486   3                              write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
1487   3                      }
1488   2                      if (chargeModuleSet.moduleNum >= 3)
1489   2                      {
1490   3                              write_dgus_vp(0x9508, (uint8_t *)&chargeModule[2].outputVolt, 3);
1491   3                              write_dgus_vp(0x950B, (uint8_t *)&chargeModule[2].DI, 1);
1492   3                              // {
1493   3                              //      uint16_t temp = chargeModule[2].DI.onOffState;
1494   3                              //      write_dgus_vp(0x950B, (uint8_t *)&temp, 1);
1495   3                              // }
1496   3                              {
1497   4                                      uint16_t temp = 0;
1498   4                                      write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1499   4                              }
1500   3                      }
1501   2                      else
1502   2                      {
1503   3                              uint16_t temp = 1;
1504   3                              write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1505   3                      }
1506   2                      if (chargeModuleSet.moduleNum >= 4)
1507   2                      {
1508   3                              write_dgus_vp(0x950C, (uint8_t *)&chargeModule[3].outputVolt, 3);
1509   3                              write_dgus_vp(0x950F, (uint8_t *)&chargeModule[3].DI, 1);
1510   3                              // {
1511   3                              //      uint16_t temp = chargeModule[3].DI.onOffState;
1512   3                              //      write_dgus_vp(0x950F, (uint8_t *)&temp, 1);
1513   3                              // }
1514   3                              {
1515   4                                      uint16_t temp = 0;
1516   4                                      write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1517   4                              }
1518   3                      }
1519   2                      else
1520   2                      {
1521   3                              uint16_t temp = 1;
1522   3                              write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1523   3                      }
1524   2                      if (chargeModuleSet.moduleNum >= 5)
1525   2                      {
1526   3                              write_dgus_vp(0x9510, (uint8_t *)&chargeModule[4].outputVolt, 3);
1527   3                              write_dgus_vp(0x9513, (uint8_t *)&chargeModule[4].DI, 1);
1528   3                              // {
1529   3                              //      uint16_t temp = chargeModule[4].DI.onOffState;
1530   3                              //      write_dgus_vp(0x9513, (uint8_t *)&temp, 1);
1531   3                              // }
1532   3                              {
1533   4                                      uint16_t temp = 0;
1534   4                                      write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1535   4                              }
1536   3                      }
1537   2                      else
1538   2                      {
1539   3                              uint16_t temp = 1;
1540   3                              write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1541   3                      }
1542   2                      if (chargeModuleSet.moduleNum >= 6)
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 26  

1543   2                      {
1544   3                              write_dgus_vp(0x9514, (uint8_t *)&chargeModule[5].outputVolt, 3);
1545   3                              write_dgus_vp(0x9517, (uint8_t *)&chargeModule[5].DI, 1);
1546   3                              // {
1547   3                              //      uint16_t temp = chargeModule[5].DI.onOffState;
1548   3                              //      write_dgus_vp(0x9517, (uint8_t *)&temp, 1);
1549   3                              // }
1550   3                              {
1551   4                                      uint16_t temp = 0;
1552   4                                      write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1553   4                              }
1554   3                      }
1555   2                      else
1556   2                      {
1557   3                              uint16_t temp = 1;
1558   3                              write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1559   3                      }
1560   2                      if (chargeModuleSet.moduleNum >= 7)
1561   2                      {
1562   3                              write_dgus_vp(0x9518, (uint8_t *)&chargeModule[6].outputVolt, 3);
1563   3                              write_dgus_vp(0x951B, (uint8_t *)&chargeModule[6].DI, 1);
1564   3                              // {
1565   3                              //      uint16_t temp = chargeModule[6].DI.onOffState;
1566   3                              //      write_dgus_vp(0x951B, (uint8_t *)&temp, 1);
1567   3                              // }
1568   3                              {
1569   4                                      uint16_t temp = 0;
1570   4                                      write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1571   4                              }
1572   3                      }
1573   2                      else
1574   2                      {
1575   3                              uint16_t temp = 1;
1576   3                              write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1577   3                      }
1578   2                      if (chargeModuleSet.moduleNum >= 8)
1579   2                      {
1580   3                              write_dgus_vp(0x951C, (uint8_t *)&chargeModule[7].outputVolt, 3);
1581   3                              write_dgus_vp(0x951F, (uint8_t *)&chargeModule[7].DI, 1);
1582   3                              // {
1583   3                              //      uint16_t temp = chargeModule[7].DI.onOffState;
1584   3                              //      write_dgus_vp(0x951F, (uint8_t *)&temp, 1);
1585   3                              // }
1586   3                              {
1587   4                                      uint16_t temp = 0;
1588   4                                      write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
1589   4                              }
1590   3                      }
1591   2                      else
1592   2                      {
1593   3                              uint16_t temp = 1;
1594   3                              write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
1595   3                      }
1596   2              }
1597   1      }
1598          
1599          void p72Func(void)
1600          {
1601   1              uint16_t swState;
1602   1              uint16_t i;
1603   1              for (i = 0; i < switchModuleSet.synthesisCollection.alarmChannelNum; i++)
1604   1              {
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 27  

1605   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1606   2                      {
1607   3                              swState = SW_NORMAL;
1608   3                      }
1609   2                      else
1610   2                      {
1611   3                              swState = SW_FAULT;
1612   3                      }
1613   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1614   2              }
1615   1              for (; i < 12; i++)
1616   1              {
1617   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1618   2                      {
1619   3                              swState = CLOSING;
1620   3                      }
1621   2                      else
1622   2                      {
1623   3                              swState = OPENING;
1624   3                      }
1625   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1626   2              }
1627   1              for (; i < 13; i++)
1628   1              {
1629   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1630   2                      {
1631   3                              swState = SW_NORMAL;
1632   3                      }
1633   2                      else
1634   2                      {
1635   3                              swState = SW_FAULT;
1636   3                      }
1637   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1638   2              }
1639   1              for (; i < 15; i++)
1640   1              {
1641   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1642   2                      {
1643   3                              swState = CLOSING;
1644   3                      }
1645   2                      else
1646   2                      {
1647   3                              swState = OPENING;
1648   3                      }
1649   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1650   2              }
1651   1      }
1652          
1653          void p75Func(void)
1654          {
1655   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1656   1              {
1657   2                      uint16_t i;
1658   2                      for (i = 0; i < 16; i++)
1659   2                      {
1660   3                              uint16_t swState;
1661   3                              swState = (remoteControlModule_ARD[0].sw1to16 >> i) & 0x01;
1662   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1663   3                      }
1664   2              }
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 28  

1665   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1666   1              {
1667   2                      uint16_t i;
1668   2                      for (i = 0; i < 16; i++)
1669   2                      {
1670   3                              uint16_t swState;
1671   3                              swState = (remoteControlModule_TH[0].sw1to16 >> i) & 0x01;
1672   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1673   3                      }
1674   2              }
1675   1              {
1676   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1677   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1678   2                      if (variableChangedIndication.flag == 0x5A)
1679   2                      {
1680   3                              uint16_t variable[5];
1681   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1682   3                              switch (variableChangedIndication.addr)
1683   3                              {
1684   4                              case 0x9760:
1685   4                              case 0x9761:
1686   4                              case 0x9762:
1687   4                              case 0x9763:
1688   4                              case 0x9764:
1689   4                              case 0x9765:
1690   4                              case 0x9766:
1691   4                              case 0x9767:
1692   4                              case 0x9768:
1693   4                              case 0x9769:
1694   4                              case 0x976A:
1695   4                              case 0x976B:
1696   4                              case 0x976C:
1697   4                              case 0x976D:
1698   4                              case 0x976E:
1699   4                              case 0x976F:
1700   4                              {
1701   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1702   5                                      {
1703   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
1704   6                                              if (variable[0] == 0)
1705   6                                              {
1706   7                                                      static MMODBUS rtuSwOff[16];
1707   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1708   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
1709   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1710   7                                                      rtuSwOff[offset].mode = 0x00;
1711   7                                                      rtuSwOff[offset].flag = 0x00;
1712   7                                                      rtuSwOff[offset].Order = 0x06;
1713   7                                                      rtuSwOff[offset].Length = 0x01;
1714   7                                                      rtuSwOff[offset].reserved = 0x00;
1715   7                                                      rtuSwOff[offset].waitTime = 1000;
1716   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
1717   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
1718   7                                                      rtuSwOff[offset].databuff = NULL;
1719   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1720   7                                                      pushToEmergency(rtuSwOff + offset);
1721   7                                              }
1722   6                                              else if (variable[0] == 1)
1723   6                                              {
1724   7                                                      static MMODBUS rtuSwOn[16];
1725   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1726   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 29  

1727   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1728   7                                                      rtuSwOn[offset].mode = 0x00;
1729   7                                                      rtuSwOn[offset].flag = 0x00;
1730   7                                                      rtuSwOn[offset].Order = 0x06;
1731   7                                                      rtuSwOn[offset].Length = 0x01;
1732   7                                                      rtuSwOn[offset].reserved = 0x00;
1733   7                                                      rtuSwOn[offset].waitTime = 1000;
1734   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1735   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
1736   7                                                      rtuSwOn[offset].databuff = NULL;
1737   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1738   7                                                      pushToEmergency(rtuSwOn + offset);
1739   7                                              }
1740   6                                      }
1741   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1742   5                                      {
1743   6                                              if (variable[0] == 0)
1744   6                                              {
1745   7                                                      static MMODBUS rtuSwOff[16];
1746   7                                                      uint16_t OffVal = 0x0000;
1747   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1748   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1749   7                                                      rtuSwOff[offset].mode = 0x00;
1750   7                                                      rtuSwOff[offset].flag = 0x00;
1751   7                                                      rtuSwOff[offset].Order = 0x06;
1752   7                                                      rtuSwOff[offset].Length = 0x01;
1753   7                                                      rtuSwOff[offset].reserved = 0x00;
1754   7                                                      rtuSwOff[offset].waitTime = 1000;
1755   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
1756   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
1757   7                                                      rtuSwOff[offset].databuff = NULL;
1758   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OffVal, 1);
1759   7                                                      pushToEmergency(rtuSwOff + offset);
1760   7                                              }
1761   6                                              else if (variable[0] == 1)
1762   6                                              {
1763   7                                                      static MMODBUS rtuSwOn[16];
1764   7                                                      uint16_t OnVal = 0xFFFF;
1765   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1766   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1767   7                                                      rtuSwOn[offset].mode = 0x00;
1768   7                                                      rtuSwOn[offset].flag = 0x00;
1769   7                                                      rtuSwOn[offset].Order = 0x06;
1770   7                                                      rtuSwOn[offset].Length = 0x01;
1771   7                                                      rtuSwOn[offset].reserved = 0x00;
1772   7                                                      rtuSwOn[offset].waitTime = 1000;
1773   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1774   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
1775   7                                                      rtuSwOn[offset].databuff = NULL;
1776   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OnVal, 1);
1777   7                                                      pushToEmergency(rtuSwOn + offset);
1778   7                                              }
1779   6                                      }
1780   5                              }
1781   4                              break;
1782   4      
1783   4                              default:
1784   4                                      break;
1785   4                              }
1786   3                              memset(variable, 0, 5);
1787   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1788   3                              variableChangedIndication.flag = 0;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 30  

1789   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1790   3                      }
1791   2              }
1792   1      }
1793          
1794          void p76Func(void)
1795          {
1796   1              uint16_t swState;
1797   1              uint16_t i;
1798   1              for (i = 0; i < 30; i++)
1799   1              {
1800   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[0])
1801   2                      {
1802   3                              if ((switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[0]
             -)
1803   3                              {
1804   4                                      swState = SW_NORMAL;
1805   4                              }
1806   3                              else
1807   3                              {
1808   4                                      swState = SW_FAULT;
1809   4                              }
1810   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1811   3                      }
1812   2                      else
1813   2                      {
1814   3                              if (switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001)
1815   3                              {
1816   4                                      swState = CLOSING;
1817   4                              }
1818   3                              else
1819   3                              {
1820   4                                      swState = OPENING;
1821   4                              }
1822   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1823   3                      }
1824   2              }
1825   1      }
1826          
1827          void p77Func(void)
1828          {
1829   1              uint16_t swState;
1830   1              uint16_t i;
1831   1              for (i = 0; i < 30; i++)
1832   1              {
1833   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[1])
1834   2                      {
1835   3                              if ((switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[1]
             -)
1836   3                              {
1837   4                                      swState = SW_NORMAL;
1838   4                              }
1839   3                              else
1840   3                              {
1841   4                                      swState = SW_FAULT;
1842   4                              }
1843   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1844   3                      }
1845   2                      else
1846   2                      {
1847   3                              if (switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001)
1848   3                              {
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 31  

1849   4                                      swState = CLOSING;
1850   4                              }
1851   3                              else
1852   3                              {
1853   4                                      swState = OPENING;
1854   4                              }
1855   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1856   3                      }
1857   2              }
1858   1      }
1859          
1860          void p78Func(void)
1861          {
1862   1              uint16_t swState;
1863   1              uint16_t i;
1864   1              for (i = 0; i < 30; i++)
1865   1              {
1866   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[2])
1867   2                      {
1868   3                              if ((switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[2]
             -)
1869   3                              {
1870   4                                      swState = SW_NORMAL;
1871   4                              }
1872   3                              else
1873   3                              {
1874   4                                      swState = SW_FAULT;
1875   4                              }
1876   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1877   3                      }
1878   2                      else
1879   2                      {
1880   3                              if (switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001)
1881   3                              {
1882   4                                      swState = CLOSING;
1883   4                              }
1884   3                              else
1885   3                              {
1886   4                                      swState = OPENING;
1887   4                              }
1888   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1889   3                      }
1890   2              }
1891   1      }
1892          void p79Func(void)
1893          {
1894   1              uint16_t swState;
1895   1              uint16_t i;
1896   1              for (i = 0; i < 30; i++)
1897   1              {
1898   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[3])
1899   2                      {
1900   3                              if ((switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[3]
             -)
1901   3                              {
1902   4                                      swState = SW_NORMAL;
1903   4                              }
1904   3                              else
1905   3                              {
1906   4                                      swState = SW_FAULT;
1907   4                              }
1908   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 32  

1909   3                      }
1910   2                      else
1911   2                      {
1912   3                              if (switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001)
1913   3                              {
1914   4                                      swState = CLOSING;
1915   4                              }
1916   3                              else
1917   3                              {
1918   4                                      swState = OPENING;
1919   4                              }
1920   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
1921   3                      }
1922   2              }
1923   1      }
1924          
1925          void p80Func(void)
1926          {
1927   1              write_dgus_vp(0x9800, (uint8_t *)&synthesisCollection.closeBusVolt, 1);
1928   1      
1929   1              write_dgus_vp(0x9801, (uint8_t *)&synthesisCollection.controlBusVolt, 1);
1930   1      
1931   1              write_dgus_vp(0x9802, (uint8_t *)&synthesisCollection.controlBusCurr, 1);
1932   1      
1933   1              write_dgus_vp(0x9803, (uint8_t *)&synthesisCollection.batteryVolt, 1);
1934   1      
1935   1              write_dgus_vp(0x9804, (uint8_t *)&synthesisCollection.batteryCurr, 1);
1936   1      }
1937          
1938          void p82Func(void)
1939          {
1940   1              if (UPS_INV_Set.UPS_Num >= 1)
1941   1              {
1942   2                      write_dgus_vp(0x9850, (uint8_t *)&ups[0].remoteMeasurement, 11);
1943   2                      write_dgus_vp(0x985B, (uint8_t *)&ups[0].remoteSignal, 1);
1944   2              }
1945   1              if (UPS_INV_Set.UPS_Num >= 2)
1946   1              {
1947   2                      write_dgus_vp(0x9860, (uint8_t *)&ups[1].remoteMeasurement, 11);
1948   2                      write_dgus_vp(0x986B, (uint8_t *)&ups[1].remoteSignal, 1);
1949   2              }
1950   1              {
1951   2                      uint16_t ups2Hide;
1952   2                      ups2Hide = (UPS_INV_Set.UPS_Num < 2) ? 1 : 0;
1953   2                      write_dgus_vp(0x9880, (uint8_t *)&ups2Hide, 1);
1954   2              }
1955   1      }
1956          
1957          void p85Func(void)
1958          {
1959   1              if (UPS_INV_Set.INV_Num >= 1)
1960   1              {
1961   2                      write_dgus_vp(0x98A0, (uint8_t *)&inv[0], 21);
1962   2              }
1963   1              if (UPS_INV_Set.INV_Num >= 2)
1964   1              {
1965   2                      write_dgus_vp(0x98C0, (uint8_t *)&inv[1], 21);
1966   2              }
1967   1              {
1968   2                      uint16_t inv2Hide;
1969   2                      inv2Hide = (UPS_INV_Set.INV_Num < 2) ? 1 : 0;
1970   2                      write_dgus_vp(0x98E0, (uint8_t *)&inv2Hide, 1);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 33  

1971   2              }
1972   1      }
1973          
1974          void p86Func(void)
1975          {
1976   1              uint16_t i;
1977   1              for (i = 0; i < DC_ConverterSet.Num; i++)
1978   1              {
1979   2                      uint16_t faultSta;
1980   2                      uint16_t protectSta;
1981   2                      write_dgus_vp(0x9900 + i, (uint8_t *)&dc_4850_Module[i].outputVolt, 1);
1982   2                      write_dgus_vp(0x9910 + i, (uint8_t *)&dc_4850_Module[i].outputCurr, 1);
1983   2                      faultSta = dc_4850_Module[i].DI.faultState;
1984   2                      write_dgus_vp(0x9920 + i, (uint8_t *)&faultSta, 1);
1985   2                      protectSta = dc_4850_Module[i].DI.protectState;
1986   2                      write_dgus_vp(0x9930 + i, (uint8_t *)&protectSta, 1);
1987   2              }
1988   1              for (i = 0; i < DC4850MODULE_MAX; i++)
1989   1              {
1990   2                      uint16_t DC_hide;
1991   2                      DC_hide = (i >= DC_ConverterSet.Num) ? 1 : 0;
1992   2                      write_dgus_vp(0x9940 + i, (uint8_t *)&DC_hide, 1);
1993   2              }
1994   1      }
1995          
1996          void p87Func(void)
1997          {
1998   1              uint16_t i;
1999   1              for (i = 0; i < 30; i++)
2000   1              {
2001   2                      if (insulationSet.DC.Num >= 1)
2002   2                      {
2003   3                              int16_t insulationRes;
2004   3                              insulationRes = DC_Insulation[0].res[i];
2005   3                              insulationRes += i < insulationSet.DC.closeBus_1_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
2006   3                              write_dgus_vp(0x9950 + i, (uint8_t *)&insulationRes, 1);
2007   3                              if (AC_Insulation.positiveBusAlarm == 0 && AC_Insulation.negativeBusAlarm == 0)
2008   3                              {
2009   4                                      uint16_t temp = 1;
2010   4                                      if (insulationRes <= insulationSet.DC.resAlarm)
2011   4                                      {
2012   5                                              temp = 0;
2013   5                                      }
2014   4                                      write_dgus_vp(0x9970 + i, (uint8_t *)&temp, 1);
2015   4                              }
2016   3                      }
2017   2              }
2018   1      
2019   1              if (sysInfoSet.siliconChain == 1)
2020   1              {
2021   2                      int16_t temp;
2022   2                      temp = DC_Insulation[0].closeBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
2023   2                      write_dgus_vp(0x9990, (uint8_t *)&temp, 1);
2024   2      
2025   2                      temp = DC_Insulation[0].controlBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
2026   2                      write_dgus_vp(0x9991, (uint8_t *)&temp, 1);
2027   2              }
2028   1              else if (sysInfoSet.siliconChain == 0)
2029   1              {
2030   2                      int32_t chargeModuleVolt; // 充电模块电压
2031   2                      int16_t displayVolt;
2032   2                      uint16_t i;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 34  

2033   2      
2034   2                      chargeModuleVolt = 0;
2035   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
2036   2                      {
2037   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
2038   3                              {
2039   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
2040   4                              }
2041   3                      }
2042   2      
2043   2                      displayVolt = (int16_t)(MAX(batteryVoltSum, chargeModuleVolt) - DC_Insulation[0].controlBusToGroundVolt)
             -;
2044   2                      write_dgus_vp(0x9990, (uint8_t *)&displayVolt, 1);
2045   2                      write_dgus_vp(0x9991, (uint8_t *)&displayVolt, 1);
2046   2              }
2047   1      
2048   1              write_dgus_vp(0x9992, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
2049   1      
2050   1              write_dgus_vp(0x9993, (uint8_t *)&AC_Insulation.alarmValue, 1);
2051   1              // write_dgus_vp(0x9993, (uint8_t *)&insulationSet.AC.voltToGroundAlarm, 1); // 有歧义
2052   1      }
2053          
2054          void p88Func(void)
2055          {
2056   1              uint16_t i;
2057   1              for (i = 0; i < 30; i++)
2058   1              {
2059   2                      if (insulationSet.DC.Num >= 2)
2060   2                      {
2061   3                              uint16_t insulationRes;
2062   3                              insulationRes = DC_Insulation[1].res[i];
2063   3                              insulationRes += i < insulationSet.DC.closeBus_2_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
2064   3                              write_dgus_vp(0x99A0 + i, (uint8_t *)&insulationRes, 1);
2065   3                              if (AC_Insulation.positiveBusToGroundVolt || AC_Insulation.negativeBusToGroundVolt)
2066   3                              {
2067   4                                      uint16_t temp = 1;
2068   4                                      if (insulationRes <= insulationSet.DC.resAlarm)
2069   4                                      {
2070   5                                              temp = 0;
2071   5                                      }
2072   4                                      write_dgus_vp(0x99C0 + i, (uint8_t *)&temp, 1);
2073   4                              }
2074   3                      }
2075   2              }
2076   1      
2077   1              if (sysInfoSet.siliconChain == 1)
2078   1              {
2079   2                      int16_t temp;
2080   2                      temp = DC_Insulation[0].closeBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
2081   2                      write_dgus_vp(0x99E0, (uint8_t *)&temp, 1);
2082   2      
2083   2                      temp = DC_Insulation[0].controlBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
2084   2                      write_dgus_vp(0x99E1, (uint8_t *)&temp, 1);
2085   2              }
2086   1              else if (sysInfoSet.siliconChain == 0)
2087   1              {
2088   2                      int32_t chargeModuleVolt; // 充电模块电压
2089   2                      int16_t displayVolt;
2090   2                      uint16_t i;
2091   2      
2092   2                      chargeModuleVolt = 0;
2093   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 35  

2094   2                      {
2095   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
2096   3                              {
2097   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
2098   4                              }
2099   3                      }
2100   2      
2101   2                      displayVolt = MAX(batteryVoltSum, chargeModuleVolt) - DC_Insulation[0].controlBusToGroundVolt;
2102   2                      write_dgus_vp(0x99E0, (uint8_t *)&displayVolt, 1);
2103   2                      write_dgus_vp(0x99E1, (uint8_t *)&displayVolt, 1);
2104   2              }
2105   1      
2106   1              write_dgus_vp(0x99E2, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
2107   1      
2108   1              write_dgus_vp(0x99E3, (uint8_t *)&AC_Insulation.alarmValue, 1);
2109   1      }
2110          
2111          void p94Func(void)
2112          {
2113   1              uint16_t i;
2114   1              if (batterySet.batteryType == XJ24)
2115   1              {
2116   2                      for (i = 0; i < 60; i++)
2117   2                      {
2118   3                              if (i < batterySet.xj24.cellNum)
2119   3                              {
2120   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
2121   4                              }
2122   3                              else
2123   3                              {
2124   4                                      uint16_t temp = 0;
2125   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
2126   4                              }
2127   3                      }
2128   2              }
2129   1              else if (batterySet.batteryType == XJ55)
2130   1              {
2131   2                      for (i = 0; i < 60; i++)
2132   2                      {
2133   3                              if (i < batterySet.xj24.cellNum)
2134   3                              {
2135   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
2136   4                              }
2137   3                              else
2138   3                              {
2139   4                                      uint16_t temp = 0;
2140   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
2141   4                              }
2142   3                      }
2143   2              }
2144   1      }
2145          
2146          void p113Func(void)
2147          {
2148   1              uint16_t i;
2149   1              if (batterySet.batteryType == XJ24)
2150   1              {
2151   2                      for (i = 60; i < 120; i++)
2152   2                      {
2153   3                              if (i < batterySet.xj24.cellNum)
2154   3                              {
2155   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 36  

2156   4                              }
2157   3                              else
2158   3                              {
2159   4                                      uint16_t temp = 0;
2160   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
2161   4                              }
2162   3                      }
2163   2              }
2164   1              else if (batterySet.batteryType == XJ55)
2165   1              {
2166   2                      for (i = 60; i < 120; i++)
2167   2                      {
2168   3                              if (i < batterySet.xj24.cellNum)
2169   3                              {
2170   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
2171   4                              }
2172   3                              else
2173   3                              {
2174   4                                      uint16_t temp = 0;
2175   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
2176   4                              }
2177   3                      }
2178   2              }
2179   1      }
2180          
2181          void p114Func()
2182          {
2183   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
2184   1              {
2185   2                      uint16_t i;
2186   2                      for (i = 0; i < 16; i++)
2187   2                      {
2188   3                              uint16_t swState;
2189   3                              swState = (remoteControlModule_ARD[1].sw1to16 >> i) & 0x01;
2190   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
2191   3                      }
2192   2              }
2193   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
2194   1              {
2195   2                      uint16_t i;
2196   2                      for (i = 0; i < 16; i++)
2197   2                      {
2198   3                              uint16_t swState;
2199   3                              swState = (remoteControlModule_TH[1].sw1to16 >> i) & 0x01;
2200   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
2201   3                      }
2202   2              }
2203   1              {
2204   2                      VariableChangedIndicationTypeDef variableChangedIndication;
2205   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
2206   2                      if (variableChangedIndication.flag == 0x5A)
2207   2                      {
2208   3                              uint16_t variable[5];
2209   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
2210   3                              switch (variableChangedIndication.addr)
2211   3                              {
2212   4                              case 0x97B0:
2213   4                              case 0x97B1:
2214   4                              case 0x97B2:
2215   4                              case 0x97B3:
2216   4                              case 0x97B4:
2217   4                              case 0x97B5:
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 37  

2218   4                              case 0x97B6:
2219   4                              case 0x97B7:
2220   4                              case 0x97B8:
2221   4                              case 0x97B9:
2222   4                              case 0x97BA:
2223   4                              case 0x97BB:
2224   4                              case 0x97BC:
2225   4                              case 0x97BD:
2226   4                              case 0x97BE:
2227   4                              case 0x97BF:
2228   4                              {
2229   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
2230   5                                      {
2231   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
2232   6                                              if (variable[0] == 0)
2233   6                                              {
2234   7                                                      static MMODBUS rtuSwOff[16];
2235   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2236   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
2237   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2238   7                                                      rtuSwOff[offset].mode = 0x00;
2239   7                                                      rtuSwOff[offset].flag = 0x00;
2240   7                                                      rtuSwOff[offset].Order = 0x06;
2241   7                                                      rtuSwOff[offset].Length = 0x01;
2242   7                                                      rtuSwOff[offset].reserved = 0x00;
2243   7                                                      rtuSwOff[offset].waitTime = 1000;
2244   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2245   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
2246   7                                                      rtuSwOff[offset].databuff = NULL;
2247   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2248   7                                                      pushToEmergency(rtuSwOff + offset);
2249   7                                              }
2250   6                                              else if (variable[0] == 1)
2251   6                                              {
2252   7                                                      static MMODBUS rtuSwOn[16];
2253   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2254   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
2255   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2256   7                                                      rtuSwOn[offset].mode = 0x00;
2257   7                                                      rtuSwOn[offset].flag = 0x00;
2258   7                                                      rtuSwOn[offset].Order = 0x06;
2259   7                                                      rtuSwOn[offset].Length = 0x01;
2260   7                                                      rtuSwOn[offset].reserved = 0x00;
2261   7                                                      rtuSwOn[offset].waitTime = 1000;
2262   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2263   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
2264   7                                                      rtuSwOn[offset].databuff = NULL;
2265   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2266   7                                                      pushToEmergency(rtuSwOn + offset);
2267   7                                              }
2268   6                                      }
2269   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
2270   5                                      {
2271   6                                              if (variable[0] == 0)
2272   6                                              {
2273   7                                                      static MMODBUS rtuSwOff[16];
2274   7                                                      uint16_t OffVal = 0x0000;
2275   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2276   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2277   7                                                      rtuSwOff[offset].mode = 0x00;
2278   7                                                      rtuSwOff[offset].flag = 0x00;
2279   7                                                      rtuSwOff[offset].Order = 0x06;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 38  

2280   7                                                      rtuSwOff[offset].Length = 0x01;
2281   7                                                      rtuSwOff[offset].reserved = 0x00;
2282   7                                                      rtuSwOff[offset].waitTime = 1000;
2283   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2284   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
2285   7                                                      rtuSwOff[offset].databuff = NULL;
2286   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OffVal, 1);
2287   7                                                      pushToEmergency(rtuSwOff + offset);
2288   7                                              }
2289   6                                              else if (variable[0] == 1)
2290   6                                              {
2291   7                                                      static MMODBUS rtuSwOn[16];
2292   7                                                      uint16_t OnVal = 0xFFFF;
2293   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2294   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2295   7                                                      rtuSwOn[offset].mode = 0x00;
2296   7                                                      rtuSwOn[offset].flag = 0x00;
2297   7                                                      rtuSwOn[offset].Order = 0x06;
2298   7                                                      rtuSwOn[offset].Length = 0x01;
2299   7                                                      rtuSwOn[offset].reserved = 0x00;
2300   7                                                      rtuSwOn[offset].waitTime = 1000;
2301   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2302   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
2303   7                                                      rtuSwOn[offset].databuff = NULL;
2304   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OnVal, 1);
2305   7                                                      pushToEmergency(rtuSwOn + offset);
2306   7                                              }
2307   6                                      }
2308   5                              }
2309   4                              break;
2310   4      
2311   4                              default:
2312   4                                      break;
2313   4                              }
2314   3                              memset(variable, 0, 5);
2315   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
2316   3                              variableChangedIndication.flag = 0;
2317   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
2318   3                      }
2319   2              }
2320   1      }
2321          
2322          code void (*PagePointer[])(void) = {
2323                  P0Func,
2324                  NULL,
2325                  P2Func,
2326                  NULL,
2327                  NULL,
2328                  NULL,
2329                  NULL,
2330                  NULL,
2331                  NULL,
2332                  NULL,
2333                  NULL,
2334                  P11Func,
2335                  P12Func,
2336                  NULL,                             // 13
2337                  NULL,                             // 14
2338                  NULL,                             // 15
2339                  NULL,                             // 16
2340                  NULL,                             // 17
2341                  P18Func,                          // 18
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 39  

2342                  NULL,                             // 19
2343                  NULL,                             // 20
2344                  NULL,                             // 21
2345                  P22Func,                          // 22
2346                  NULL,                             // 23
2347                  P24Func,                          // 24
2348                  NULL,                             // 25
2349                  P26Func,                          // 26
2350                  NULL,                             // 27
2351                  NULL,                             // 28
2352                  P29Func,                          // 29
2353                  NULL,                             // 30
2354                  NULL,                             // 31
2355                  NULL,                             // 32
2356                  P33Func,                          // 33
2357                  NULL,                             // 34
2358                  P35Func,                          // 35
2359                  NULL,                             // 36
2360                  NULL,                             // 37
2361                  NULL,                             // 38
2362                  P39Func,                          // 39
2363                  NULL,                             // 40
2364                  NULL,                             // 41
2365                  p42Func,                          // 42
2366                  NULL,                             // 43
2367                  p44Func,                          // 44
2368                  NULL,                             // 45
2369                  NULL,                             // 46
2370                  NULL,                             // 47
2371                  p48Func,                          // 48
2372                  NULL,                             // 49
2373                  p50Func,                          // 50
2374                  NULL,                             // 51
2375                  p52Func,                          // 52
2376                  NULL,                             // 53
2377                  NULL,                             // 54
2378                  NULL,                             // 55
2379                  NULL,                             // 56
2380                  NULL,                             // 57
2381                  NULL,                             // 58
2382                  realTimeAlarmDisplay, // 59
2383                  NULL,                             // 60
2384                  historyAlarmDisplay,  // 61
2385                  NULL,                             // 62
2386                  NULL,                             // 63
2387                  NULL,                             // 64
2388                  NULL,                             // 65
2389                  NULL,                             // 66
2390                  NULL,                             // 67
2391                  p68Func,                          // 68
2392                  NULL,                             // 69
2393                  p70Func,                          // 70
2394                  NULL,                             // 71
2395                  p72Func,                          // 72
2396                  NULL,                             // 73
2397                  NULL,                             // 74
2398                  p75Func,                          // 75
2399                  p76Func,                          // 76
2400                  p77Func,                          // 77
2401                  p78Func,                          // 78
2402                  p79Func,                          // 79
2403                  p80Func,                          // 80
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 40  

2404                  NULL,                             // 81
2405                  p82Func,                          // 82
2406                  NULL,                             // 83
2407                  NULL,                             // 84
2408                  p85Func,                          // 85
2409                  p86Func,                          // 86
2410                  p87Func,                          // 87
2411                  p88Func,                          // 88
2412                  NULL,                             // 89
2413                  NULL,                             // 90
2414                  NULL,                             // 91
2415                  NULL,                             // 92
2416                  NULL,                             // 93
2417                  p94Func,                          // 94
2418                  NULL,                             // 95
2419                  NULL,                             // 96
2420                  NULL,                             // 97
2421                  NULL,                             // 98
2422                  NULL,                             // 99
2423                  permissionLogin,          // 100
2424                  NULL,                             // 101
2425                  passwordModify,           // 102
2426                  NULL,                             // 103
2427                  NULL,                             // 104
2428                  NULL,                             // 105
2429                  NULL,                             // 106
2430                  NULL,                             // 107
2431                  NULL,                             // 108
2432                  NULL,                             // 109
2433                  NULL,                             // 110
2434                  NULL,                             // 111
2435                  NULL,                             // 112
2436                  p113Func,                         // 113
2437                  p114Func,                         // 114
2438                  NULL,                             // 115s
2439          };
2440          
2441          // code void (*pageOpenTreat[])(void) =
2442          // {
2443          
2444          // }
2445          
2446          /**
2447           * @brief 打开某页时执行的功能，主要为更新一次当前页的数据
2448           *
2449           * @param page
2450           */
2451          void pageOpenTreat(uint16_t page)
2452          {
2453   1              switch (page)
2454   1              {
2455   2              case 11:
2456   2                      write_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE); // 进入页面时刷新数据
2457   2                      break;
2458   2              case 12:
2459   2                      write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
2460   2                      break;
2461   2              case 18:
2462   2                      write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
2463   2                      break;
2464   2              case 22:
2465   2                      write_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 41  

2466   2                      break;
2467   2              case 29:
2468   2                      write_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, BATTERY_SET_SIZE);
2469   2                      break;
2470   2              case 33:
2471   2              {
2472   3                      uint8_t rtc[6];
2473   3                      memcpy(rtc, RTCdata, 3);
2474   3                      memcpy(rtc + 3, RTCdata + 4, 3);
2475   3                      write_dgus_vp(0x9D, (uint8_t *)&rtc, 3);
2476   3                      write_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
2477   3              }
2478   2              break;
2479   2              case 35:
2480   2                      write_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
2481   2                      break;
2482   2              case 39:
2483   2                      write_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
2484   2                      break;
2485   2              case 42:
2486   2                      write_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
2487   2                      break;
2488   2              case 44:
2489   2                      write_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
2490   2                      break;
2491   2              case 48:
2492   2                      write_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
2493   2                      break;
2494   2      
2495   2              default:
2496   2                      break;
2497   2              }
2498   1      }
2499          void PageFunction(void)
2500          {
2501   1              u16 pageid;
2502   1      
2503   1              static uint16_t oldPageid = 0;
2504   1      
2505   1              // EA = 0;
2506   1              ADR_H = 0x00;
2507   1              ADR_M = 0x00;
2508   1              ADR_L = 0x0a;
2509   1              ADR_INC = 1;
2510   1              RAMMODE = 0xAF;
2511   1              while (!APP_ACK)
2512   1                      ;
2513   1              APP_EN = 1;
2514   1              while (APP_EN)
2515   1                      ;
2516   1              pageid = DATA3;
2517   1              pageid <<= 8;
2518   1              pageid |= DATA2;
2519   1              RAMMODE = 0;
2520   1              EA = 1;
2521   1              if (PagePointer[pageid] != 0)
2522   1              {
2523   2                      PagePointer[pageid]();
2524   2              }
2525   1      
2526   1              if (pageid != oldPageid)
2527   1              {
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 42  

2528   2                      pageOpenTreat(pageid);
2529   2                      oldPageid = pageid;
2530   2              }
2531   1      }
2532          
2533          // /**
2534          //  * @brief 打开屏保，CFG未设置屏保的情况下，可以通过该代码设置
2535          //  *
2536          //  */
2537          // void openScreenProtection(void)
2538          // {
2539          //      // // 打开屏保
2540          //      // uint16_t data_0x80[2];
2541          //      // data_0x80[0] = 0x5A00;
2542          //      // read_dgus_vp(0x81, (uint8_t *)(data_0x80 + 1), 1);
2543          //      // data_0x80[1] |= 0x01 << 2;
2544          //      // write_dgus_vp(0x80, (uint8_t *)data_0x80, 2);
2545          
2546          //      // { // 设置屏保亮度
2547          //      //      struct
2548          //      //      {
2549          //      //              uint8_t OpenLuminance;           // 开启亮度
2550          //      //              uint8_t protectionLuminance; // 屏保亮度
2551          //      //      } screenLuminance;                               // 屏幕亮度
2552          //      //      read_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2553          //      //      screenLuminance.protectionLuminance = 0;
2554          //      //      write_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2555          //      // }
2556          // }
2557          
2558          void weekDisplay(void)
2559          {
2560   1              uint16_t weekday = RTCdata[3];
2561   1              write_dgus_vp(0xB000, (uint8_t *)&weekday, 1);
2562   1      }
2563          
2564          /**
2565           * @brief 屏保程序
2566           *
2567           */
2568          void screenProtection(void)
2569          {
2570   1              static uint16_t returnPage = 0;
2571   1              static uint16_t second = 0;
2572   1              struct
2573   1              {
2574   1                      uint8_t OpenLuminance;           // 开启亮度
2575   1                      uint8_t protectionLuminance; // 屏保亮度
2576   1              } screenLuminance;                               // 屏幕亮度
2577   1              uint16_t page;
2578   1              read_dgus_vp(PIC_NOW, (uint8_t *)&page, 1);
2579   1              if (page != SCREEN_PROTECTION_PAGE)
2580   1              {
2581   2                      if (GetTimeOutFlag(3))
2582   2                      {
2583   3                              second++;
2584   3                              if (second >= backLightTime[0])
2585   3                              {
2586   4                                      Page_Change(SCREEN_PROTECTION_PAGE);
2587   4                                      second = 0;
2588   4                                      screenLuminance.OpenLuminance = 0;
2589   4                                      write_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 43  

2590   4                                      returnPage = page;
2591   4                              }
2592   3                              StartTimer(3, 1000);
2593   3                      }
2594   2              }
2595   1              else if (page == SCREEN_PROTECTION_PAGE)
2596   1              {
2597   2                      uint16_t key;
2598   2      
2599   2                      read_dgus_vp(0xb100, (uint8_t *)&key, 1);
2600   2                      if (key == 1)
2601   2                      {
2602   3                              key = 0;
2603   3                              write_dgus_vp(0xb100, (uint8_t *)&key, 1);
2604   3                              screenLuminance.OpenLuminance = 100;
2605   3                              write_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2606   3                              Page_Change(returnPage);
2607   3                              StartTimer(3, 1000);
2608   3                      }
2609   2              }
2610   1      
2611   1              if (ScreenTouchOrNot())
2612   1              {
2613   2                      second = 0;
2614   2              }
2615   1      }
2616          
2617          /**
2618           * @brief 充电模式切换为浮充或均充
2619           *
2620           * @param chargeMode ：FLOAT_CHARGE/EQUALIZE_CHARGE
2621           */
2622          void chargeModeSwitch(uint16_t chargeMode)
2623          {
2624   1              static MMODBUS chargeCmd;
2625   1              if (chargeMode == FLOAT_CHARGE)
2626   1              {
2627   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2628   2                      chargeCmd.mode = 0x00;
2629   2                      chargeCmd.flag = 0x00;
2630   2                      chargeCmd.Order = 0x06;
2631   2                      chargeCmd.Length = 1;
2632   2                      chargeCmd.reserved = 0x00;
2633   2                      chargeCmd.waitTime = 1000;
2634   2                      chargeCmd.VPaddr = 0;
2635   2                      chargeCmd.ModbusReg = 0X0000;
2636   2                      chargeCmd.databuff = &batteryInfoSet.floatChargeVolt;
2637   2                      synthesisCollection.closeBusVolt = batteryInfoSet.floatChargeVolt; // 防止重复发送数据
2638   2              }
2639   1              else if (chargeMode == EQUALIZE_CHARGE)
2640   1              {
2641   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2642   2                      chargeCmd.mode = 0x00;
2643   2                      chargeCmd.flag = 0x00;
2644   2                      chargeCmd.Order = 0x06;
2645   2                      chargeCmd.Length = 1;
2646   2                      chargeCmd.reserved = 0x00;
2647   2                      chargeCmd.waitTime = 1000;
2648   2                      chargeCmd.VPaddr = 0;
2649   2                      chargeCmd.ModbusReg = 0X0000;
2650   2                      chargeCmd.databuff = &batteryInfoSet.equalizeChargeVolt;
2651   2                      synthesisCollection.closeBusVolt = batteryInfoSet.equalizeChargeVolt;
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 44  

2652   2              }
2653   1              pushToEmergency(&chargeCmd);
2654   1      }
2655          void batteryManage(void)
2656          {
2657   1              static int32_t totalSecond = 0;
2658   1              static uint16_t chargeState = FLOAT_CHARGE; // 充电状态：均充/浮充
2659   1              int16_t batteryCurr;                                            // 霍尔变比后电池组电流
2660   1      
2661   1              batteryCurr = (int32_t)synthesisCollection.batteryCurr * (int32_t)DC_InfoSet.batteryHallRatio / 100;
2662   1      
2663   1              {
2664   2                      if (batteryCurr < 0)
2665   2                      {
2666   3                              chargeState = DISCHARGE;
2667   3                              KillTimer(CHARGE_TIMER);
2668   3                              totalSecond = 0;
2669   3                      }
2670   2                      else if (batteryCurr >= 0)
2671   2                      {
2672   3                              if (synthesisCollection.closeBusVolt >= batteryInfoSet.equalizeChargeVolt)
2673   3                              { // 根据电压判断均充浮充
2674   4                                      if (chargeState != EQUALIZE_CHARGE)
2675   4                                      {
2676   5                                              chargeState = EQUALIZE_CHARGE;
2677   5                                              StartTimer(CHARGE_TIMER, 1000);
2678   5                                              totalSecond = (int32_t)batteryInfoSet.equalizeChargeHour * 60 * 60;
2679   5                                      }
2680   4                              }
2681   3                              else if (synthesisCollection.closeBusVolt <= batteryInfoSet.floatChargeVolt)
2682   3                              {
2683   4                                      if (chargeState != FLOAT_CHARGE)
2684   4                                      {
2685   5                                              chargeState = FLOAT_CHARGE;
2686   5                                              StartTimer(CHARGE_TIMER, 1000);
2687   5                                              totalSecond = (int32_t)batteryInfoSet.floatChargeDay * 24 * 60 * 60;
2688   5                                      }
2689   4                              }
2690   3      
2691   3                              {
2692   4                                      int32_t equalizeCurr; // 均充电流
2693   4                                      int32_t floatCurr;        // 浮充电流
2694   4                                      equalizeCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.floatToEqualizeChargeCur / 100
             -0;
2695   4                                      floatCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.equalizeToFloatChargeCur / 1000;
2696   4                                      if (batteryCurr >= equalizeCurr)
2697   4                                      {
2698   5                                              if (chargeState != EQUALIZE_CHARGE)
2699   5                                              {
2700   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2701   6                                              }
2702   5                                      }
2703   4                                      else if (batteryCurr <= floatCurr)
2704   4                                      {
2705   5                                              if (chargeState != FLOAT_CHARGE)
2706   5                                              {
2707   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2708   6                                              }
2709   5                                      }
2710   4                              }
2711   3      
2712   3                              if (GetTimeOutFlag(CHARGE_TIMER))
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 45  

2713   3                              {
2714   4                                      totalSecond--;
2715   4                                      if (totalSecond <= 0)
2716   4                                      {
2717   5                                              if (chargeState == FLOAT_CHARGE)
2718   5                                              {
2719   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2720   6                                              }
2721   5                                              else if (chargeState == EQUALIZE_CHARGE)
2722   5                                              {
2723   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2724   6                                              }
2725   5                                      }
2726   4                                      StartTimer(CHARGE_TIMER, 1000);
2727   4                                      {
2728   5                                              timeTypeDef chargeTime;
2729   5                                              chargeTime.day = totalSecond / 60 / 60 / 24;
2730   5                                              chargeTime.hour = totalSecond / 60 / 60 % 24;
2731   5                                              chargeTime.minite = totalSecond / 60 % 60;
2732   5                                              chargeTime.second = totalSecond % 60;
2733   5                                              write_dgus_vp(0xB010, (uint8_t *)&chargeTime, 10);
2734   5                                      }
2735   4                              }
2736   3                      }
2737   2                      write_dgus_vp(0xB002, (uint8_t *)&chargeState, 1);
2738   2              }
2739   1      }
2740          
2741          int16_t batteryVoltSum;
2742          
2743          void batteryVoltDisplay()
2744          {
2745   1              int16_t sum;
2746   1              uint16_t i;
2747   1              if (batterySet.xj24.cellNum > 0)
2748   1              {
2749   2                      if (batterySet.batteryType == XJ24)
2750   2                      {
2751   3                              sum = 0;
2752   3                              for (i = 0; i < batterySet.xj24.cellNum; i++)
2753   3                              {
2754   4                                      sum += battery_xj24[i / 24].volt[i % 24];
2755   4                              }
2756   3                      }
2757   2                      else if (batterySet.batteryType == XJ55)
2758   2                      {
2759   3                              sum = 0;
2760   3                              for (i = 0; i < batterySet.xj55.cellNum; i++)
2761   3                              {
2762   4                                      sum += battery_xj55[i / 55].volt[i % 55];
2763   4                              }
2764   3                      }
2765   2              }
2766   1              else if (batterySet.xj24.cellNum == 0)
2767   1              {
2768   2                      sum = synthesisCollection.batteryVolt;
2769   2              }
2770   1              batteryVoltSum = sum;
2771   1              write_dgus_vp(0xB020, (uint8_t *)&batteryVoltSum, 1);
2772   1      }
2773          
2774          void batteryCurrDisplay(void)
C51 COMPILER V9.60.7.0   UI                                                                05/11/2023 11:48:28 PAGE 46  

2775          {
2776   1              write_dgus_vp(0xB022, (uint8_t *)&synthesisCollection.batteryCurr, 1);
2777   1      }
2778          
2779          void alarmSoundPlay()
2780          {
2781   1              extern AlarmTypeDef realTimeAlarmHeader;
2782   1              if (realTimeAlarmHeader.nextVP != 0)
2783   1              {
2784   2                      if (alarmSoundOnOff[0])
2785   2                      {
2786   3                              u8 buzzer[4] = {0x00, 0x3E, 0x40, 0x00};
2787   3                              write_dgus_vp(0xA0, buzzer, 2);
2788   3                      }
2789   2              }
2790   1      }
2791          void publicUI(void)
2792          {
2793   1              weekDisplay();
2794   1              batteryVoltDisplay();
2795   1              batteryCurrDisplay();
2796   1              {
2797   2                      extern AlarmTypeDef realTimeAlarmHeader;
2798   2                      uint16_t temp;
2799   2                      if (realTimeAlarmHeader.nextVP == 0)
2800   2                      {
2801   3                              temp = 1;
2802   3                      }
2803   2                      else
2804   2                      {
2805   3                              temp = 0;
2806   3                      }
2807   2                      write_dgus_vp(0xB030, (uint8_t *)&temp, 1);
2808   2              }
2809   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  20701    ----
   CONSTANT SIZE    =    357    ----
   XDATA SIZE       =   2252     396
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
