C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UI
OBJECT MODULE PLACED IN .\Objects\ui.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\ui.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.\li
                    -b) DEBUG OBJECTEXTEND PRINT(.\Listings\ui.lst) OBJECT(.\Objects\ui.obj)

line level    source

   1          #include "ui.h"
   2          #include "modbus.h"
   3          #include <STRING.H>
   4          #include "permission.h"
   5          #include "debug.h"
   6          #include "norflash.h"
   7          #include <STDLIB.H>
   8          #include "rtc.h"
   9          #include "const.h"
  10          #include "data.h"
  11          #include "umath.h"
  12          #include "timer.h"
  13          #include "alarm.h"
  14          
  15          #define testDis 0
  16          void testDisplayNum(u16 addr, u16 num)
  17          {
  18   1      #if testDis
              
              #else
  21   1              write_dgus_vp(addr, (u8 *)&num, 1);
  22   1      #endif
  23   1      }
  24          
  25          // 读取按键0x1000的值
  26          u8 getTouch(void)
  27          {
  28   1              u8 tmp;
  29   1              // EA = 0;
  30   1              ADR_H = 0x00;
  31   1              ADR_M = 0x08; // 0x1000
  32   1              ADR_L = 0x00;
  33   1              ADR_INC = 1;
  34   1              RAMMODE = 0xAF;
  35   1              while (!APP_ACK)
  36   1                      ;
  37   1              APP_EN = 1;
  38   1              while (APP_EN)
  39   1                      ;
  40   1              // str[0] = DATA3;
  41   1              tmp = DATA2;
  42   1              // EA = 1;
  43   1              RAMMODE = 0;
  44   1              return tmp;
  45   1      }
  46          
  47          // 清除按键0x1000的值
  48          void clrTouch(void)
  49          {
  50   1              // EA = 0;
  51   1              ADR_H = 0x00;
  52   1              ADR_M = 0x08; // 0x1000
  53   1              ADR_L = 0x00;
  54   1              ADR_INC = 1;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 2   

  55   1              RAMMODE = 0x8C;
  56   1              while (!APP_ACK)
  57   1                      ;
  58   1              DATA3 = 0;
  59   1              DATA2 = 0;
  60   1              APP_EN = 1;
  61   1              while (APP_EN)
  62   1                      ;
  63   1              RAMMODE = 0;
  64   1              // EA = 1;
  65   1      }
  66          
  67          void P0Func(void)
  68          {
  69   1              VariableChangedIndicationTypeDef variableChangedIndication;
  70   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
  71   1              if (variableChangedIndication.flag == 0x5A)
  72   1              {
  73   2                      uint16_t variable[5];
  74   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
  75   2                      switch (variableChangedIndication.addr)
  76   2                      {
  77   3                      case 0x8000:
  78   3                              if (variable[0] == 1)
  79   3                              {
  80   4                                      if (manager.loginFlag || admin.loginFlag)
  81   4                                      {
  82   5                                              Page_Change(SYS_FUNCTION_TABLE_PAGE);
  83   5                                      }
  84   4                                      else
  85   4                                      {
  86   5                                              passwordLogin(SYS_FUNCTION_TABLE_PAGE);
  87   5                                      }
  88   4                              }
  89   3                              break;
  90   3                      case 0x8001:
  91   3                              if (variable[0] == 1)
  92   3                              {
  93   4                                      if (manager.loginFlag || admin.loginFlag)
  94   4                                      {
  95   5                                              Page_Change(BATTERY_MANAGER_PAGE);
  96   5                                      }
  97   4                                      else
  98   4                                      {
  99   5                                              passwordLogin(BATTERY_MANAGER_PAGE);
 100   5                                      }
 101   4                              }
 102   3                              break;
 103   3                      case 0x8006:
 104   3                              if (variable[0] == 1)
 105   3                              {
 106   4                                      if (chargeModuleSet.moduleNum > 0)
 107   4                                      {
 108   5                                              Page_Change(CHARGE_DATA_PAGE);
 109   5                                      }
 110   4                              }
 111   3                              break;
 112   3                      case 0x8007:
 113   3                              if (variable[0] == 1)
 114   3                              {
 115   4                                      if (batterySet.batteryType == XJ24)
 116   4                                      {
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 3   

 117   5                                              if (batterySet.xj24.batteryModuleNum > 0)
 118   5                                              {
 119   6                                                      Page_Change(BATTERY_DATA_PAGE);
 120   6                                              }
 121   5                                      }
 122   4                                      else if (batterySet.batteryType == XJ55)
 123   4                                      {
 124   5                                              if (batterySet.xj55.batteryModuleNum > 0)
 125   5                                              {
 126   6                                                      Page_Change(BATTERY_DATA_PAGE);
 127   6                                              }
 128   5                                      }
 129   4                              }
 130   3                              break;
 131   3                      case 0x8008:
 132   3                              if (variable[0] == 1)
 133   3                              {
 134   4                                      if (switchModuleSet.switchModule.switchNum > 0)
 135   4                                      {
 136   5                                              Page_Change(SWITCH_MODULE_DATA_PAGE);
 137   5                                      }
 138   4                              }
 139   3                              break;
 140   3                      case 0x800A:
 141   3                              if (variable[0] == 1)
 142   3                              {
 143   4                                      if (UPS_INV_Set.UPS_Num > 0)
 144   4                                      {
 145   5                                              Page_Change(UPS_DATA_PAGE);
 146   5                                      }
 147   4                              }
 148   3                              break;
 149   3                      case 0x800B:
 150   3                              if (variable[0] == 1)
 151   3                              {
 152   4                                      if (DC_ConverterSet.Num > 0)
 153   4                                      {
 154   5                                              Page_Change(DC_CONVERTER_DATA_PAGE);
 155   5                                      }
 156   4                              }
 157   3                              break;
 158   3                      case 0x800C:
 159   3                              if (variable[0] == 1)
 160   3                              {
 161   4                                      if (insulationSet.DC.Num > 0)
 162   4                                      {
 163   5                                              Page_Change(INSULATION_DATA_PAGE);
 164   5                                      }
 165   4                                      else
 166   4                                      {
 167   5                                              Page_Change(NON_INSULATION_DATA_PAGE);
 168   5                                      }
 169   4                              }
 170   3                              break;
 171   3                      default:
 172   3                              break;
 173   3                      }
 174   2                      memset(variable, 0, 5);
 175   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 176   2                      variableChangedIndication.flag = 0;
 177   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 178   2              }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 4   

 179   1      
 180   1              if (manager.loginFlag)
 181   1              {
 182   2                      manager.loginFlag = 0;
 183   2              }
 184   1              if (admin.loginFlag)
 185   1              {
 186   2                      admin.loginFlag = 0;
 187   2              }
 188   1      }
 189          
 190          void P2Func(void)
 191          {
 192   1              VariableChangedIndicationTypeDef variableChangedIndication;
 193   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 194   1              if (variableChangedIndication.flag == 0x5A)
 195   1              {
 196   2                      uint16_t variable[5];
 197   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 198   2                      switch (variableChangedIndication.addr)
 199   2                      {
 200   3                      case 0x8020:
 201   3                              if (variable[0] == 1)
 202   3                              {
 203   4                                      if (manager.loginFlag || admin.loginFlag)
 204   4                                      {
 205   5                                              Page_Change(SYS_INFO_PAGE);
 206   5                                      }
 207   4                                      else
 208   4                                      {
 209   5                                              passwordLogin(SYS_INFO_PAGE);
 210   5                                      }
 211   4                              }
 212   3                              break;
 213   3                      case 0x8021:
 214   3                              if (variable[0] == 1)
 215   3                              {
 216   4                                      if (manager.loginFlag || admin.loginFlag)
 217   4                                      {
 218   5                                              Page_Change(SWITCH_MODULE_SET_PAGE);
 219   5                                      }
 220   4                                      else
 221   4                                      {
 222   5                                              passwordLogin(SWITCH_MODULE_SET_PAGE);
 223   5                                      }
 224   4                              }
 225   3                              break;
 226   3                      case 0x8022:
 227   3                              if (variable[0] == 1)
 228   3                              {
 229   4                                      if (manager.loginFlag || admin.loginFlag)
 230   4                                      {
 231   5                                              Page_Change(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 232   5                                      }
 233   4                                      else
 234   4                                      {
 235   5                                              passwordLogin(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 236   5                                      }
 237   4                              }
 238   3                              break;
 239   3                      case 0x8023:
 240   3                              if (variable[0] == 1)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 5   

 241   3                              {
 242   4                                      if (manager.loginFlag || admin.loginFlag)
 243   4                                      {
 244   5                                              Page_Change(INSULATION_SET_PAGE);
 245   5                                      }
 246   4                                      else
 247   4                                      {
 248   5                                              passwordLogin(INSULATION_SET_PAGE);
 249   5                                      }
 250   4                              }
 251   3                              break;
 252   3                      case 0x8024:
 253   3                              if (variable[0] == 1)
 254   3                              {
 255   4                                      if (manager.loginFlag || admin.loginFlag)
 256   4                                      {
 257   5                                              Page_Change(CHARGER_MODULE_SET_PAGE);
 258   5                                      }
 259   4                                      else
 260   4                                      {
 261   5                                              passwordLogin(CHARGER_MODULE_SET_PAGE);
 262   5                                      }
 263   4                              }
 264   3                              break;
 265   3                      case 0x8025:
 266   3                              if (variable[0] == 1)
 267   3                              {
 268   4                                      if (manager.loginFlag || admin.loginFlag)
 269   4                                      {
 270   5                                              Page_Change(DC_MODULE_SET_PAGE);
 271   5                                      }
 272   4                                      else
 273   4                                      {
 274   5                                              passwordLogin(DC_MODULE_SET_PAGE);
 275   5                                      }
 276   4                              }
 277   3                              break;
 278   3                      case 0x8026:
 279   3                              if (variable[0] == 1)
 280   3                              {
 281   4                                      if (manager.loginFlag || admin.loginFlag)
 282   4                                      {
 283   5                                              Page_Change(UPS_INV_SET_PAGE);
 284   5                                      }
 285   4                                      else
 286   4                                      {
 287   5                                              passwordLogin(UPS_INV_SET_PAGE);
 288   5                                      }
 289   4                              }
 290   3                              break;
 291   3                      case 0x8027:
 292   3                              if (variable[0] == 1)
 293   3                              {
 294   4                                      if (admin.loginFlag)
 295   4                                      {
 296   5                                              Page_Change(RECOVERY_PAGE);
 297   5                                      }
 298   4                                      else
 299   4                                      {
 300   5                                              passwordLogin(RECOVERY_PAGE);
 301   5                                      }
 302   4                              }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 6   

 303   3                              break;
 304   3      
 305   3                      default:
 306   3                              break;
 307   3                      }
 308   2                      memset(variable, 0, 5);
 309   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 310   2                      variableChangedIndication.flag = 0;
 311   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 312   2              }
 313   1      }
 314          
 315          void P11Func(void)
 316          {
 317   1              VariableChangedIndicationTypeDef variableChangedIndication;
 318   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 319   1              if (variableChangedIndication.flag == 0x5A)
 320   1              {
 321   2                      uint16_t variable[5];
 322   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 323   2                      switch (variableChangedIndication.addr)
 324   2                      {
 325   3                      case 0x8041:
 326   3                              if (variable[0] == 1)
 327   3                              {
 328   4                                      read_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE);
 329   4                                      dgusToNorFlash(SYS_INFO_NORFLASH_ADDR, SYS_INFO_VP, SYS_INFO_SIZE);
 330   4                                      modbusCenerate();
 331   4                                      // DEBUGINFO("save sysInfo");
 332   4                              }
 333   3                              break;
 334   3                      default:
 335   3                              break;
 336   3                      }
 337   2                      memset(variable, 0, 5);
 338   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 339   2      
 340   2                      variableChangedIndication.flag = 0;
 341   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 342   2              }
 343   1      }
 344          
 345          void P12Func()
 346          {
 347   1              VariableChangedIndicationTypeDef variableChangedIndication;
 348   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 349   1              if (variableChangedIndication.flag == 0x5A)
 350   1              {
 351   2                      uint16_t variable[5];
 352   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 353   2                      switch (variableChangedIndication.addr)
 354   2                      {
 355   3                      case 0x8060:
 356   3                              if (variable[0] == 1)
 357   3                              {
 358   4                                      read_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
 359   4                                      dgusToNorFlash(AC_INFO_NORFLASH_ADDR, AC_INFO_VP, AC_INFO_SIZE);
 360   4                                      modbusCenerate();
 361   4                              }
 362   3                              break;
 363   3                      default:
 364   3                              break;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 7   

 365   3                      }
 366   2                      memset(variable, 0, 5);
 367   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 368   2      
 369   2                      variableChangedIndication.flag = 0;
 370   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 371   2              }
 372   1      }
 373          
 374          void P18Func()
 375          {
 376   1              VariableChangedIndicationTypeDef variableChangedIndication;
 377   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 378   1              if (variableChangedIndication.flag == 0x5A)
 379   1              {
 380   2                      uint16_t variable[5];
 381   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 382   2                      switch (variableChangedIndication.addr)
 383   2                      {
 384   3                      case 0x8060:
 385   3                              if (variable[0] == 1)
 386   3                              {
 387   4                                      read_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
 388   4                                      dgusToNorFlash(DC_INFO_NORFLASH_ADDR, DC_INFO_VP, DC_INFO_SIZE);
 389   4                                      modbusCenerate();
 390   4                              }
 391   3                              break;
 392   3                      case 0x90B1:
 393   3                      {
 394   4                              if (sysInfoSet.siliconChain == 0)
 395   4                              {
 396   5                                      write_dgus_vp(0x90A1, (uint8_t *)&variable, 1);
 397   5                              }
 398   4                              else
 399   4                              {
 400   5                                      write_dgus_vp(0x90A5, (uint8_t *)&variable, 1);
 401   5                              }
 402   4                      }
 403   3                      break;
 404   3                      case 0x90B2:
 405   3                      {
 406   4                              if (sysInfoSet.siliconChain == 0)
 407   4                              {
 408   5                                      write_dgus_vp(0x90A2, (uint8_t *)&variable, 1);
 409   5                              }
 410   4                              else
 411   4                              {
 412   5                                      write_dgus_vp(0x90A6, (uint8_t *)&variable, 1);
 413   5                              }
 414   4                      }
 415   3                      break;
 416   3                      case 0x90B3:
 417   3                      {
 418   4                              if (sysInfoSet.siliconChain == 0)
 419   4                              {
 420   5                                      write_dgus_vp(0x90A3, (uint8_t *)&variable, 1);
 421   5                              }
 422   4                              else
 423   4                              {
 424   5                                      write_dgus_vp(0x90A7, (uint8_t *)&variable, 1);
 425   5                              }
 426   4                      }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 8   

 427   3                      break;
 428   3                      case 0x90B4:
 429   3                      {
 430   4                              if (sysInfoSet.siliconChain == 0)
 431   4                              {
 432   5                                      write_dgus_vp(0x90A4, (uint8_t *)&variable, 1);
 433   5                              }
 434   4                              else
 435   4                              {
 436   5                                      write_dgus_vp(0x90A8, (uint8_t *)&variable, 1);
 437   5                              }
 438   4                      }
 439   3                      break;
 440   3                      default:
 441   3                              break;
 442   3                      }
 443   2                      memset(variable, 0, 5);
 444   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)variable, variableChangedIndication.len);
 445   2      
 446   2                      variableChangedIndication.flag = 0;
 447   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 448   2              }
 449   1      
 450   1              {
 451   2                      if (sysInfoSet.sysVoltageGrade == SYSTEM_220V)
 452   2                      {
 453   3                              uint16_t sp; // 描述指针
 454   3                              sp = 0x90A1;
 455   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 456   3                              sp = 0x90A2;
 457   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 458   3                              sp = 0x90A3;
 459   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 460   3                              sp = 0x90A4;
 461   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 462   3                      }
 463   2                      else if (sysInfoSet.sysVoltageGrade == SYSTEM_110V)
 464   2                      {
 465   3                              uint16_t sp; // 描述指针
 466   3                              sp = 0x90A5;
 467   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 468   3                              sp = 0x90A6;
 469   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 470   3                              sp = 0x90A7;
 471   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 472   3                              sp = 0x90A8;
 473   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 474   3                      }
 475   2              }
 476   1      }
 477          
 478          void P22Func()
 479          {
 480   1              VariableChangedIndicationTypeDef variableChangedIndication;
 481   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 482   1              if (variableChangedIndication.flag == 0x5A)
 483   1              {
 484   2                      uint16_t variable[5];
 485   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 486   2                      switch (variableChangedIndication.addr)
 487   2                      {
 488   3                      case 0x8080:
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 9   

 489   3                              if (variable[0] == 1)
 490   3                              {
 491   4                                      read_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
 492   4                                      dgusToNorFlash(BATTERY_INFO_NORFLASH_ADDR, BATTERY_INFO_VP, BATTERY_SET_SIZE);
 493   4                                      modbusCenerate();
 494   4                              }
 495   3                              break;
 496   3                      case 0x9120:
 497   3                              if (variable[0] == 1)
 498   3                              {
 499   4                                      chargeModeSwitch(FLOAT_CHARGE);
 500   4                              }
 501   3                              break;
 502   3                      case 0x9121:
 503   3                              if (variable[0] == 1)
 504   3                              {
 505   4                                      chargeModeSwitch(EQUALIZE_CHARGE);
 506   4                              }
 507   3                              break;
 508   3                      default:
 509   3                              break;
 510   3                      }
 511   2                      memset(variable, 0, 5);
 512   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 513   2      
 514   2                      variableChangedIndication.flag = 0;
 515   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 516   2              }
 517   1      }
 518          
 519          void P26Func()
 520          {
 521   1              VariableChangedIndicationTypeDef variableChangedIndication;
 522   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 523   1              if (variableChangedIndication.flag == 0x5A)
 524   1              {
 525   2                      uint16_t variable[5];
 526   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 527   2                      switch (variableChangedIndication.addr)
 528   2                      {
 529   3                      case 0x9150:
 530   3                              if (variable[0] == 1)
 531   3                              {
 532   4                                      passwordLogin(26);
 533   4                              }
 534   3                              break;
 535   3                      case 0x9152:
 536   3                              if (variable[0] == 1)
 537   3                              {
 538   4                                      manager.loginFlag = 0;
 539   4                                      admin.loginFlag = 0;
 540   4                              }
 541   3                              break;
 542   3                      default:
 543   3                              break;
 544   3                      }
 545   2                      memset(variable, 0, 5);
 546   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 547   2                      variableChangedIndication.flag = 0;
 548   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 549   2              }
 550   1      
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 10  

 551   1              { // 当前登录用户显示
 552   2                      int16_t userNum;
 553   2                      if (admin.loginFlag)
 554   2                      {
 555   3                              userNum = 2;
 556   3                      }
 557   2                      else if (manager.loginFlag)
 558   2                      {
 559   3                              userNum = 1;
 560   3                      }
 561   2                      else
 562   2                      {
 563   3                              userNum = 0;
 564   3                      }
 565   2                      write_dgus_vp(0x9160, (uint8_t *)&userNum, 1);
 566   2              }
 567   1      }
 568          
 569          void P29Func()
 570          {
 571   1              VariableChangedIndicationTypeDef variableChangedIndication;
 572   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 573   1              if (variableChangedIndication.flag == 0x5A)
 574   1              {
 575   2                      uint16_t variable[5];
 576   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 577   2                      switch (variableChangedIndication.addr)
 578   2                      {
 579   3                      case 0x80C0:
 580   3                              if (variable[0] == 1)
 581   3                              {
 582   4                                      read_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, SPECIAL_PARA_SIZE);
 583   4                                      dgusToNorFlash(SPECIAL_PARA_NORFLASH_ADDR, SPECIAL_PARA_VP, SPECIAL_PARA_SIZE);
 584   4                                      modbusCenerate();
 585   4                              }
 586   3                              break;
 587   3                      case 0x91B2:
 588   3                      {
 589   4                              static MMODBUS closeBusVoltRectify;
 590   4                              closeBusVoltRectify.SlaveAddr = 0x61;
 591   4                              closeBusVoltRectify.mode = 0x00;
 592   4                              closeBusVoltRectify.flag = 0x00;
 593   4                              closeBusVoltRectify.Order = 0x06;
 594   4                              closeBusVoltRectify.Length = 0x01;
 595   4                              closeBusVoltRectify.reserved = 0x00;
 596   4                              closeBusVoltRectify.waitTime = 1000;
 597   4                              closeBusVoltRectify.VPaddr = 0x91B2;
 598   4                              closeBusVoltRectify.ModbusReg = 0x0000;
 599   4                              closeBusVoltRectify.databuff = NULL;
 600   4                              pushToEmergency(&closeBusVoltRectify);
 601   4                      }
 602   3                      break;
 603   3                      case 0x91B3:
 604   3                      {
 605   4                              static MMODBUS controlBusVoltRectify;
 606   4                              controlBusVoltRectify.SlaveAddr = 0x61;
 607   4                              controlBusVoltRectify.mode = 0x00;
 608   4                              controlBusVoltRectify.flag = 0x00;
 609   4                              controlBusVoltRectify.Order = 0x06;
 610   4                              controlBusVoltRectify.Length = 0x01;
 611   4                              controlBusVoltRectify.reserved = 0x00;
 612   4                              controlBusVoltRectify.waitTime = 1000;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 11  

 613   4                              controlBusVoltRectify.VPaddr = 0x91B3;
 614   4                              controlBusVoltRectify.ModbusReg = 0x0001;
 615   4                              controlBusVoltRectify.databuff = NULL;
 616   4                              pushToEmergency(&controlBusVoltRectify);
 617   4                      }
 618   3                      break;
 619   3                      case 0x91B4:
 620   3                      {
 621   4                              static MMODBUS busToGroundVoltRectify;
 622   4                              busToGroundVoltRectify.SlaveAddr = 0x61;
 623   4                              busToGroundVoltRectify.mode = 0x00;
 624   4                              busToGroundVoltRectify.flag = 0x00;
 625   4                              busToGroundVoltRectify.Order = 0x06;
 626   4                              busToGroundVoltRectify.Length = 0x01;
 627   4                              busToGroundVoltRectify.reserved = 0x00;
 628   4                              busToGroundVoltRectify.waitTime = 1000;
 629   4                              busToGroundVoltRectify.VPaddr = 0x91B4;
 630   4                              busToGroundVoltRectify.ModbusReg = 0x0002;
 631   4                              busToGroundVoltRectify.databuff = NULL;
 632   4                              pushToEmergency(&busToGroundVoltRectify);
 633   4                      }
 634   3                      break;
 635   3                      case 0x91B5:
 636   3                      {
 637   4                              static MMODBUS batteryVoltRectify;
 638   4                              batteryVoltRectify.SlaveAddr = 0x61;
 639   4                              batteryVoltRectify.mode = 0x00;
 640   4                              batteryVoltRectify.flag = 0x00;
 641   4                              batteryVoltRectify.Order = 0x06;
 642   4                              batteryVoltRectify.Length = 0x01;
 643   4                              batteryVoltRectify.reserved = 0x00;
 644   4                              batteryVoltRectify.waitTime = 1000;
 645   4                              batteryVoltRectify.VPaddr = 0x91B5;
 646   4                              batteryVoltRectify.ModbusReg = 0x0003;
 647   4                              batteryVoltRectify.databuff = NULL;
 648   4                              pushToEmergency(&batteryVoltRectify);
 649   4                      }
 650   3                      break;
 651   3      
 652   3                      case 0x91B6:
 653   3                      {
 654   4                              static MMODBUS AC1_Ua_Rectify;
 655   4                              AC1_Ua_Rectify.SlaveAddr = 0x61;
 656   4                              AC1_Ua_Rectify.mode = 0x00;
 657   4                              AC1_Ua_Rectify.flag = 0x00;
 658   4                              AC1_Ua_Rectify.Order = 0x06;
 659   4                              AC1_Ua_Rectify.Length = 0x01;
 660   4                              AC1_Ua_Rectify.reserved = 0x00;
 661   4                              AC1_Ua_Rectify.waitTime = 1000;
 662   4                              AC1_Ua_Rectify.VPaddr = 0x91B6;
 663   4                              AC1_Ua_Rectify.ModbusReg = 0x0006;
 664   4                              AC1_Ua_Rectify.databuff = NULL;
 665   4                              pushToEmergency(&AC1_Ua_Rectify);
 666   4                      }
 667   3                      break;
 668   3      
 669   3                      case 0x91B7:
 670   3                      {
 671   4                              static MMODBUS AC1_Ub_Rectify;
 672   4                              AC1_Ub_Rectify.SlaveAddr = 0x61;
 673   4                              AC1_Ub_Rectify.mode = 0x00;
 674   4                              AC1_Ub_Rectify.flag = 0x00;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 12  

 675   4                              AC1_Ub_Rectify.Order = 0x06;
 676   4                              AC1_Ub_Rectify.Length = 0x01;
 677   4                              AC1_Ub_Rectify.reserved = 0x00;
 678   4                              AC1_Ub_Rectify.waitTime = 1000;
 679   4                              AC1_Ub_Rectify.VPaddr = 0x91B7;
 680   4                              AC1_Ub_Rectify.ModbusReg = 0x0007;
 681   4                              AC1_Ub_Rectify.databuff = NULL;
 682   4                              pushToEmergency(&AC1_Ub_Rectify);
 683   4                      }
 684   3                      break;
 685   3                      case 0x91B8:
 686   3                      {
 687   4                              static MMODBUS AC1_Uc_Rectify;
 688   4                              AC1_Uc_Rectify.SlaveAddr = 0x61;
 689   4                              AC1_Uc_Rectify.mode = 0x00;
 690   4                              AC1_Uc_Rectify.flag = 0x00;
 691   4                              AC1_Uc_Rectify.Order = 0x06;
 692   4                              AC1_Uc_Rectify.Length = 0x01;
 693   4                              AC1_Uc_Rectify.reserved = 0x00;
 694   4                              AC1_Uc_Rectify.waitTime = 1000;
 695   4                              AC1_Uc_Rectify.VPaddr = 0x91B8;
 696   4                              AC1_Uc_Rectify.ModbusReg = 0x0008;
 697   4                              AC1_Uc_Rectify.databuff = NULL;
 698   4                              pushToEmergency(&AC1_Uc_Rectify);
 699   4                      }
 700   3                      break;
 701   3                      case 0x91B9:
 702   3                      {
 703   4                              static MMODBUS AC2_Ua_Rectify;
 704   4                              AC2_Ua_Rectify.SlaveAddr = 0x61;
 705   4                              AC2_Ua_Rectify.mode = 0x00;
 706   4                              AC2_Ua_Rectify.flag = 0x00;
 707   4                              AC2_Ua_Rectify.Order = 0x06;
 708   4                              AC2_Ua_Rectify.Length = 0x01;
 709   4                              AC2_Ua_Rectify.reserved = 0x00;
 710   4                              AC2_Ua_Rectify.waitTime = 1000;
 711   4                              AC2_Ua_Rectify.VPaddr = 0x91B9;
 712   4                              AC2_Ua_Rectify.ModbusReg = 0x0009;
 713   4                              AC2_Ua_Rectify.databuff = NULL;
 714   4                              pushToEmergency(&AC2_Ua_Rectify);
 715   4                      }
 716   3                      break;
 717   3                      case 0x91BA:
 718   3                      {
 719   4                              static MMODBUS AC2_Ub_Rectify;
 720   4                              AC2_Ub_Rectify.SlaveAddr = 0x61;
 721   4                              AC2_Ub_Rectify.mode = 0x00;
 722   4                              AC2_Ub_Rectify.flag = 0x00;
 723   4                              AC2_Ub_Rectify.Order = 0x06;
 724   4                              AC2_Ub_Rectify.Length = 0x01;
 725   4                              AC2_Ub_Rectify.reserved = 0x00;
 726   4                              AC2_Ub_Rectify.waitTime = 1000;
 727   4                              AC2_Ub_Rectify.VPaddr = 0x91BA;
 728   4                              AC2_Ub_Rectify.ModbusReg = 0x000A;
 729   4                              AC2_Ub_Rectify.databuff = NULL;
 730   4                              pushToEmergency(&AC2_Ub_Rectify);
 731   4                      }
 732   3                      break;
 733   3                      case 0x91BB:
 734   3                      {
 735   4                              static MMODBUS AC2_Uc_Rectify;
 736   4                              AC2_Uc_Rectify.SlaveAddr = 0x61;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 13  

 737   4                              AC2_Uc_Rectify.mode = 0x00;
 738   4                              AC2_Uc_Rectify.flag = 0x00;
 739   4                              AC2_Uc_Rectify.Order = 0x06;
 740   4                              AC2_Uc_Rectify.Length = 0x01;
 741   4                              AC2_Uc_Rectify.reserved = 0x00;
 742   4                              AC2_Uc_Rectify.waitTime = 1000;
 743   4                              AC2_Uc_Rectify.VPaddr = 0x91BB;
 744   4                              AC2_Uc_Rectify.ModbusReg = 0x000B;
 745   4                              AC2_Uc_Rectify.databuff = NULL;
 746   4                              pushToEmergency(&AC2_Uc_Rectify);
 747   4                      }
 748   3                      break;
 749   3      
 750   3                      default:
 751   3                              break;
 752   3                      }
 753   2                      variableChangedIndication.flag = 0;
 754   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 755   2              }
 756   1              {
 757   2                      write_dgus_vp(0x91A2, (uint8_t *)&synthesisCollection.closeBusVolt, 1);
 758   2                      write_dgus_vp(0x91A3, (uint8_t *)&synthesisCollection.controlBusVolt, 1);
 759   2                      write_dgus_vp(0x91A4, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
 760   2                      write_dgus_vp(0x91A5, (uint8_t *)&synthesisCollection.batteryVolt, 1);
 761   2                      write_dgus_vp(0x91A6, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
 762   2                      write_dgus_vp(0x91A7, (uint8_t *)&synthesisCollection.AC_channel_1_Ubc, 1);
 763   2                      write_dgus_vp(0x91A8, (uint8_t *)&synthesisCollection.AC_channel_1_Uca, 1);
 764   2                      write_dgus_vp(0x91A9, (uint8_t *)&synthesisCollection.AC_channel_2_Uab, 1);
 765   2                      write_dgus_vp(0x91AA, (uint8_t *)&synthesisCollection.AC_channel_2_Ubc, 1);
 766   2                      write_dgus_vp(0x91AB, (uint8_t *)&synthesisCollection.AC_channel_2_Uca, 1);
 767   2              }
 768   1      }
 769          
 770          void P33Func()
 771          {
 772   1              static uint8_t timeModifyFlag = 0; // 时间修改标记
 773   1              VariableChangedIndicationTypeDef variableChangedIndication;
 774   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 775   1              if (variableChangedIndication.flag == 0x5A)
 776   1              {
 777   2                      uint16_t variable[5];
 778   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 779   2                      switch (variableChangedIndication.addr)
 780   2                      {
 781   3                      case 0x009D:
 782   3                      case 0x009E:
 783   3                      case 0x009F:
 784   3                              timeModifyFlag = 1;
 785   3                              break;
 786   3      
 787   3                      case 0x80E0:
 788   3                              if (variable[0] == 1)
 789   3                              {
 790   4                                      if (timeModifyFlag == 1) // 由于时间会不断变化，故仅在修改时间的情况下保存时间，避免修改屏保时写入时间
 791   4                                      {
 792   5                                              uint8_t rtcSetData[6];
 793   5                                              read_dgus_vp(0x9D, rtcSetData, 4);
 794   5                                              Write_RTC(rtcSetData);
 795   5                                              timeModifyFlag = 0;
 796   5                                      }
 797   4                                      read_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
 798   4                                      Nor_Flash_write(BACKLIGHT_TIME_NORFLASH_ADDR, (uint8_t *)&backLightTime, 2);
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 14  

 799   4                                      write_dgus_vp(0x83, (uint8_t *)&backLightTime, 1);
 800   4                              }
 801   3                              break;
 802   3      
 803   3                      default:
 804   3                              break;
 805   3                      }
 806   2                      variableChangedIndication.flag = 0;
 807   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 808   2              }
 809   1      }
 810          
 811          void P35Func()
 812          {
 813   1              VariableChangedIndicationTypeDef variableChangedIndication;
 814   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 815   1              if (variableChangedIndication.flag == 0x5A)
 816   1              {
 817   2                      uint16_t variable[5];
 818   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 819   2                      switch (variableChangedIndication.addr)
 820   2                      {
 821   3                      case 0x8100:
 822   3                              if (variable[0] == 1)
 823   3                              {
 824   4                                      read_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
 825   4                                      dgusToNorFlash(SWITCH_MODULE_NORFLASH_ADDR, SWITCH_MODULE_SET_VP, SWITCH_MODULE_SIZE);
 826   4                                      modbusCenerate();
 827   4                              }
 828   3                              break;
 829   3      
 830   3                      default:
 831   3                              break;
 832   3                      }
 833   2                      memset(variable, 0, 5);
 834   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 835   2                      variableChangedIndication.flag = 0;
 836   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 837   2              }
 838   1      }
 839          
 840          void P39Func()
 841          {
 842   1              VariableChangedIndicationTypeDef variableChangedIndication;
 843   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 844   1              if (variableChangedIndication.flag == 0x5A)
 845   1              {
 846   2                      uint16_t variable[5];
 847   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 848   2                      switch (variableChangedIndication.addr)
 849   2                      {
 850   3                      case 0x8120:
 851   3                              if (variable[0] == 1)
 852   3                              {
 853   4                                      read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
 854   4                                      dgusToNorFlash(BATTERY_SET_NORFLASH_ADDR, BATTERY_SET_VP, BATTERY_SET_SIZE);
 855   4                                      modbusCenerate();
 856   4                              }
 857   3                              break;
 858   3                      case 0x9250:
 859   3                              read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet.batteryType, 1);
 860   3                              break;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 15  

 861   3                      case 0x9280:
 862   3                      {
 863   4                              if (batterySet.batteryType == XJ24)
 864   4                              {
 865   5                                      if (0 <= variable[0] && variable[0] <= 5)
 866   5                                      {
 867   6                                              uint16_t batteryModuleNum = variable[0];
 868   6                                              uint16_t cellNum;
 869   6                                              write_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 870   6      
 871   6                                              // 根据巡检数量设置电池节数上限
 872   6                                              read_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 873   6                                              if (cellNum > batteryModuleNum * 24)
 874   6                                              {
 875   7                                                      cellNum = batteryModuleNum * 24;
 876   7                                              }
 877   6                                              write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 878   6                                      }
 879   5                              }
 880   4                              else if (batterySet.batteryType == XJ55)
 881   4                              {
 882   5                                      if (0 <= variable[0] && variable[0] <= 2)
 883   5                                      {
 884   6                                              uint16_t batteryModuleNum = variable[0];
 885   6                                              uint16_t cellNum;
 886   6                                              write_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 887   6      
 888   6                                              // 根据巡检数量设置电池节数上限
 889   6                                              read_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 890   6                                              if (cellNum > batteryModuleNum * 55)
 891   6                                              {
 892   7                                                      cellNum = batteryModuleNum * 55;
 893   7                                              }
 894   6                                              write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 895   6                                      }
 896   5                              }
 897   4                      }
 898   3                      break;
 899   3                      case 0x9281:
 900   3                      {
 901   4                              if (batterySet.batteryType == XJ24)
 902   4                              {
 903   5                                      uint16_t batteryModuleNum;
 904   5                                      uint16_t cellNum = variable[0];
 905   5                                      read_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 906   5                                      if (cellNum > batteryModuleNum * 24)
 907   5                                      {
 908   6                                              cellNum = batteryModuleNum * 24;
 909   6                                      }
 910   5                                      write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 911   5                              }
 912   4                              else if (batterySet.batteryType == XJ55)
 913   4                              {
 914   5                                      uint16_t batteryModuleNum;
 915   5                                      uint16_t cellNum = variable[0];
 916   5                                      read_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 917   5                                      if (cellNum > batteryModuleNum * 55)
 918   5                                      {
 919   6                                              cellNum = batteryModuleNum * 55;
 920   6                                      }
 921   5                                      write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 922   5                              }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 16  

 923   4                      }
 924   3                      break;
 925   3                      case 0x9282:
 926   3                      {
 927   4                              if (batterySet.batteryType == XJ24)
 928   4                              {
 929   5                                      write_dgus_vp(0x9262, (uint8_t *)variable, 1);
 930   5                              }
 931   4                              else if (batterySet.batteryType == XJ55)
 932   4                              {
 933   5                                      write_dgus_vp(0x9272, (uint8_t *)variable, 1);
 934   5                              }
 935   4                      }
 936   3                      break;
 937   3                      case 0x9283:
 938   3                      {
 939   4                              if (batterySet.batteryType == XJ24)
 940   4                              {
 941   5                                      write_dgus_vp(0x9263, (uint8_t *)variable, 1);
 942   5                              }
 943   4                              else if (batterySet.batteryType == XJ55)
 944   4                              {
 945   5                                      write_dgus_vp(0x9273, (uint8_t *)variable, 1);
 946   5                              }
 947   4                      }
 948   3                      break;
 949   3                      case 0x9284:
 950   3                      {
 951   4                              if (batterySet.batteryType == XJ24)
 952   4                              {
 953   5                                      write_dgus_vp(0x9264, (uint8_t *)variable, 1);
 954   5                              }
 955   4                              else if (batterySet.batteryType == XJ55)
 956   4                              {
 957   5                                      write_dgus_vp(0x9274, (uint8_t *)variable, 1);
 958   5                              }
 959   4                      }
 960   3                      break;
 961   3                      case 0x9285:
 962   3                      {
 963   4                              if (batterySet.batteryType == XJ24)
 964   4                              {
 965   5                                      write_dgus_vp(0x9265, (uint8_t *)variable, 1);
 966   5                              }
 967   4                              else if (batterySet.batteryType == XJ55)
 968   4                              {
 969   5                                      write_dgus_vp(0x9275, (uint8_t *)variable, 1);
 970   5                              }
 971   4                      }
 972   3                      break;
 973   3                      case 0x9286:
 974   3                      {
 975   4                              if (batterySet.batteryType == XJ24)
 976   4                              {
 977   5                                      write_dgus_vp(0x9266, (uint8_t *)variable, 1);
 978   5                              }
 979   4                              else if (batterySet.batteryType == XJ55)
 980   4                              {
 981   5                                      write_dgus_vp(0x9276, (uint8_t *)variable, 1);
 982   5                              }
 983   4                      }
 984   3                      break;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 17  

 985   3                      default:
 986   3                              break;
 987   3                      }
 988   2                      // memset(variable, 0, 5);
 989   2                      // write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 990   2                      variableChangedIndication.flag = 0;
 991   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 992   2              }
 993   1              {
 994   2                      if (batterySet.batteryType == XJ24)
 995   2                      {
 996   3                              uint16_t sp; // 描述指针
 997   3                              sp = 0x9260;
 998   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
 999   3                              sp = 0x9261;
1000   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
1001   3                              sp = 0x9262;
1002   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
1003   3                              sp = 0x9263;
1004   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
1005   3                              sp = 0x9264;
1006   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
1007   3                              sp = 0x9265;
1008   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
1009   3                              sp = 0x9266;
1010   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
1011   3                      }
1012   2                      else if (batterySet.batteryType == XJ55)
1013   2                      {
1014   3                              uint16_t sp; // 描述指针
1015   3                              sp = 0x9270;
1016   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
1017   3                              sp = 0x9271;
1018   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
1019   3                              sp = 0x9272;
1020   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
1021   3                              sp = 0x9273;
1022   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
1023   3                              sp = 0x9274;
1024   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
1025   3                              sp = 0x9275;
1026   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
1027   3                              sp = 0x9276;
1028   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
1029   3                      }
1030   2              }
1031   1      }
1032          
1033          void p42Func()
1034          {
1035   1              VariableChangedIndicationTypeDef variableChangedIndication;
1036   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1037   1              if (variableChangedIndication.flag == 0x5A)
1038   1              {
1039   2                      uint16_t variable[5];
1040   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1041   2                      switch (variableChangedIndication.addr)
1042   2                      {
1043   3                      case 0x8140:
1044   3                              if (variable[0] == 1)
1045   3                              {
1046   4                                      read_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 18  

1047   4                                      dgusToNorFlash(INSULATION_SET_NORFLASH_ADDR, INSULATION_SET_VP, INSULATION_SET_SIZE);
1048   4                                      modbusCenerate();
1049   4                              }
1050   3                              break;
1051   3      
1052   3                      default:
1053   3                              break;
1054   3                      }
1055   2                      memset(variable, 0, 5);
1056   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1057   2                      variableChangedIndication.flag = 0;
1058   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1059   2              }
1060   1      }
1061          
1062          void p44Func()
1063          {
1064   1              VariableChangedIndicationTypeDef variableChangedIndication;
1065   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1066   1              if (variableChangedIndication.flag == 0x5A)
1067   1              {
1068   2                      uint16_t variable[5];
1069   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1070   2                      switch (variableChangedIndication.addr)
1071   2                      {
1072   3                      case 0x8160:
1073   3                              if (variable[0] == 1)
1074   3                              {
1075   4                                      read_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
1076   4                                      dgusToNorFlash(CHARGE_MODULE_SET_NORFLASH_ADDR, CHARGE_MODULE_SET_VP, CHARGE_MODULE_SET_SIZE);
1077   4                                      modbusCenerate();
1078   4                              }
1079   3                              break;
1080   3      
1081   3                      default:
1082   3                              break;
1083   3                      }
1084   2                      memset(variable, 0, 5);
1085   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1086   2                      variableChangedIndication.flag = 0;
1087   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1088   2              }
1089   1      }
1090          
1091          void p48Func()
1092          {
1093   1              VariableChangedIndicationTypeDef variableChangedIndication;
1094   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1095   1              if (variableChangedIndication.flag == 0x5A)
1096   1              {
1097   2                      uint16_t variable[5];
1098   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1099   2                      switch (variableChangedIndication.addr)
1100   2                      {
1101   3                      case 0x8180:
1102   3                              if (variable[0] == 1)
1103   3                              {
1104   4                                      read_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
1105   4                                      dgusToNorFlash(DC_CONVERTER_SET_NORFLASH_ADDR, DC_CONVERTER_SET_VP, DC_CONVERTER_SET_SIZE);
1106   4                                      modbusCenerate();
1107   4                              }
1108   3                              break;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 19  

1109   3                      case 0x9360:
1110   3                              if (variable[0] == 1)
1111   3                              {
1112   4                                      if (DC_ConverterSet.Num > 0)
1113   4                                      {
1114   5                                              static MMODBUS DC_moduleOnOffCmd;
1115   5                                              static uint16_t DC_module_DI;
1116   5                                              dc_4850_Module[0].DI.onOffState = !dc_4850_Module[0].DI.onOffState;
1117   5                                              DC_module_DI = dc_4850_Module[0].DI.onOffState;
1118   5                                              DC_moduleOnOffCmd.SlaveAddr = 0xFE;
1119   5                                              DC_moduleOnOffCmd.mode = 0x00;
1120   5                                              DC_moduleOnOffCmd.flag = 0x00;
1121   5                                              DC_moduleOnOffCmd.Order = 0x06;
1122   5                                              DC_moduleOnOffCmd.Length = 1;
1123   5                                              DC_moduleOnOffCmd.reserved = 0x00;
1124   5                                              DC_moduleOnOffCmd.waitTime = 1000;
1125   5                                              DC_moduleOnOffCmd.VPaddr = 0;
1126   5                                              DC_moduleOnOffCmd.ModbusReg = 0x0005;
1127   5                                              DC_moduleOnOffCmd.databuff = &DC_module_DI;
1128   5                                              pushToEmergency(&DC_moduleOnOffCmd);
1129   5                                      }
1130   4                              }
1131   3                              break;
1132   3      
1133   3                      default:
1134   3                              break;
1135   3                      }
1136   2                      memset(variable, 0, 5);
1137   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1138   2                      variableChangedIndication.flag = 0;
1139   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1140   2              }
1141   1              {
1142   2                      uint16_t DC_Module_OnOffState = dc_4850_Module[0].DI.onOffState ? 1 : 0;
1143   2                      write_dgus_vp(0x9361, (uint8_t *)&DC_Module_OnOffState, 1);
1144   2              }
1145   1      }
1146          
1147          void p50Func()
1148          {
1149   1              VariableChangedIndicationTypeDef variableChangedIndication;
1150   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1151   1              if (variableChangedIndication.flag == 0x5A)
1152   1              {
1153   2                      uint16_t variable[5];
1154   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1155   2                      switch (variableChangedIndication.addr)
1156   2                      {
1157   3                      case 0x81A0:
1158   3                              if (variable[0] == 1)
1159   3                              {
1160   4                                      read_dgus_vp(UPS_INV_SET_VP, (uint8_t *)&UPS_INV_Set, UPS_INV_SET_SIZE);
1161   4                                      dgusToNorFlash(UPS_INV_SET_NORFLASH_ADDR, UPS_INV_SET_VP, UPS_INV_SET_SIZE);
1162   4                                      modbusCenerate();
1163   4                              }
1164   3                              break;
1165   3      
1166   3                      default:
1167   3                              break;
1168   3                      }
1169   2                      memset(variable, 0, 5);
1170   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 20  

1171   2                      variableChangedIndication.flag = 0;
1172   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1173   2              }
1174   1      }
1175          
1176          void recovery(void)
1177          {
1178   1              AC_InfoSet.AC_InputChannel = 1;
1179   1              AC_InfoSet.threePhaseAC_VolMax = 4500;
1180   1              AC_InfoSet.threePhaseAC_VolMin = 3230;
1181   1              AC_InfoSet.singlePhaseAC_VolMax = 2800;
1182   1              AC_InfoSet.singlePhaseAC_VolMin = 1870;
1183   1              Nor_Flash_write(AC_INFO_NORFLASH_ADDR, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1184   1              write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1185   1      
1186   1              // DC_InfoSet.busVoltMax_220V = 2600;
1187   1              // DC_InfoSet.busVoltMin_220V = 2000;
1188   1              // DC_InfoSet.moduleVoltMax_220V = 2420;
1189   1              // DC_InfoSet.moduleVoltMin_220V = 2000;
1190   1              // DC_InfoSet.busVoltMax_110V = 1300;
1191   1              // DC_InfoSet.busVoltMin_110V = 1000;
1192   1              // DC_InfoSet.moduleVoltMax_110V = 1200;
1193   1              // DC_InfoSet.moduleVoltMin_110V = 1000;
1194   1              DC_InfoSet.loadHallRatio = 1000;
1195   1              DC_InfoSet.batteryHallRatio = 1000;
1196   1              Nor_Flash_write(DC_INFO_NORFLASH_ADDR, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1197   1              write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1198   1      }
1199          
1200          void p52Func()
1201          {
1202   1              VariableChangedIndicationTypeDef variableChangedIndication;
1203   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1204   1              if (variableChangedIndication.flag == 0x5A)
1205   1              {
1206   2                      uint16_t variable[5];
1207   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1208   2                      switch (variableChangedIndication.addr)
1209   2                      {
1210   3                      case 0x9400:
1211   3                              if (variable[0] == 1)
1212   3                              {
1213   4                                      recovery();
1214   4                              }
1215   3                              break;
1216   3                      case 0x9401:
1217   3                              if (variable[0] == 1)
1218   3                              {
1219   4                                      // 清楚记录
1220   4                              }
1221   3                              break;
1222   3                      case 0x9402:
1223   3                              if (variable[0] == 1)
1224   3                              {
1225   4                                      // 重启触摸屏
1226   4                                      write_dgus_vp(0x04, (uint8_t *)"\x55\xAA\x5A\xA5", 2);
1227   4                              }
1228   3                              break;
1229   3      
1230   3                      default:
1231   3                              break;
1232   3                      }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 21  

1233   2                      memset(variable, 0, 5);
1234   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1235   2                      variableChangedIndication.flag = 0;
1236   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1237   2              }
1238   1      }
1239          
1240          void p68Func(void)
1241          {
1242   1      
1243   1              if (AC_InfoSet.singlePhaseThreePhaseSelection == THREE_PHASE)
1244   1              {
1245   2                      uint16_t sp;
1246   2                      sp = 0x94A0;
1247   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1248   2                      // sp = 0x94A0;
1249   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1250   2                      sp = 0x94A1;
1251   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1252   2                      sp = 0x94A3;
1253   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1254   2                      // sp = 0x94A4;
1255   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1256   2                      sp = 0x94A5;
1257   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
1258   2      
1259   2                      write_dgus_vp(0x94A0, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 6);
1260   2              }
1261   1              else if (AC_InfoSet.singlePhaseThreePhaseSelection == SINGLE_PHASE)
1262   1              {
1263   2                      uint16_t sp;
1264   2                      sp = 0xFFFF;
1265   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1266   2                      // sp = 0x94A0;
1267   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1268   2                      sp = 0xFFFF;
1269   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1270   2                      sp = 0xFFFF;
1271   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1272   2                      // sp = 0x94A4;
1273   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1274   2                      sp = 0xFFFF;
1275   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
1276   2      
1277   2                      write_dgus_vp(0x94A1, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1278   2                      write_dgus_vp(0x94A4, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1279   2              }
1280   1      }
1281          
1282          void p70Func(void)
1283          {
1284   1              {
1285   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1286   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1287   2                      if (variableChangedIndication.flag == 0x5A)
1288   2                      {
1289   3                              uint16_t variable[5];
1290   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1291   3                              switch (variableChangedIndication.addr)
1292   3                              {
1293   4                              case 0x9530:
1294   4                                      if (variable[0] == 1)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 22  

1295   4                                      {
1296   5                                              if (chargeModuleSet.moduleNum >= 1)
1297   5                                              {
1298   6                                                      static MMODBUS chargeModuleOnOff = {0x01, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9540, 0x06, NULL};
1299   6                                                      chargeModule[0].DI.onOffState = !chargeModule[0].DI.onOffState;
1300   6                                                      write_dgus_vp(0x9540, (uint8_t *)&chargeModule[0].DI, 1);
1301   6                                                      pushToEmergency(&chargeModuleOnOff);
1302   6                                              }
1303   5                                      }
1304   4                                      break;
1305   4                              case 0x9531:
1306   4                                      if (variable[0] == 1)
1307   4                                      {
1308   5                                              if (chargeModuleSet.moduleNum >= 2)
1309   5                                              {
1310   6                                                      static MMODBUS chargeModuleOnOff = {0x02, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9541, 0x06, NULL};
1311   6                                                      chargeModule[1].DI.onOffState = !chargeModule[1].DI.onOffState;
1312   6                                                      write_dgus_vp(0x9541, (uint8_t *)&chargeModule[1].DI, 1);
1313   6                                                      pushToEmergency(&chargeModuleOnOff);
1314   6                                              }
1315   5                                      }
1316   4                                      break;
1317   4                              case 0x9532:
1318   4                                      if (variable[0] == 1)
1319   4                                      {
1320   5                                              if (chargeModuleSet.moduleNum >= 3)
1321   5                                              {
1322   6                                                      static MMODBUS chargeModuleOnOff = {0x03, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9542, 0x06, NULL};
1323   6                                                      chargeModule[2].DI.onOffState = !chargeModule[2].DI.onOffState;
1324   6                                                      write_dgus_vp(0x9542, (uint8_t *)&chargeModule[2].DI, 1);
1325   6                                                      pushToEmergency(&chargeModuleOnOff);
1326   6                                              }
1327   5                                      }
1328   4                                      break;
1329   4                              case 0x9533:
1330   4                                      if (variable[0] == 1)
1331   4                                      {
1332   5                                              if (chargeModuleSet.moduleNum >= 4)
1333   5                                              {
1334   6                                                      static MMODBUS chargeModuleOnOff = {0x04, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9543, 0x06, NULL};
1335   6                                                      chargeModule[3].DI.onOffState = !chargeModule[3].DI.onOffState;
1336   6                                                      write_dgus_vp(0x9543, (uint8_t *)&chargeModule[3].DI, 1);
1337   6                                                      pushToEmergency(&chargeModuleOnOff);
1338   6                                              }
1339   5                                      }
1340   4                                      break;
1341   4                              case 0x9534:
1342   4                                      if (variable[0] == 1)
1343   4                                      {
1344   5                                              if (chargeModuleSet.moduleNum >= 5)
1345   5                                              {
1346   6                                                      static MMODBUS chargeModuleOnOff = {0x05, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9544, 0x06, NULL};
1347   6                                                      chargeModule[4].DI.onOffState = !chargeModule[4].DI.onOffState;
1348   6                                                      write_dgus_vp(0x9544, (uint8_t *)&chargeModule[4].DI, 1);
1349   6                                                      pushToEmergency(&chargeModuleOnOff);
1350   6                                              }
1351   5                                      }
1352   4                                      break;
1353   4                              case 0x9535:
1354   4                                      if (variable[0] == 1)
1355   4                                      {
1356   5                                              if (chargeModuleSet.moduleNum >= 6)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 23  

1357   5                                              {
1358   6                                                      static MMODBUS chargeModuleOnOff = {0x06, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9545, 0x06, NULL};
1359   6                                                      chargeModule[5].DI.onOffState = !chargeModule[5].DI.onOffState;
1360   6                                                      write_dgus_vp(0x9545, (uint8_t *)&chargeModule[5].DI, 1);
1361   6                                                      pushToEmergency(&chargeModuleOnOff);
1362   6                                              }
1363   5                                      }
1364   4                                      break;
1365   4                              case 0x9536:
1366   4                                      if (variable[0] == 1)
1367   4                                      {
1368   5                                              if (chargeModuleSet.moduleNum >= 7)
1369   5                                              {
1370   6                                                      static MMODBUS chargeModuleOnOff = {0x07, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9546, 0x06, NULL};
1371   6                                                      chargeModule[6].DI.onOffState = !chargeModule[6].DI.onOffState;
1372   6                                                      write_dgus_vp(0x9546, (uint8_t *)&chargeModule[6].DI, 1);
1373   6                                                      pushToEmergency(&chargeModuleOnOff);
1374   6                                              }
1375   5                                      }
1376   4                                      break;
1377   4                              case 0x9537:
1378   4                                      if (variable[0] == 1)
1379   4                                      {
1380   5                                              if (chargeModuleSet.moduleNum >= 8)
1381   5                                              {
1382   6                                                      static MMODBUS chargeModuleOnOff = {0x08, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9547, 0x06, NULL};
1383   6                                                      chargeModule[7].DI.onOffState = !chargeModule[7].DI.onOffState;
1384   6                                                      write_dgus_vp(0x9547, (uint8_t *)&chargeModule[7].DI, 1);
1385   6                                                      pushToEmergency(&chargeModuleOnOff);
1386   6                                              }
1387   5                                      }
1388   4                                      break;
1389   4      
1390   4                              default:
1391   4                                      break;
1392   4                              }
1393   3                              memset(variable, 0, 5);
1394   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1395   3                              variableChangedIndication.flag = 0;
1396   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1397   3                      }
1398   2              }
1399   1              {
1400   2                      if (chargeModuleSet.moduleNum >= 1)
1401   2                      {
1402   3                              write_dgus_vp(0x9500, (uint8_t *)&chargeModule[0].outputVolt, 3);
1403   3                              write_dgus_vp(0x9503, (uint8_t *)&chargeModule[0].DI, 1);
1404   3                              // {
1405   3                              //      uint16_t temp = chargeModule.onOffState;
1406   3                              //      write_dgus_vp(0x9503, (uint8_t *)&temp, 1);
1407   3                              // }
1408   3                              {
1409   4                                      uint16_t temp = 0;
1410   4                                      write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1411   4                              }
1412   3                      }
1413   2                      else
1414   2                      {
1415   3                              uint16_t temp = 1;
1416   3                              write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1417   3                      }
1418   2                      if (chargeModuleSet.moduleNum >= 2)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 24  

1419   2                      {
1420   3                              write_dgus_vp(0x9504, (uint8_t *)&chargeModule[1].outputVolt, 3);
1421   3                              write_dgus_vp(0x9507, (uint8_t *)&chargeModule[1].DI, 1);
1422   3                              // {
1423   3                              //      uint16_t temp = chargeModule[1].DI.onOffState;
1424   3                              //      write_dgus_vp(0x9507, (uint8_t *)&temp, 1);
1425   3                              // }
1426   3                              {
1427   4                                      uint16_t temp = 0;
1428   4                                      write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
1429   4                              }
1430   3                      }
1431   2                      else
1432   2                      {
1433   3                              uint16_t temp = 1;
1434   3                              write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
1435   3                      }
1436   2                      if (chargeModuleSet.moduleNum >= 3)
1437   2                      {
1438   3                              write_dgus_vp(0x9508, (uint8_t *)&chargeModule[2].outputVolt, 3);
1439   3                              write_dgus_vp(0x950B, (uint8_t *)&chargeModule[2].DI, 1);
1440   3                              // {
1441   3                              //      uint16_t temp = chargeModule[2].DI.onOffState;
1442   3                              //      write_dgus_vp(0x950B, (uint8_t *)&temp, 1);
1443   3                              // }
1444   3                              {
1445   4                                      uint16_t temp = 0;
1446   4                                      write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1447   4                              }
1448   3                      }
1449   2                      else
1450   2                      {
1451   3                              uint16_t temp = 1;
1452   3                              write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1453   3                      }
1454   2                      if (chargeModuleSet.moduleNum >= 4)
1455   2                      {
1456   3                              write_dgus_vp(0x950C, (uint8_t *)&chargeModule[3].outputVolt, 3);
1457   3                              write_dgus_vp(0x950F, (uint8_t *)&chargeModule[3].DI, 1);
1458   3                              // {
1459   3                              //      uint16_t temp = chargeModule[3].DI.onOffState;
1460   3                              //      write_dgus_vp(0x950F, (uint8_t *)&temp, 1);
1461   3                              // }
1462   3                              {
1463   4                                      uint16_t temp = 0;
1464   4                                      write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1465   4                              }
1466   3                      }
1467   2                      else
1468   2                      {
1469   3                              uint16_t temp = 1;
1470   3                              write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1471   3                      }
1472   2                      if (chargeModuleSet.moduleNum >= 5)
1473   2                      {
1474   3                              write_dgus_vp(0x9510, (uint8_t *)&chargeModule[4].outputVolt, 3);
1475   3                              write_dgus_vp(0x9513, (uint8_t *)&chargeModule[4].DI, 1);
1476   3                              // {
1477   3                              //      uint16_t temp = chargeModule[4].DI.onOffState;
1478   3                              //      write_dgus_vp(0x9513, (uint8_t *)&temp, 1);
1479   3                              // }
1480   3                              {
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 25  

1481   4                                      uint16_t temp = 0;
1482   4                                      write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1483   4                              }
1484   3                      }
1485   2                      else
1486   2                      {
1487   3                              uint16_t temp = 1;
1488   3                              write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1489   3                      }
1490   2                      if (chargeModuleSet.moduleNum >= 6)
1491   2                      {
1492   3                              write_dgus_vp(0x9514, (uint8_t *)&chargeModule[5].outputVolt, 3);
1493   3                              write_dgus_vp(0x9517, (uint8_t *)&chargeModule[5].DI, 1);
1494   3                              // {
1495   3                              //      uint16_t temp = chargeModule[5].DI.onOffState;
1496   3                              //      write_dgus_vp(0x9517, (uint8_t *)&temp, 1);
1497   3                              // }
1498   3                              {
1499   4                                      uint16_t temp = 0;
1500   4                                      write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1501   4                              }
1502   3                      }
1503   2                      else
1504   2                      {
1505   3                              uint16_t temp = 1;
1506   3                              write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1507   3                      }
1508   2                      if (chargeModuleSet.moduleNum >= 7)
1509   2                      {
1510   3                              write_dgus_vp(0x9518, (uint8_t *)&chargeModule[6].outputVolt, 3);
1511   3                              write_dgus_vp(0x951B, (uint8_t *)&chargeModule[6].DI, 1);
1512   3                              // {
1513   3                              //      uint16_t temp = chargeModule[6].DI.onOffState;
1514   3                              //      write_dgus_vp(0x951B, (uint8_t *)&temp, 1);
1515   3                              // }
1516   3                              {
1517   4                                      uint16_t temp = 0;
1518   4                                      write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1519   4                              }
1520   3                      }
1521   2                      else
1522   2                      {
1523   3                              uint16_t temp = 1;
1524   3                              write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1525   3                      }
1526   2                      if (chargeModuleSet.moduleNum >= 8)
1527   2                      {
1528   3                              write_dgus_vp(0x951C, (uint8_t *)&chargeModule[7].outputVolt, 3);
1529   3                              write_dgus_vp(0x951F, (uint8_t *)&chargeModule[7].DI, 1);
1530   3                              // {
1531   3                              //      uint16_t temp = chargeModule[7].DI.onOffState;
1532   3                              //      write_dgus_vp(0x951F, (uint8_t *)&temp, 1);
1533   3                              // }
1534   3                              {
1535   4                                      uint16_t temp = 0;
1536   4                                      write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
1537   4                              }
1538   3                      }
1539   2                      else
1540   2                      {
1541   3                              uint16_t temp = 1;
1542   3                              write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 26  

1543   3                      }
1544   2              }
1545   1      }
1546          
1547          void p72Func(void)
1548          {
1549   1              uint16_t swState;
1550   1              uint16_t i;
1551   1              for (i = 0; i < switchModuleSet.synthesisCollection.alarmChannelNum; i++)
1552   1              {
1553   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1554   2                      {
1555   3                              swState = NORMAL;
1556   3                      }
1557   2                      else
1558   2                      {
1559   3                              swState = FAULT;
1560   3                      }
1561   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1562   2              }
1563   1              for (; i < 12; i++)
1564   1              {
1565   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1566   2                      {
1567   3                              swState = CLOSING;
1568   3                      }
1569   2                      else
1570   2                      {
1571   3                              swState = OPENING;
1572   3                      }
1573   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1574   2              }
1575   1              for (; i < 13; i++)
1576   1              {
1577   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1578   2                      {
1579   3                              swState = NORMAL;
1580   3                      }
1581   2                      else
1582   2                      {
1583   3                              swState = FAULT;
1584   3                      }
1585   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1586   2              }
1587   1              for (; i < 15; i++)
1588   1              {
1589   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1590   2                      {
1591   3                              swState = CLOSING;
1592   3                      }
1593   2                      else
1594   2                      {
1595   3                              swState = OPENING;
1596   3                      }
1597   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1598   2              }
1599   1      }
1600          
1601          void p75Func(void)
1602          {
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 27  

1603   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1604   1              {
1605   2                      uint16_t i;
1606   2                      for (i = 0; i < 16; i++)
1607   2                      {
1608   3                              uint16_t swState;
1609   3                              swState = (remoteControlModule_ARD[0].sw1to16 >> i) & 0x01;
1610   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1611   3                      }
1612   2              }
1613   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1614   1              {
1615   2                      uint16_t i;
1616   2                      for (i = 0; i < 16; i++)
1617   2                      {
1618   3                              uint16_t swState;
1619   3                              swState = (remoteControlModule_TH[0].sw1to16 >> i) & 0x01;
1620   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1621   3                      }
1622   2              }
1623   1              {
1624   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1625   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1626   2                      if (variableChangedIndication.flag == 0x5A)
1627   2                      {
1628   3                              uint16_t variable[5];
1629   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1630   3                              switch (variableChangedIndication.addr)
1631   3                              {
1632   4                              case 0x9760:
1633   4                              case 0x9761:
1634   4                              case 0x9762:
1635   4                              case 0x9763:
1636   4                              case 0x9764:
1637   4                              case 0x9765:
1638   4                              case 0x9766:
1639   4                              case 0x9767:
1640   4                              case 0x9768:
1641   4                              case 0x9769:
1642   4                              case 0x976A:
1643   4                              case 0x976B:
1644   4                              case 0x976C:
1645   4                              case 0x976D:
1646   4                              case 0x976E:
1647   4                              case 0x976F:
1648   4                              {
1649   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1650   5                                      {
1651   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
1652   6                                              if (variable[0] == 0)
1653   6                                              {
1654   7                                                      static MMODBUS rtuSwOff[16];
1655   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1656   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
1657   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1658   7                                                      rtuSwOff[offset].mode = 0x00;
1659   7                                                      rtuSwOff[offset].flag = 0x00;
1660   7                                                      rtuSwOff[offset].Order = 0x06;
1661   7                                                      rtuSwOff[offset].Length = 0x01;
1662   7                                                      rtuSwOff[offset].reserved = 0x00;
1663   7                                                      rtuSwOff[offset].waitTime = 1000;
1664   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 28  

1665   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
1666   7                                                      rtuSwOff[offset].databuff = NULL;
1667   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1668   7                                                      pushToEmergency(rtuSwOff + offset);
1669   7                                              }
1670   6                                              else if (variable[0] == 1)
1671   6                                              {
1672   7                                                      static MMODBUS rtuSwOn[16];
1673   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1674   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
1675   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1676   7                                                      rtuSwOn[offset].mode = 0x00;
1677   7                                                      rtuSwOn[offset].flag = 0x00;
1678   7                                                      rtuSwOn[offset].Order = 0x06;
1679   7                                                      rtuSwOn[offset].Length = 0x01;
1680   7                                                      rtuSwOn[offset].reserved = 0x00;
1681   7                                                      rtuSwOn[offset].waitTime = 1000;
1682   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1683   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
1684   7                                                      rtuSwOn[offset].databuff = NULL;
1685   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1686   7                                                      pushToEmergency(rtuSwOn + offset);
1687   7                                              }
1688   6                                      }
1689   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1690   5                                      {
1691   6                                              if (variable[0] == 0)
1692   6                                              {
1693   7                                                      static MMODBUS rtuSwOff[16];
1694   7                                                      uint16_t OffVal = 0x0000;
1695   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1696   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1697   7                                                      rtuSwOff[offset].mode = 0x00;
1698   7                                                      rtuSwOff[offset].flag = 0x00;
1699   7                                                      rtuSwOff[offset].Order = 0x06;
1700   7                                                      rtuSwOff[offset].Length = 0x01;
1701   7                                                      rtuSwOff[offset].reserved = 0x00;
1702   7                                                      rtuSwOff[offset].waitTime = 1000;
1703   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
1704   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
1705   7                                                      rtuSwOff[offset].databuff = NULL;
1706   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OffVal, 1);
1707   7                                                      pushToEmergency(rtuSwOff + offset);
1708   7                                              }
1709   6                                              else if (variable[0] == 1)
1710   6                                              {
1711   7                                                      static MMODBUS rtuSwOn[16];
1712   7                                                      uint16_t OnVal = 0xFFFF;
1713   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1714   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1715   7                                                      rtuSwOn[offset].mode = 0x00;
1716   7                                                      rtuSwOn[offset].flag = 0x00;
1717   7                                                      rtuSwOn[offset].Order = 0x06;
1718   7                                                      rtuSwOn[offset].Length = 0x01;
1719   7                                                      rtuSwOn[offset].reserved = 0x00;
1720   7                                                      rtuSwOn[offset].waitTime = 1000;
1721   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1722   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
1723   7                                                      rtuSwOn[offset].databuff = NULL;
1724   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OnVal, 1);
1725   7                                                      pushToEmergency(rtuSwOn + offset);
1726   7                                              }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 29  

1727   6                                      }
1728   5                              }
1729   4                              break;
1730   4      
1731   4                              default:
1732   4                                      break;
1733   4                              }
1734   3                              memset(variable, 0, 5);
1735   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1736   3                              variableChangedIndication.flag = 0;
1737   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1738   3                      }
1739   2              }
1740   1      }
1741          
1742          void p76Func(void)
1743          {
1744   1              uint16_t swState;
1745   1              uint16_t i;
1746   1              for (i = 0; i < 30; i++)
1747   1              {
1748   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[0])
1749   2                      {
1750   3                              if ((switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[0]
             -)
1751   3                              {
1752   4                                      swState = NORMAL;
1753   4                              }
1754   3                              else
1755   3                              {
1756   4                                      swState = FAULT;
1757   4                              }
1758   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1759   3                      }
1760   2                      else
1761   2                      {
1762   3                              if (switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001)
1763   3                              {
1764   4                                      swState = CLOSING;
1765   4                              }
1766   3                              else
1767   3                              {
1768   4                                      swState = OPENING;
1769   4                              }
1770   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1771   3                      }
1772   2              }
1773   1      }
1774          void p77Func(void)
1775          {
1776   1              uint16_t swState;
1777   1              uint16_t i;
1778   1              for (i = 0; i < 30; i++)
1779   1              {
1780   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[1])
1781   2                      {
1782   3                              if ((switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[1]
             -)
1783   3                              {
1784   4                                      swState = NORMAL;
1785   4                              }
1786   3                              else
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 30  

1787   3                              {
1788   4                                      swState = FAULT;
1789   4                              }
1790   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1791   3                      }
1792   2                      else
1793   2                      {
1794   3                              if (switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001)
1795   3                              {
1796   4                                      swState = CLOSING;
1797   4                              }
1798   3                              else
1799   3                              {
1800   4                                      swState = OPENING;
1801   4                              }
1802   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1803   3                      }
1804   2              }
1805   1      }
1806          void p78Func(void)
1807          {
1808   1              uint16_t swState;
1809   1              uint16_t i;
1810   1              for (i = 0; i < 30; i++)
1811   1              {
1812   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[2])
1813   2                      {
1814   3                              if ((switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[2]
             -)
1815   3                              {
1816   4                                      swState = NORMAL;
1817   4                              }
1818   3                              else
1819   3                              {
1820   4                                      swState = FAULT;
1821   4                              }
1822   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1823   3                      }
1824   2                      else
1825   2                      {
1826   3                              if (switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001)
1827   3                              {
1828   4                                      swState = CLOSING;
1829   4                              }
1830   3                              else
1831   3                              {
1832   4                                      swState = OPENING;
1833   4                              }
1834   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1835   3                      }
1836   2              }
1837   1      }
1838          void p79Func(void)
1839          {
1840   1              uint16_t swState;
1841   1              uint16_t i;
1842   1              for (i = 0; i < 30; i++)
1843   1              {
1844   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[3])
1845   2                      {
1846   3                              if ((switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[3]
             -)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 31  

1847   3                              {
1848   4                                      swState = NORMAL;
1849   4                              }
1850   3                              else
1851   3                              {
1852   4                                      swState = FAULT;
1853   4                              }
1854   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
1855   3                      }
1856   2                      else
1857   2                      {
1858   3                              if (switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001)
1859   3                              {
1860   4                                      swState = CLOSING;
1861   4                              }
1862   3                              else
1863   3                              {
1864   4                                      swState = OPENING;
1865   4                              }
1866   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
1867   3                      }
1868   2              }
1869   1      }
1870          
1871          void p80Func(void)
1872          {
1873   1              write_dgus_vp(0x9800, (uint8_t *)&synthesisCollection.closeBusVolt, 1);
1874   1      
1875   1              write_dgus_vp(0x9801, (uint8_t *)&synthesisCollection.controlBusVolt, 1);
1876   1      
1877   1              write_dgus_vp(0x9802, (uint8_t *)&synthesisCollection.controlBusCurr, 1);
1878   1      
1879   1              write_dgus_vp(0x9803, (uint8_t *)&synthesisCollection.batteryVolt, 1);
1880   1      
1881   1              write_dgus_vp(0x9804, (uint8_t *)&synthesisCollection.batteryCurr, 1);
1882   1      }
1883          
1884          void p82Func(void)
1885          {
1886   1              if (UPS_INV_Set.UPS_Num >= 1)
1887   1              {
1888   2                      write_dgus_vp(0x9850, (uint8_t *)&ups[0].remoteMeasurement, 11);
1889   2                      write_dgus_vp(0x985B, (uint8_t *)&ups[0].remoteSignal, 1);
1890   2              }
1891   1              if (UPS_INV_Set.UPS_Num >= 2)
1892   1              {
1893   2                      write_dgus_vp(0x9860, (uint8_t *)&ups[1].remoteMeasurement, 11);
1894   2                      write_dgus_vp(0x986B, (uint8_t *)&ups[1].remoteSignal, 1);
1895   2              }
1896   1              {
1897   2                      uint16_t ups2Hide;
1898   2                      ups2Hide = (UPS_INV_Set.UPS_Num < 2) ? 1 : 0;
1899   2                      write_dgus_vp(0x9880, (uint8_t *)&ups2Hide, 1);
1900   2              }
1901   1      }
1902          
1903          void p85Func(void)
1904          {
1905   1              if (UPS_INV_Set.INV_Num >= 1)
1906   1              {
1907   2                      write_dgus_vp(0x98A0, (uint8_t *)&inv[0], 21);
1908   2              }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 32  

1909   1              if (UPS_INV_Set.INV_Num >= 2)
1910   1              {
1911   2                      write_dgus_vp(0x98C0, (uint8_t *)&inv[1], 21);
1912   2              }
1913   1              {
1914   2                      uint16_t inv2Hide;
1915   2                      inv2Hide = (UPS_INV_Set.INV_Num < 2) ? 1 : 0;
1916   2                      write_dgus_vp(0x98E0, (uint8_t *)&inv2Hide, 1);
1917   2              }
1918   1      }
1919          
1920          void p86Func(void)
1921          {
1922   1              uint16_t i;
1923   1              for (i = 0; i < DC_ConverterSet.Num; i++)
1924   1              {
1925   2                      uint16_t faultSta;
1926   2                      uint16_t protectSta;
1927   2                      write_dgus_vp(0x9900 + i, (uint8_t *)&dc_4850_Module[i].outputVolt, 1);
1928   2                      write_dgus_vp(0x9910 + i, (uint8_t *)&dc_4850_Module[i].outputCurr, 1);
1929   2                      faultSta = dc_4850_Module[i].DI.faultState;
1930   2                      write_dgus_vp(0x9920 + i, (uint8_t *)&faultSta, 1);
1931   2                      protectSta = dc_4850_Module[i].DI.protectState;
1932   2                      write_dgus_vp(0x9930 + i, (uint8_t *)&protectSta, 1);
1933   2              }
1934   1              for (i = 0; i < DC4850MODULE_MAX; i++)
1935   1              {
1936   2                      uint16_t DC_hide;
1937   2                      DC_hide = (i >= DC_ConverterSet.Num) ? 1 : 0;
1938   2                      write_dgus_vp(0x9940 + i, (uint8_t *)&DC_hide, 1);
1939   2              }
1940   1      }
1941          
1942          void p87Func(void)
1943          {
1944   1              uint16_t i;
1945   1              for (i = 0; i < 30; i++)
1946   1              {
1947   2                      int16_t insulationRes;
1948   2                      insulationRes = branchInsulation[0].res[i];
1949   2                      insulationRes += i < insulationSet.DC.closeBus_1_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
1950   2                      write_dgus_vp(0x9950 + i, (uint8_t *)&insulationRes, 1);
1951   2              }
1952   1      
1953   1              if (sysInfoSet.siliconChain == 1)
1954   1              {
1955   2                      int16_t temp;
1956   2                      temp = branchInsulation[0].closeBusToGroundVolt - branchInsulation[0].busToGroundVolt;
1957   2                      write_dgus_vp(0x9970, (uint8_t *)&temp, 1);
1958   2      
1959   2                      temp = branchInsulation[0].controlBusToGroundVolt - branchInsulation[0].busToGroundVolt;
1960   2                      write_dgus_vp(0x9971, (uint8_t *)&temp, 1);
1961   2              }
1962   1              else if (sysInfoSet.siliconChain == 0)
1963   1              {
1964   2                      int32_t batteryVoltSum;   // 电池巡检电压总和
1965   2                      int32_t chargeModuleVolt; // 充电模块电压
1966   2                      int16_t displayVolt;
1967   2                      uint16_t i;
1968   2      
1969   2                      // if (batterySet.batteryType == XJ24)
1970   2                      // {
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 33  

1971   2                      //      batteryVoltSum = 0;
1972   2                      //      for (i = 0; i < batterySet.xj24.cellNum; i++)
1973   2                      //      {
1974   2                      //              batteryVoltSum += battery_xj24[i / 24].volt[i % 24];
1975   2                      //      }
1976   2                      // }
1977   2                      // else if (batterySet.batteryType == XJ55)
1978   2                      // {
1979   2                      //      batteryVoltSum = 0;
1980   2                      //      for (i = 0; i < batterySet.xj55.cellNum; i++)
1981   2                      //      {
1982   2                      //              batteryVoltSum += battery_xj55[i / 55].volt[i % 55];
1983   2                      //      }
1984   2                      // }
1985   2                      read_dgus_vp(0xb020, (uint8_t *)&batteryVoltSum, 1);
1986   2      
1987   2                      chargeModuleVolt = 0;
1988   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
1989   2                      {
1990   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
1991   3                              {
1992   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
1993   4                              }
1994   3                      }
1995   2      
1996   2                      displayVolt = MAX(batteryVoltSum, chargeModuleVolt) - branchInsulation[0].controlBusToGroundVolt;
1997   2                      write_dgus_vp(0x9970, (uint8_t *)&displayVolt, 1);
1998   2                      write_dgus_vp(0x9971, (uint8_t *)&displayVolt, 1);
1999   2              }
2000   1              write_dgus_vp(0x9972, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
2001   1      }
2002          
2003          void p88Func(void)
2004          {
2005   1              uint16_t i;
2006   1              for (i = 0; i < 30; i++)
2007   1              {
2008   2                      uint16_t insulationRes;
2009   2                      insulationRes = branchInsulation[1].res[i];
2010   2                      insulationRes += i < insulationSet.DC.closeBus_2_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
2011   2                      write_dgus_vp(0x99A0 + i, (uint8_t *)&insulationRes, 1);
2012   2              }
2013   1      
2014   1              if (sysInfoSet.siliconChain == 1)
2015   1              {
2016   2                      int16_t temp;
2017   2                      temp = branchInsulation[0].closeBusToGroundVolt - branchInsulation[0].closeBusToGroundVolt;
2018   2                      write_dgus_vp(0x9970, (uint8_t *)&temp, 1);
2019   2      
2020   2                      temp = branchInsulation[0].controlBusToGroundVolt - branchInsulation[0].controlBusToGroundVolt;
2021   2                      write_dgus_vp(0x9971, (uint8_t *)&temp, 1);
2022   2              }
2023   1              else if (sysInfoSet.siliconChain == 0)
2024   1              {
2025   2                      int16_t batteryVoltSum;   // 电池巡检电压总和
2026   2                      int16_t chargeModuleVolt; // 充电模块电压
2027   2                      int16_t displayVolt;
2028   2                      uint16_t i;
2029   2                      // if (batterySet.batteryType == XJ24)
2030   2                      // {
2031   2                      //      batteryVoltSum = 0;
2032   2                      //      for (i = 0; i < batterySet.xj24.cellNum; i++)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 34  

2033   2                      //      {
2034   2                      //              batteryVoltSum += battery_xj24[i / 24].volt[i % 24];
2035   2                      //      }
2036   2                      // }
2037   2                      // else if (batterySet.batteryType == XJ55)
2038   2                      // {
2039   2                      //      batteryVoltSum = 0;
2040   2                      //      for (i = 0; i < batterySet.xj55.cellNum; i++)
2041   2                      //      {
2042   2                      //              batteryVoltSum += battery_xj55[i / 55].volt[i % 55];
2043   2                      //      }
2044   2                      // }
2045   2                      read_dgus_vp(0xb020, (uint8_t *)&batteryVoltSum, 1);
2046   2      
2047   2                      chargeModuleVolt = 0;
2048   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
2049   2                      {
2050   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
2051   3                              {
2052   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
2053   4                              }
2054   3                      }
2055   2      
2056   2                      displayVolt = MAX(batteryVoltSum, chargeModuleVolt) - branchInsulation[0].controlBusToGroundVolt;
2057   2                      write_dgus_vp(0x9970, (uint8_t *)&displayVolt, 1);
2058   2                      write_dgus_vp(0x9971, (uint8_t *)&displayVolt, 1);
2059   2              }
2060   1              write_dgus_vp(0x9972, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
2061   1      }
2062          
2063          void p94Func(void)
2064          {
2065   1              uint16_t i;
2066   1              if (batterySet.batteryType == XJ24)
2067   1              {
2068   2                      for (i = 0; i < 60; i++)
2069   2                      {
2070   3                              if (i < batterySet.xj24.cellNum)
2071   3                              {
2072   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
2073   4                              }
2074   3                              else
2075   3                              {
2076   4                                      uint16_t temp = 0;
2077   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
2078   4                              }
2079   3                      }
2080   2              }
2081   1              else if (batterySet.batteryType == XJ55)
2082   1              {
2083   2                      for (i = 0; i < 60; i++)
2084   2                      {
2085   3                              if (i < batterySet.xj24.cellNum)
2086   3                              {
2087   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
2088   4                              }
2089   3                              else
2090   3                              {
2091   4                                      uint16_t temp = 0;
2092   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
2093   4                              }
2094   3                      }
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 35  

2095   2              }
2096   1      }
2097          
2098          void p113Func(void)
2099          {
2100   1              uint16_t i;
2101   1              if (batterySet.batteryType == XJ24)
2102   1              {
2103   2                      for (i = 60; i < 120; i++)
2104   2                      {
2105   3                              if (i < batterySet.xj24.cellNum)
2106   3                              {
2107   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
2108   4                              }
2109   3                              else
2110   3                              {
2111   4                                      uint16_t temp = 0;
2112   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
2113   4                              }
2114   3                      }
2115   2              }
2116   1              else if (batterySet.batteryType == XJ55)
2117   1              {
2118   2                      for (i = 60; i < 120; i++)
2119   2                      {
2120   3                              if (i < batterySet.xj24.cellNum)
2121   3                              {
2122   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
2123   4                              }
2124   3                              else
2125   3                              {
2126   4                                      uint16_t temp = 0;
2127   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
2128   4                              }
2129   3                      }
2130   2              }
2131   1      }
2132          
2133          void p114Func()
2134          {
2135   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
2136   1              {
2137   2                      uint16_t i;
2138   2                      for (i = 0; i < 16; i++)
2139   2                      {
2140   3                              uint16_t swState;
2141   3                              swState = (remoteControlModule_ARD[1].sw1to16 >> i) & 0x01;
2142   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
2143   3                      }
2144   2              }
2145   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
2146   1              {
2147   2                      uint16_t i;
2148   2                      for (i = 0; i < 16; i++)
2149   2                      {
2150   3                              uint16_t swState;
2151   3                              swState = (remoteControlModule_TH[1].sw1to16 >> i) & 0x01;
2152   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
2153   3                      }
2154   2              }
2155   1              {
2156   2                      VariableChangedIndicationTypeDef variableChangedIndication;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 36  

2157   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
2158   2                      if (variableChangedIndication.flag == 0x5A)
2159   2                      {
2160   3                              uint16_t variable[5];
2161   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
2162   3                              switch (variableChangedIndication.addr)
2163   3                              {
2164   4                              case 0x97B0:
2165   4                              case 0x97B1:
2166   4                              case 0x97B2:
2167   4                              case 0x97B3:
2168   4                              case 0x97B4:
2169   4                              case 0x97B5:
2170   4                              case 0x97B6:
2171   4                              case 0x97B7:
2172   4                              case 0x97B8:
2173   4                              case 0x97B9:
2174   4                              case 0x97BA:
2175   4                              case 0x97BB:
2176   4                              case 0x97BC:
2177   4                              case 0x97BD:
2178   4                              case 0x97BE:
2179   4                              case 0x97BF:
2180   4                              {
2181   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
2182   5                                      {
2183   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
2184   6                                              if (variable[0] == 0)
2185   6                                              {
2186   7                                                      static MMODBUS rtuSwOff[16];
2187   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2188   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
2189   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2190   7                                                      rtuSwOff[offset].mode = 0x00;
2191   7                                                      rtuSwOff[offset].flag = 0x00;
2192   7                                                      rtuSwOff[offset].Order = 0x06;
2193   7                                                      rtuSwOff[offset].Length = 0x01;
2194   7                                                      rtuSwOff[offset].reserved = 0x00;
2195   7                                                      rtuSwOff[offset].waitTime = 1000;
2196   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2197   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
2198   7                                                      rtuSwOff[offset].databuff = NULL;
2199   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2200   7                                                      pushToEmergency(rtuSwOff + offset);
2201   7                                              }
2202   6                                              else if (variable[0] == 1)
2203   6                                              {
2204   7                                                      static MMODBUS rtuSwOn[16];
2205   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2206   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
2207   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2208   7                                                      rtuSwOn[offset].mode = 0x00;
2209   7                                                      rtuSwOn[offset].flag = 0x00;
2210   7                                                      rtuSwOn[offset].Order = 0x06;
2211   7                                                      rtuSwOn[offset].Length = 0x01;
2212   7                                                      rtuSwOn[offset].reserved = 0x00;
2213   7                                                      rtuSwOn[offset].waitTime = 1000;
2214   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2215   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
2216   7                                                      rtuSwOn[offset].databuff = NULL;
2217   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2218   7                                                      pushToEmergency(rtuSwOn + offset);
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 37  

2219   7                                              }
2220   6                                      }
2221   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
2222   5                                      {
2223   6                                              if (variable[0] == 0)
2224   6                                              {
2225   7                                                      static MMODBUS rtuSwOff[16];
2226   7                                                      uint16_t OffVal = 0x0000;
2227   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2228   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2229   7                                                      rtuSwOff[offset].mode = 0x00;
2230   7                                                      rtuSwOff[offset].flag = 0x00;
2231   7                                                      rtuSwOff[offset].Order = 0x06;
2232   7                                                      rtuSwOff[offset].Length = 0x01;
2233   7                                                      rtuSwOff[offset].reserved = 0x00;
2234   7                                                      rtuSwOff[offset].waitTime = 1000;
2235   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2236   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
2237   7                                                      rtuSwOff[offset].databuff = NULL;
2238   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OffVal, 1);
2239   7                                                      pushToEmergency(rtuSwOff + offset);
2240   7                                              }
2241   6                                              else if (variable[0] == 1)
2242   6                                              {
2243   7                                                      static MMODBUS rtuSwOn[16];
2244   7                                                      uint16_t OnVal = 0xFFFF;
2245   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2246   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2247   7                                                      rtuSwOn[offset].mode = 0x00;
2248   7                                                      rtuSwOn[offset].flag = 0x00;
2249   7                                                      rtuSwOn[offset].Order = 0x06;
2250   7                                                      rtuSwOn[offset].Length = 0x01;
2251   7                                                      rtuSwOn[offset].reserved = 0x00;
2252   7                                                      rtuSwOn[offset].waitTime = 1000;
2253   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2254   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
2255   7                                                      rtuSwOn[offset].databuff = NULL;
2256   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OnVal, 1);
2257   7                                                      pushToEmergency(rtuSwOn + offset);
2258   7                                              }
2259   6                                      }
2260   5                              }
2261   4                              break;
2262   4      
2263   4                              default:
2264   4                                      break;
2265   4                              }
2266   3                              memset(variable, 0, 5);
2267   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
2268   3                              variableChangedIndication.flag = 0;
2269   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
2270   3                      }
2271   2              }
2272   1      }
2273          
2274          code void (*PagePointer[])(void) = {
2275                  P0Func,
2276                  NULL,
2277                  P2Func,
2278                  NULL,
2279                  NULL,
2280                  NULL,
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 38  

2281                  NULL,
2282                  NULL,
2283                  NULL,
2284                  NULL,
2285                  NULL,
2286                  P11Func,
2287                  P12Func,
2288                  NULL,                             // 13
2289                  NULL,                             // 14
2290                  NULL,                             // 15
2291                  NULL,                             // 16
2292                  NULL,                             // 17
2293                  P18Func,                          // 18
2294                  NULL,                             // 19
2295                  NULL,                             // 20
2296                  NULL,                             // 21
2297                  P22Func,                          // 22
2298                  NULL,                             // 23
2299                  NULL,                             // 24
2300                  NULL,                             // 25
2301                  P26Func,                          // 26
2302                  NULL,                             // 27
2303                  NULL,                             // 28
2304                  P29Func,                          // 29
2305                  NULL,                             // 30
2306                  NULL,                             // 31
2307                  NULL,                             // 32
2308                  P33Func,                          // 33
2309                  NULL,                             // 34
2310                  P35Func,                          // 35
2311                  NULL,                             // 36
2312                  NULL,                             // 37
2313                  NULL,                             // 38
2314                  P39Func,                          // 39
2315                  NULL,                             // 40
2316                  NULL,                             // 41
2317                  p42Func,                          // 42
2318                  NULL,                             // 43
2319                  p44Func,                          // 44
2320                  NULL,                             // 45
2321                  NULL,                             // 46
2322                  NULL,                             // 47
2323                  p48Func,                          // 48
2324                  NULL,                             // 49
2325                  p50Func,                          // 50
2326                  NULL,                             // 51
2327                  p52Func,                          // 52
2328                  NULL,                             // 53
2329                  NULL,                             // 54
2330                  NULL,                             // 55
2331                  NULL,                             // 56
2332                  NULL,                             // 57
2333                  NULL,                             // 58
2334                  realTimeAlarmDisplay, // 59
2335                  NULL,                             // 60
2336                  historyAlarmDisplay,  // 61
2337                  NULL,                             // 62
2338                  NULL,                             // 63
2339                  NULL,                             // 64
2340                  NULL,                             // 65
2341                  NULL,                             // 66
2342                  NULL,                             // 67
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 39  

2343                  p68Func,                          // 68
2344                  NULL,                             // 69
2345                  p70Func,                          // 70
2346                  NULL,                             // 71
2347                  p72Func,                          // 72
2348                  NULL,                             // 73
2349                  NULL,                             // 74
2350                  p75Func,                          // 75
2351                  p76Func,                          // 76
2352                  p77Func,                          // 77
2353                  p78Func,                          // 78
2354                  p79Func,                          // 79
2355                  p80Func,                          // 80
2356                  NULL,                             // 81
2357                  p82Func,                          // 82
2358                  NULL,                             // 83
2359                  NULL,                             // 84
2360                  p85Func,                          // 85
2361                  p86Func,                          // 86
2362                  p87Func,                          // 87
2363                  p88Func,                          // 88
2364                  NULL,                             // 89
2365                  NULL,                             // 90
2366                  NULL,                             // 91
2367                  NULL,                             // 92
2368                  NULL,                             // 93
2369                  p94Func,                          // 94
2370                  NULL,                             // 95
2371                  NULL,                             // 96
2372                  NULL,                             // 97
2373                  NULL,                             // 98
2374                  NULL,                             // 99
2375                  permissionLogin,          // 100
2376                  NULL,                             // 101
2377                  passwordModify,           // 102
2378                  NULL,                             // 103
2379                  NULL,                             // 104
2380                  NULL,                             // 105
2381                  NULL,                             // 106
2382                  NULL,                             // 107
2383                  NULL,                             // 108
2384                  NULL,                             // 109
2385                  NULL,                             // 110
2386                  NULL,                             // 111
2387                  NULL,                             // 112
2388                  p113Func,                         // 113
2389                  p114Func,                         // 114
2390                  NULL,                             // 115s
2391          };
2392          
2393          // code void (*pageOpenTreat[])(void) =
2394          // {
2395          
2396          // }
2397          
2398          /**
2399           * @brief 打开某页时执行的功能，主要为更新一次当前页的数据
2400           *
2401           * @param page
2402           */
2403          void pageOpenTreat(uint16_t page)
2404          {
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 40  

2405   1              switch (page)
2406   1              {
2407   2              case 11:
2408   2                      write_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE); // 进入页面时刷新数据
2409   2                      break;
2410   2              case 12:
2411   2                      write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
2412   2                      break;
2413   2              case 18:
2414   2                      write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
2415   2                      break;
2416   2              case 22:
2417   2                      write_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
2418   2                      break;
2419   2              case 29:
2420   2                      write_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, BATTERY_SET_SIZE);
2421   2                      break;
2422   2              case 33:
2423   2              {
2424   3                      uint8_t rtc[6];
2425   3                      memcpy(rtc, RTCdata, 3);
2426   3                      memcpy(rtc + 3, RTCdata + 4, 3);
2427   3                      write_dgus_vp(0x9D, (uint8_t *)&rtc, 3);
2428   3                      write_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
2429   3              }
2430   2              break;
2431   2              case 35:
2432   2                      write_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
2433   2                      break;
2434   2              case 39:
2435   2                      write_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
2436   2                      break;
2437   2              case 42:
2438   2                      write_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
2439   2                      break;
2440   2              case 44:
2441   2                      write_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
2442   2                      break;
2443   2              case 48:
2444   2                      write_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
2445   2                      break;
2446   2      
2447   2              default:
2448   2                      break;
2449   2              }
2450   1      }
2451          void PageFunction(void)
2452          {
2453   1              u16 pageid;
2454   1      
2455   1              static uint16_t oldPageid = 0;
2456   1      
2457   1              // EA = 0;
2458   1              ADR_H = 0x00;
2459   1              ADR_M = 0x00;
2460   1              ADR_L = 0x0a;
2461   1              ADR_INC = 1;
2462   1              RAMMODE = 0xAF;
2463   1              while (!APP_ACK)
2464   1                      ;
2465   1              APP_EN = 1;
2466   1              while (APP_EN)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 41  

2467   1                      ;
2468   1              pageid = DATA3;
2469   1              pageid <<= 8;
2470   1              pageid |= DATA2;
2471   1              RAMMODE = 0;
2472   1              EA = 1;
2473   1              if (PagePointer[pageid] != 0)
2474   1              {
2475   2                      PagePointer[pageid]();
2476   2              }
2477   1      
2478   1              if (pageid != oldPageid)
2479   1              {
2480   2                      pageOpenTreat(pageid);
2481   2                      oldPageid = pageid;
2482   2              }
2483   1      }
2484          
2485          /**
2486           * @brief 打开屏保，CFG未设置屏保的情况下，可以通过该代码设置
2487           *
2488           */
2489          void openScreenProtection(void)
2490          {
2491   1              // 打开屏保
2492   1              uint16_t data_0x80[2];
2493   1              data_0x80[0] = 0x5A00;
2494   1              read_dgus_vp(0x81, (uint8_t *)(data_0x80 + 1), 1);
2495   1              data_0x80[1] |= 0x01 << 2;
2496   1              write_dgus_vp(0x80, (uint8_t *)data_0x80, 2);
2497   1      
2498   1              { // 设置屏保亮度
2499   2                      struct
2500   2                      {
2501   2                              uint8_t OpenLuminance;           // 开启亮度
2502   2                              uint8_t protectionLuminance; // 屏保亮度
2503   2                      } screenLuminance;                               // 屏幕亮度
2504   2                      read_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2505   2                      screenLuminance.protectionLuminance = 0;
2506   2                      write_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2507   2              }
2508   1      }
2509          
2510          void weekDisplay(void)
2511          {
2512   1              uint16_t weekday = RTCdata[3];
2513   1              write_dgus_vp(0xB000, (uint8_t *)&weekday, 1);
2514   1      }
2515          
2516          /**
2517           * @brief 充电模式切换为浮充或均充
2518           *
2519           * @param chargeMode ：FLOAT_CHARGE/EQUALIZE_CHARGE
2520           */
2521          void chargeModeSwitch(uint16_t chargeMode)
2522          {
2523   1              static MMODBUS chargeCmd;
2524   1              if (chargeMode == FLOAT_CHARGE)
2525   1              {
2526   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2527   2                      chargeCmd.mode = 0x00;
2528   2                      chargeCmd.flag = 0x00;
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 42  

2529   2                      chargeCmd.Order = 0x06;
2530   2                      chargeCmd.Length = 1;
2531   2                      chargeCmd.reserved = 0x00;
2532   2                      chargeCmd.waitTime = 1000;
2533   2                      chargeCmd.VPaddr = 0;
2534   2                      chargeCmd.ModbusReg = 0X0000;
2535   2                      chargeCmd.databuff = &batteryInfoSet.floatChargeVolt;
2536   2                      synthesisCollection.closeBusVolt = batteryInfoSet.floatChargeVolt; // 防止重复发送数据
2537   2              }
2538   1              else if (chargeMode == EQUALIZE_CHARGE)
2539   1              {
2540   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2541   2                      chargeCmd.mode = 0x00;
2542   2                      chargeCmd.flag = 0x00;
2543   2                      chargeCmd.Order = 0x06;
2544   2                      chargeCmd.Length = 1;
2545   2                      chargeCmd.reserved = 0x00;
2546   2                      chargeCmd.waitTime = 1000;
2547   2                      chargeCmd.VPaddr = 0;
2548   2                      chargeCmd.ModbusReg = 0X0000;
2549   2                      chargeCmd.databuff = &batteryInfoSet.equalizeChargeVolt;
2550   2                      synthesisCollection.closeBusVolt = batteryInfoSet.equalizeChargeVolt;
2551   2              }
2552   1              pushToEmergency(&chargeCmd);
2553   1      }
2554          void batteryManage(void)
2555          {
2556   1              static int32_t totalSecond = 0;
2557   1              static uint16_t chargeState = FLOAT_CHARGE; // 充电状态：均充/浮充
2558   1              int16_t batteryCurr;                                            // 霍尔变比后电池组电流
2559   1      
2560   1              batteryCurr = (int32_t)synthesisCollection.batteryCurr * (int32_t)DC_InfoSet.batteryHallRatio / 100;
2561   1      
2562   1              {
2563   2                      if (batteryCurr < 0)
2564   2                      {
2565   3                              chargeState = DISCHARGE;
2566   3                              KillTimer(CHARGE_TIMER);
2567   3                              totalSecond = 0;
2568   3                      }
2569   2                      else if (batteryCurr >= 0)
2570   2                      {
2571   3                              if (synthesisCollection.closeBusVolt >= batteryInfoSet.equalizeChargeVolt)
2572   3                              { // 根据电压判断均充浮充
2573   4                                      if (chargeState != EQUALIZE_CHARGE)
2574   4                                      {
2575   5                                              chargeState = EQUALIZE_CHARGE;
2576   5                                              StartTimer(CHARGE_TIMER, 1000);
2577   5                                              totalSecond = (int32_t)batteryInfoSet.equalizeChargeHour * 60 * 60;
2578   5                                      }
2579   4                              }
2580   3                              else if (synthesisCollection.closeBusVolt <= batteryInfoSet.floatChargeVolt)
2581   3                              {
2582   4                                      if (chargeState != FLOAT_CHARGE)
2583   4                                      {
2584   5                                              chargeState = FLOAT_CHARGE;
2585   5                                              StartTimer(CHARGE_TIMER, 1000);
2586   5                                              totalSecond = (int32_t)batteryInfoSet.floatChargeDay * 24 * 60 * 60;
2587   5                                      }
2588   4                              }
2589   3      
2590   3                              {
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 43  

2591   4                                      int32_t equalizeCurr; // 均充电流
2592   4                                      int32_t floatCurr;        // 浮充电流
2593   4                                      equalizeCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.floatToEqualizeChargeCur / 100
             -0;
2594   4                                      floatCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.equalizeToFloatChargeCur / 1000;
2595   4                                      if (batteryCurr >= equalizeCurr)
2596   4                                      {
2597   5                                              if (chargeState != EQUALIZE_CHARGE)
2598   5                                              {
2599   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2600   6                                              }
2601   5                                      }
2602   4                                      else if (batteryCurr <= floatCurr)
2603   4                                      {
2604   5                                              if (chargeState != FLOAT_CHARGE)
2605   5                                              {
2606   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2607   6                                              }
2608   5                                      }
2609   4                              }
2610   3      
2611   3                              if (GetTimeOutFlag(CHARGE_TIMER))
2612   3                              {
2613   4                                      totalSecond--;
2614   4                                      if (totalSecond <= 0)
2615   4                                      {
2616   5                                              if (chargeState == FLOAT_CHARGE)
2617   5                                              {
2618   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2619   6                                              }
2620   5                                              else if (chargeState == EQUALIZE_CHARGE)
2621   5                                              {
2622   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2623   6                                              }
2624   5                                      }
2625   4                                      StartTimer(CHARGE_TIMER, 1000);
2626   4                                      {
2627   5                                              timeTypeDef chargeTime;
2628   5                                              chargeTime.day = totalSecond / 60 / 60 / 24;
2629   5                                              chargeTime.hour = totalSecond / 60 / 60 % 24;
2630   5                                              chargeTime.minite = totalSecond / 60 % 60;
2631   5                                              chargeTime.second = totalSecond % 60;
2632   5                                              write_dgus_vp(0xB010, (uint8_t *)&chargeTime, 10);
2633   5                                      }
2634   4                              }
2635   3                      }
2636   2                      write_dgus_vp(0xB002, (uint8_t *)&chargeState, 1);
2637   2              }
2638   1      }
2639          
2640          int16_t batteryVoltSum;
2641          
2642          void batteryVoltDisplay()
2643          {
2644   1              int16_t sum;
2645   1              uint16_t i;
2646   1              if (batterySet.xj24.cellNum > 0)
2647   1              {
2648   2                      if (batterySet.batteryType == XJ24)
2649   2                      {
2650   3                              sum = 0;
2651   3                              for (i = 0; i < batterySet.xj24.cellNum; i++)
C51 COMPILER V9.60.7.0   UI                                                                05/05/2023 15:27:44 PAGE 44  

2652   3                              {
2653   4                                      sum += battery_xj24[i / 24].volt[i % 24];
2654   4                              }
2655   3                      }
2656   2                      else if (batterySet.batteryType == XJ55)
2657   2                      {
2658   3                              sum = 0;
2659   3                              for (i = 0; i < batterySet.xj55.cellNum; i++)
2660   3                              {
2661   4                                      sum += battery_xj55[i / 55].volt[i % 55];
2662   4                              }
2663   3                      }
2664   2              }
2665   1              else if (batterySet.xj24.cellNum == 0)
2666   1              {
2667   2                      sum = synthesisCollection.batteryVolt;
2668   2              }
2669   1              batteryVoltSum = sum;
2670   1              write_dgus_vp(0xB020, (uint8_t *)&batteryVoltSum, 1);
2671   1      }
2672          
2673          void batteryCurrDisplay(void)
2674          {
2675   1              write_dgus_vp(0xB022, (uint8_t *)&synthesisCollection.batteryCurr, 1);
2676   1      }
2677          
2678          void publicUI(void)
2679          {
2680   1              weekDisplay();
2681   1              batteryVoltDisplay();
2682   1              batteryCurrDisplay();
2683   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  19784    ----
   CONSTANT SIZE    =    353    ----
   XDATA SIZE       =   2233     380
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
