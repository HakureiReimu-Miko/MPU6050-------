C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UI
OBJECT MODULE PLACED IN .\Objects\ui.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\ui.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.\li
                    -b) DEBUG OBJECTEXTEND PRINT(.\Listings\ui.lst) OBJECT(.\Objects\ui.obj)

line level    source

   1          #include "ui.h"
   2          #include "modbus.h"
   3          #include <STRING.H>
   4          #include "permission.h"
   5          #include "debug.h"
   6          #include "norflash.h"
   7          #include <STDLIB.H>
   8          #include "rtc.h"
   9          #include "const.h"
  10          #include "data.h"
  11          #include "umath.h"
  12          #include "timer.h"
  13          #include "alarm.h"
  14          
  15          #define testDis 0
  16          void testDisplayNum(u16 addr, u16 num)
  17          {
  18   1      #if testDis
              
              #else
  21   1              write_dgus_vp(addr, (u8 *)&num, 1);
  22   1      #endif
  23   1      }
  24          
  25          // 读取按键0x1000的值
  26          u8 getTouch(void)
  27          {
  28   1              u8 tmp;
  29   1              // EA = 0;
  30   1              ADR_H = 0x00;
  31   1              ADR_M = 0x08; // 0x1000
  32   1              ADR_L = 0x00;
  33   1              ADR_INC = 1;
  34   1              RAMMODE = 0xAF;
  35   1              while (!APP_ACK)
  36   1                      ;
  37   1              APP_EN = 1;
  38   1              while (APP_EN)
  39   1                      ;
  40   1              // str[0] = DATA3;
  41   1              tmp = DATA2;
  42   1              // EA = 1;
  43   1              RAMMODE = 0;
  44   1              return tmp;
  45   1      }
  46          
  47          // 清除按键0x1000的值
  48          void clrTouch(void)
  49          {
  50   1              // EA = 0;
  51   1              ADR_H = 0x00;
  52   1              ADR_M = 0x08; // 0x1000
  53   1              ADR_L = 0x00;
  54   1              ADR_INC = 1;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 2   

  55   1              RAMMODE = 0x8C;
  56   1              while (!APP_ACK)
  57   1                      ;
  58   1              DATA3 = 0;
  59   1              DATA2 = 0;
  60   1              APP_EN = 1;
  61   1              while (APP_EN)
  62   1                      ;
  63   1              RAMMODE = 0;
  64   1              // EA = 1;
  65   1      }
  66          
  67          void P0Func(void)
  68          {
  69   1              VariableChangedIndicationTypeDef variableChangedIndication;
  70   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
  71   1              if (variableChangedIndication.flag == 0x5A)
  72   1              {
  73   2                      uint16_t variable[5];
  74   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
  75   2                      switch (variableChangedIndication.addr)
  76   2                      {
  77   3                      case 0x8000:
  78   3                              if (variable[0] == 1)
  79   3                              {
  80   4                                      if (manager.loginFlag || admin.loginFlag)
  81   4                                      {
  82   5                                              Page_Change(SYS_FUNCTION_TABLE_PAGE);
  83   5                                      }
  84   4                                      else
  85   4                                      {
  86   5                                              passwordLogin(SYS_FUNCTION_TABLE_PAGE);
  87   5                                      }
  88   4                              }
  89   3                              break;
  90   3                      case 0x8001:
  91   3                              if (variable[0] == 1)
  92   3                              {
  93   4                                      if (manager.loginFlag || admin.loginFlag)
  94   4                                      {
  95   5                                              Page_Change(BATTERY_MANAGER_PAGE);
  96   5                                      }
  97   4                                      else
  98   4                                      {
  99   5                                              passwordLogin(BATTERY_MANAGER_PAGE);
 100   5                                      }
 101   4                              }
 102   3                              break;
 103   3                      case 0x8006:
 104   3                              if (variable[0] == 1)
 105   3                              {
 106   4                                      if (chargeModuleSet.moduleNum > 0)
 107   4                                      {
 108   5                                              Page_Change(CHARGE_DATA_PAGE);
 109   5                                      }
 110   4                              }
 111   3                              break;
 112   3                      case 0x8007:
 113   3                              if (variable[0] == 1)
 114   3                              {
 115   4                                      if (batterySet.batteryType == XJ24)
 116   4                                      {
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 3   

 117   5                                              if (batterySet.xj24.batteryModuleNum > 0)
 118   5                                              {
 119   6                                                      Page_Change(BATTERY_DATA_PAGE);
 120   6                                              }
 121   5                                      }
 122   4                                      else if (batterySet.batteryType == XJ55)
 123   4                                      {
 124   5                                              if (batterySet.xj55.batteryModuleNum > 0)
 125   5                                              {
 126   6                                                      Page_Change(BATTERY_DATA_PAGE);
 127   6                                              }
 128   5                                      }
 129   4                              }
 130   3                              break;
 131   3                      case 0x8008:
 132   3                              if (variable[0] == 1)
 133   3                              {
 134   4                                      if (switchModuleSet.switchModule.switchNum > 0)
 135   4                                      {
 136   5                                              Page_Change(SWITCH_MODULE_DATA_PAGE);
 137   5                                      }
 138   4                              }
 139   3                              break;
 140   3                      case 0x800A:
 141   3                              if (variable[0] == 1)
 142   3                              {
 143   4                                      if (UPS_INV_Set.UPS_Num > 0)
 144   4                                      {
 145   5                                              Page_Change(UPS_DATA_PAGE);
 146   5                                      }
 147   4                              }
 148   3                              break;
 149   3                      case 0x800B:
 150   3                              if (variable[0] == 1)
 151   3                              {
 152   4                                      if (DC_ConverterSet.Num > 0)
 153   4                                      {
 154   5                                              Page_Change(DC_CONVERTER_DATA_PAGE);
 155   5                                      }
 156   4                              }
 157   3                              break;
 158   3                      case 0x800C:
 159   3                              if (variable[0] == 1)
 160   3                              {
 161   4                                      if (insulationSet.DC.Num > 0)
 162   4                                      {
 163   5                                              Page_Change(INSULATION_DATA_PAGE);
 164   5                                      }
 165   4                                      else
 166   4                                      {
 167   5                                              Page_Change(NON_INSULATION_DATA_PAGE);
 168   5                                      }
 169   4                              }
 170   3                              break;
 171   3                      default:
 172   3                              break;
 173   3                      }
 174   2                      memset(variable, 0, 5);
 175   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 176   2                      variableChangedIndication.flag = 0;
 177   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 178   2              }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 4   

 179   1      
 180   1              if (manager.loginFlag)
 181   1              {
 182   2                      manager.loginFlag = 0;
 183   2              }
 184   1              if (admin.loginFlag)
 185   1              {
 186   2                      admin.loginFlag = 0;
 187   2              }
 188   1      }
 189          
 190          void P2Func(void)
 191          {
 192   1              VariableChangedIndicationTypeDef variableChangedIndication;
 193   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 194   1              if (variableChangedIndication.flag == 0x5A)
 195   1              {
 196   2                      uint16_t variable[5];
 197   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 198   2                      switch (variableChangedIndication.addr)
 199   2                      {
 200   3                      case 0x8020:
 201   3                              if (variable[0] == 1)
 202   3                              {
 203   4                                      if (manager.loginFlag || admin.loginFlag)
 204   4                                      {
 205   5                                              Page_Change(SYS_INFO_PAGE);
 206   5                                      }
 207   4                                      else
 208   4                                      {
 209   5                                              passwordLogin(SYS_INFO_PAGE);
 210   5                                      }
 211   4                              }
 212   3                              break;
 213   3                      case 0x8021:
 214   3                              if (variable[0] == 1)
 215   3                              {
 216   4                                      if (manager.loginFlag || admin.loginFlag)
 217   4                                      {
 218   5                                              Page_Change(SWITCH_MODULE_SET_PAGE);
 219   5                                      }
 220   4                                      else
 221   4                                      {
 222   5                                              passwordLogin(SWITCH_MODULE_SET_PAGE);
 223   5                                      }
 224   4                              }
 225   3                              break;
 226   3                      case 0x8022:
 227   3                              if (variable[0] == 1)
 228   3                              {
 229   4                                      if (manager.loginFlag || admin.loginFlag)
 230   4                                      {
 231   5                                              Page_Change(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 232   5                                      }
 233   4                                      else
 234   4                                      {
 235   5                                              passwordLogin(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 236   5                                      }
 237   4                              }
 238   3                              break;
 239   3                      case 0x8023:
 240   3                              if (variable[0] == 1)
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 5   

 241   3                              {
 242   4                                      if (manager.loginFlag || admin.loginFlag)
 243   4                                      {
 244   5                                              Page_Change(INSULATION_SET_PAGE);
 245   5                                      }
 246   4                                      else
 247   4                                      {
 248   5                                              passwordLogin(INSULATION_SET_PAGE);
 249   5                                      }
 250   4                              }
 251   3                              break;
 252   3                      case 0x8024:
 253   3                              if (variable[0] == 1)
 254   3                              {
 255   4                                      if (manager.loginFlag || admin.loginFlag)
 256   4                                      {
 257   5                                              Page_Change(CHARGER_MODULE_SET_PAGE);
 258   5                                      }
 259   4                                      else
 260   4                                      {
 261   5                                              passwordLogin(CHARGER_MODULE_SET_PAGE);
 262   5                                      }
 263   4                              }
 264   3                              break;
 265   3                      case 0x8025:
 266   3                              if (variable[0] == 1)
 267   3                              {
 268   4                                      if (manager.loginFlag || admin.loginFlag)
 269   4                                      {
 270   5                                              Page_Change(DC_MODULE_SET_PAGE);
 271   5                                      }
 272   4                                      else
 273   4                                      {
 274   5                                              passwordLogin(DC_MODULE_SET_PAGE);
 275   5                                      }
 276   4                              }
 277   3                              break;
 278   3                      case 0x8026:
 279   3                              if (variable[0] == 1)
 280   3                              {
 281   4                                      if (manager.loginFlag || admin.loginFlag)
 282   4                                      {
 283   5                                              Page_Change(UPS_INV_SET_PAGE);
 284   5                                      }
 285   4                                      else
 286   4                                      {
 287   5                                              passwordLogin(UPS_INV_SET_PAGE);
 288   5                                      }
 289   4                              }
 290   3                              break;
 291   3                      case 0x8027:
 292   3                              if (variable[0] == 1)
 293   3                              {
 294   4                                      if (admin.loginFlag)
 295   4                                      {
 296   5                                              Page_Change(RECOVERY_PAGE);
 297   5                                      }
 298   4                                      else
 299   4                                      {
 300   5                                              passwordLogin(RECOVERY_PAGE);
 301   5                                      }
 302   4                              }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 6   

 303   3                              break;
 304   3      
 305   3                      default:
 306   3                              break;
 307   3                      }
 308   2                      memset(variable, 0, 5);
 309   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 310   2                      variableChangedIndication.flag = 0;
 311   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 312   2              }
 313   1      }
 314          
 315          void P11Func(void)
 316          {
 317   1              VariableChangedIndicationTypeDef variableChangedIndication;
 318   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 319   1              if (variableChangedIndication.flag == 0x5A)
 320   1              {
 321   2                      uint16_t variable[5];
 322   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 323   2                      switch (variableChangedIndication.addr)
 324   2                      {
 325   3                      case 0x8041:
 326   3                              if (variable[0] == 1)
 327   3                              {
 328   4                                      read_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE);
 329   4                                      dgusToNorFlash(SYS_INFO_NORFLASH_ADDR, SYS_INFO_VP, SYS_INFO_SIZE);
 330   4                                      modbusCenerate();
 331   4                                      // DEBUGINFO("save sysInfo");
 332   4                              }
 333   3                              break;
 334   3                      default:
 335   3                              break;
 336   3                      }
 337   2                      memset(variable, 0, 5);
 338   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 339   2      
 340   2                      variableChangedIndication.flag = 0;
 341   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 342   2              }
 343   1      }
 344          
 345          void P12Func()
 346          {
 347   1              VariableChangedIndicationTypeDef variableChangedIndication;
 348   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 349   1              if (variableChangedIndication.flag == 0x5A)
 350   1              {
 351   2                      uint16_t variable[5];
 352   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 353   2                      switch (variableChangedIndication.addr)
 354   2                      {
 355   3                      case 0x8060:
 356   3                              if (variable[0] == 1)
 357   3                              {
 358   4                                      read_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
 359   4                                      dgusToNorFlash(AC_INFO_NORFLASH_ADDR, AC_INFO_VP, AC_INFO_SIZE);
 360   4                                      modbusCenerate();
 361   4                              }
 362   3                              break;
 363   3                      default:
 364   3                              break;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 7   

 365   3                      }
 366   2                      memset(variable, 0, 5);
 367   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 368   2      
 369   2                      variableChangedIndication.flag = 0;
 370   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 371   2              }
 372   1      }
 373          
 374          void P18Func()
 375          {
 376   1              VariableChangedIndicationTypeDef variableChangedIndication;
 377   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 378   1              if (variableChangedIndication.flag == 0x5A)
 379   1              {
 380   2                      uint16_t variable[5];
 381   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 382   2                      switch (variableChangedIndication.addr)
 383   2                      {
 384   3                      case 0x8060:
 385   3                              if (variable[0] == 1)
 386   3                              {
 387   4                                      read_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
 388   4                                      dgusToNorFlash(DC_INFO_NORFLASH_ADDR, DC_INFO_VP, DC_INFO_SIZE);
 389   4                                      modbusCenerate();
 390   4                              }
 391   3                              break;
 392   3                      case 0x90B1:
 393   3                      {
 394   4                              if (sysInfoSet.siliconChain == 0)
 395   4                              {
 396   5                                      write_dgus_vp(0x90A1, (uint8_t *)&variable, 1);
 397   5                              }
 398   4                              else
 399   4                              {
 400   5                                      write_dgus_vp(0x90A5, (uint8_t *)&variable, 1);
 401   5                              }
 402   4                      }
 403   3                      break;
 404   3                      case 0x90B2:
 405   3                      {
 406   4                              if (sysInfoSet.siliconChain == 0)
 407   4                              {
 408   5                                      write_dgus_vp(0x90A2, (uint8_t *)&variable, 1);
 409   5                              }
 410   4                              else
 411   4                              {
 412   5                                      write_dgus_vp(0x90A6, (uint8_t *)&variable, 1);
 413   5                              }
 414   4                      }
 415   3                      break;
 416   3                      case 0x90B3:
 417   3                      {
 418   4                              if (sysInfoSet.siliconChain == 0)
 419   4                              {
 420   5                                      write_dgus_vp(0x90A3, (uint8_t *)&variable, 1);
 421   5                              }
 422   4                              else
 423   4                              {
 424   5                                      write_dgus_vp(0x90A7, (uint8_t *)&variable, 1);
 425   5                              }
 426   4                      }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 8   

 427   3                      break;
 428   3                      case 0x90B4:
 429   3                      {
 430   4                              if (sysInfoSet.siliconChain == 0)
 431   4                              {
 432   5                                      write_dgus_vp(0x90A4, (uint8_t *)&variable, 1);
 433   5                              }
 434   4                              else
 435   4                              {
 436   5                                      write_dgus_vp(0x90A8, (uint8_t *)&variable, 1);
 437   5                              }
 438   4                      }
 439   3                      break;
 440   3                      default:
 441   3                              break;
 442   3                      }
 443   2                      memset(variable, 0, 5);
 444   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)variable, variableChangedIndication.len);
 445   2      
 446   2                      variableChangedIndication.flag = 0;
 447   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 448   2              }
 449   1      
 450   1              {
 451   2                      if (sysInfoSet.sysVoltageGrade == SYSTEM_220V)
 452   2                      {
 453   3                              uint16_t sp; // 描述指针
 454   3                              sp = 0x90A1;
 455   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 456   3                              sp = 0x90A2;
 457   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 458   3                              sp = 0x90A3;
 459   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 460   3                              sp = 0x90A4;
 461   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 462   3                      }
 463   2                      else if (sysInfoSet.sysVoltageGrade == SYSTEM_110V)
 464   2                      {
 465   3                              uint16_t sp; // 描述指针
 466   3                              sp = 0x90A5;
 467   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 468   3                              sp = 0x90A6;
 469   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 470   3                              sp = 0x90A7;
 471   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 472   3                              sp = 0x90A8;
 473   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 474   3                      }
 475   2              }
 476   1      }
 477          
 478          void P22Func()
 479          {
 480   1              VariableChangedIndicationTypeDef variableChangedIndication;
 481   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 482   1              if (variableChangedIndication.flag == 0x5A)
 483   1              {
 484   2                      uint16_t variable[5];
 485   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 486   2                      switch (variableChangedIndication.addr)
 487   2                      {
 488   3                      case 0x8080:
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 9   

 489   3                              if (variable[0] == 1)
 490   3                              {
 491   4                                      read_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
 492   4                                      dgusToNorFlash(BATTERY_INFO_NORFLASH_ADDR, BATTERY_INFO_VP, BATTERY_SET_SIZE);
 493   4                                      modbusCenerate();
 494   4                              }
 495   3                              break;
 496   3                      case 0x9120:
 497   3                              if (variable[0] == 1)
 498   3                              {
 499   4                                      chargeModeSwitch(FLOAT_CHARGE);
 500   4                              }
 501   3                              break;
 502   3                      case 0x9121:
 503   3                              if (variable[0] == 1)
 504   3                              {
 505   4                                      chargeModeSwitch(EQUALIZE_CHARGE);
 506   4                              }
 507   3                              break;
 508   3                      default:
 509   3                              break;
 510   3                      }
 511   2                      memset(variable, 0, 5);
 512   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 513   2      
 514   2                      variableChangedIndication.flag = 0;
 515   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 516   2              }
 517   1      }
 518          
 519          void P26Func()
 520          {
 521   1              VariableChangedIndicationTypeDef variableChangedIndication;
 522   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 523   1              if (variableChangedIndication.flag == 0x5A)
 524   1              {
 525   2                      uint16_t variable[5];
 526   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 527   2                      switch (variableChangedIndication.addr)
 528   2                      {
 529   3                      case 0x9150:
 530   3                              if (variable[0] == 1)
 531   3                              {
 532   4                                      passwordLogin(26);
 533   4                              }
 534   3                              break;
 535   3                      case 0x9152:
 536   3                              if (variable[0] == 1)
 537   3                              {
 538   4                                      manager.loginFlag = 0;
 539   4                                      admin.loginFlag = 0;
 540   4                              }
 541   3                              break;
 542   3                      default:
 543   3                              break;
 544   3                      }
 545   2                      memset(variable, 0, 5);
 546   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 547   2                      variableChangedIndication.flag = 0;
 548   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 549   2              }
 550   1      
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 10  

 551   1              { // 当前登录用户显示
 552   2                      int16_t userNum;
 553   2                      if (admin.loginFlag)
 554   2                      {
 555   3                              userNum = 2;
 556   3                      }
 557   2                      else if (manager.loginFlag)
 558   2                      {
 559   3                              userNum = 1;
 560   3                      }
 561   2                      else
 562   2                      {
 563   3                              userNum = 0;
 564   3                      }
 565   2                      write_dgus_vp(0x9160, (uint8_t *)&userNum, 1);
 566   2              }
 567   1      }
 568          
 569          void P29Func()
 570          {
 571   1              VariableChangedIndicationTypeDef variableChangedIndication;
 572   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 573   1              if (variableChangedIndication.flag == 0x5A)
 574   1              {
 575   2                      uint16_t variable[5];
 576   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 577   2                      switch (variableChangedIndication.addr)
 578   2                      {
 579   3                      case 0x80C0:
 580   3                              if (variable[0] == 1)
 581   3                              {
 582   4                                      read_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, SPECIAL_PARA_SIZE);
 583   4                                      dgusToNorFlash(SPECIAL_PARA_NORFLASH_ADDR, SPECIAL_PARA_VP, SPECIAL_PARA_SIZE);
 584   4                                      modbusCenerate();
 585   4                              }
 586   3                              break;
 587   3                      case 0x91B2:
 588   3                      {
 589   4                              static MMODBUS closeBusVoltRectify;
 590   4                              closeBusVoltRectify.SlaveAddr = 0x61;
 591   4                              closeBusVoltRectify.mode = 0x00;
 592   4                              closeBusVoltRectify.flag = 0x00;
 593   4                              closeBusVoltRectify.Order = 0x06;
 594   4                              closeBusVoltRectify.Length = 0x01;
 595   4                              closeBusVoltRectify.reserved = 0x00;
 596   4                              closeBusVoltRectify.waitTime = 1000;
 597   4                              closeBusVoltRectify.VPaddr = 0x91B2;
 598   4                              closeBusVoltRectify.ModbusReg = 0x0000;
 599   4                              closeBusVoltRectify.databuff = NULL;
 600   4                              pushToEmergency(&closeBusVoltRectify);
 601   4                      }
 602   3                      break;
 603   3                      case 0x91B3:
 604   3                      {
 605   4                              static MMODBUS controlBusVoltRectify;
 606   4                              controlBusVoltRectify.SlaveAddr = 0x61;
 607   4                              controlBusVoltRectify.mode = 0x00;
 608   4                              controlBusVoltRectify.flag = 0x00;
 609   4                              controlBusVoltRectify.Order = 0x06;
 610   4                              controlBusVoltRectify.Length = 0x01;
 611   4                              controlBusVoltRectify.reserved = 0x00;
 612   4                              controlBusVoltRectify.waitTime = 1000;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 11  

 613   4                              controlBusVoltRectify.VPaddr = 0x91B3;
 614   4                              controlBusVoltRectify.ModbusReg = 0x0001;
 615   4                              controlBusVoltRectify.databuff = NULL;
 616   4                              pushToEmergency(&controlBusVoltRectify);
 617   4                      }
 618   3                      break;
 619   3                      case 0x91B4:
 620   3                      {
 621   4                              static MMODBUS busToGroundVoltRectify;
 622   4                              busToGroundVoltRectify.SlaveAddr = 0x61;
 623   4                              busToGroundVoltRectify.mode = 0x00;
 624   4                              busToGroundVoltRectify.flag = 0x00;
 625   4                              busToGroundVoltRectify.Order = 0x06;
 626   4                              busToGroundVoltRectify.Length = 0x01;
 627   4                              busToGroundVoltRectify.reserved = 0x00;
 628   4                              busToGroundVoltRectify.waitTime = 1000;
 629   4                              busToGroundVoltRectify.VPaddr = 0x91B4;
 630   4                              busToGroundVoltRectify.ModbusReg = 0x0002;
 631   4                              busToGroundVoltRectify.databuff = NULL;
 632   4                              pushToEmergency(&busToGroundVoltRectify);
 633   4                      }
 634   3                      break;
 635   3                      case 0x91B5:
 636   3                      {
 637   4                              static MMODBUS batteryVoltRectify;
 638   4                              batteryVoltRectify.SlaveAddr = 0x61;
 639   4                              batteryVoltRectify.mode = 0x00;
 640   4                              batteryVoltRectify.flag = 0x00;
 641   4                              batteryVoltRectify.Order = 0x06;
 642   4                              batteryVoltRectify.Length = 0x01;
 643   4                              batteryVoltRectify.reserved = 0x00;
 644   4                              batteryVoltRectify.waitTime = 1000;
 645   4                              batteryVoltRectify.VPaddr = 0x91B5;
 646   4                              batteryVoltRectify.ModbusReg = 0x0003;
 647   4                              batteryVoltRectify.databuff = NULL;
 648   4                              pushToEmergency(&batteryVoltRectify);
 649   4                      }
 650   3                      break;
 651   3      
 652   3                      case 0x91B6:
 653   3                      {
 654   4                              static MMODBUS AC1_Ua_Rectify;
 655   4                              AC1_Ua_Rectify.SlaveAddr = 0x61;
 656   4                              AC1_Ua_Rectify.mode = 0x00;
 657   4                              AC1_Ua_Rectify.flag = 0x00;
 658   4                              AC1_Ua_Rectify.Order = 0x06;
 659   4                              AC1_Ua_Rectify.Length = 0x01;
 660   4                              AC1_Ua_Rectify.reserved = 0x00;
 661   4                              AC1_Ua_Rectify.waitTime = 1000;
 662   4                              AC1_Ua_Rectify.VPaddr = 0x91B6;
 663   4                              AC1_Ua_Rectify.ModbusReg = 0x0006;
 664   4                              AC1_Ua_Rectify.databuff = NULL;
 665   4                              pushToEmergency(&AC1_Ua_Rectify);
 666   4                      }
 667   3                      break;
 668   3      
 669   3                      case 0x91B7:
 670   3                      {
 671   4                              static MMODBUS AC1_Ub_Rectify;
 672   4                              AC1_Ub_Rectify.SlaveAddr = 0x61;
 673   4                              AC1_Ub_Rectify.mode = 0x00;
 674   4                              AC1_Ub_Rectify.flag = 0x00;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 12  

 675   4                              AC1_Ub_Rectify.Order = 0x06;
 676   4                              AC1_Ub_Rectify.Length = 0x01;
 677   4                              AC1_Ub_Rectify.reserved = 0x00;
 678   4                              AC1_Ub_Rectify.waitTime = 1000;
 679   4                              AC1_Ub_Rectify.VPaddr = 0x91B7;
 680   4                              AC1_Ub_Rectify.ModbusReg = 0x0007;
 681   4                              AC1_Ub_Rectify.databuff = NULL;
 682   4                              pushToEmergency(&AC1_Ub_Rectify);
 683   4                      }
 684   3                      break;
 685   3                      case 0x91B8:
 686   3                      {
 687   4                              static MMODBUS AC1_Uc_Rectify;
 688   4                              AC1_Uc_Rectify.SlaveAddr = 0x61;
 689   4                              AC1_Uc_Rectify.mode = 0x00;
 690   4                              AC1_Uc_Rectify.flag = 0x00;
 691   4                              AC1_Uc_Rectify.Order = 0x06;
 692   4                              AC1_Uc_Rectify.Length = 0x01;
 693   4                              AC1_Uc_Rectify.reserved = 0x00;
 694   4                              AC1_Uc_Rectify.waitTime = 1000;
 695   4                              AC1_Uc_Rectify.VPaddr = 0x91B8;
 696   4                              AC1_Uc_Rectify.ModbusReg = 0x0008;
 697   4                              AC1_Uc_Rectify.databuff = NULL;
 698   4                              pushToEmergency(&AC1_Uc_Rectify);
 699   4                      }
 700   3                      break;
 701   3                      case 0x91B9:
 702   3                      {
 703   4                              static MMODBUS AC2_Ua_Rectify;
 704   4                              AC2_Ua_Rectify.SlaveAddr = 0x61;
 705   4                              AC2_Ua_Rectify.mode = 0x00;
 706   4                              AC2_Ua_Rectify.flag = 0x00;
 707   4                              AC2_Ua_Rectify.Order = 0x06;
 708   4                              AC2_Ua_Rectify.Length = 0x01;
 709   4                              AC2_Ua_Rectify.reserved = 0x00;
 710   4                              AC2_Ua_Rectify.waitTime = 1000;
 711   4                              AC2_Ua_Rectify.VPaddr = 0x91B9;
 712   4                              AC2_Ua_Rectify.ModbusReg = 0x0009;
 713   4                              AC2_Ua_Rectify.databuff = NULL;
 714   4                              pushToEmergency(&AC2_Ua_Rectify);
 715   4                      }
 716   3                      break;
 717   3                      case 0x91BA:
 718   3                      {
 719   4                              static MMODBUS AC2_Ub_Rectify;
 720   4                              AC2_Ub_Rectify.SlaveAddr = 0x61;
 721   4                              AC2_Ub_Rectify.mode = 0x00;
 722   4                              AC2_Ub_Rectify.flag = 0x00;
 723   4                              AC2_Ub_Rectify.Order = 0x06;
 724   4                              AC2_Ub_Rectify.Length = 0x01;
 725   4                              AC2_Ub_Rectify.reserved = 0x00;
 726   4                              AC2_Ub_Rectify.waitTime = 1000;
 727   4                              AC2_Ub_Rectify.VPaddr = 0x91BA;
 728   4                              AC2_Ub_Rectify.ModbusReg = 0x000A;
 729   4                              AC2_Ub_Rectify.databuff = NULL;
 730   4                              pushToEmergency(&AC2_Ub_Rectify);
 731   4                      }
 732   3                      break;
 733   3                      case 0x91BB:
 734   3                      {
 735   4                              static MMODBUS AC2_Uc_Rectify;
 736   4                              AC2_Uc_Rectify.SlaveAddr = 0x61;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 13  

 737   4                              AC2_Uc_Rectify.mode = 0x00;
 738   4                              AC2_Uc_Rectify.flag = 0x00;
 739   4                              AC2_Uc_Rectify.Order = 0x06;
 740   4                              AC2_Uc_Rectify.Length = 0x01;
 741   4                              AC2_Uc_Rectify.reserved = 0x00;
 742   4                              AC2_Uc_Rectify.waitTime = 1000;
 743   4                              AC2_Uc_Rectify.VPaddr = 0x91BB;
 744   4                              AC2_Uc_Rectify.ModbusReg = 0x000B;
 745   4                              AC2_Uc_Rectify.databuff = NULL;
 746   4                              pushToEmergency(&AC2_Uc_Rectify);
 747   4                      }
 748   3                      break;
 749   3      
 750   3                      default:
 751   3                              break;
 752   3                      }
 753   2                      variableChangedIndication.flag = 0;
 754   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 755   2              }
 756   1              {
 757   2                      write_dgus_vp(0x91A2, (uint8_t *)&synthesisCollection.closeBusVolt, 1);
 758   2                      write_dgus_vp(0x91A3, (uint8_t *)&synthesisCollection.controlBusVolt, 1);
 759   2                      write_dgus_vp(0x91A4, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
 760   2                      write_dgus_vp(0x91A5, (uint8_t *)&synthesisCollection.batteryVolt, 1);
 761   2                      write_dgus_vp(0x91A6, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
 762   2                      write_dgus_vp(0x91A7, (uint8_t *)&synthesisCollection.AC_channel_1_Ubc, 1);
 763   2                      write_dgus_vp(0x91A8, (uint8_t *)&synthesisCollection.AC_channel_1_Uca, 1);
 764   2                      write_dgus_vp(0x91A9, (uint8_t *)&synthesisCollection.AC_channel_2_Uab, 1);
 765   2                      write_dgus_vp(0x91AA, (uint8_t *)&synthesisCollection.AC_channel_2_Ubc, 1);
 766   2                      write_dgus_vp(0x91AB, (uint8_t *)&synthesisCollection.AC_channel_2_Uca, 1);
 767   2              }
 768   1      }
 769          
 770          void P33Func()
 771          {
 772   1              static uint8_t timeModifyFlag = 0; // 时间修改标记
 773   1              VariableChangedIndicationTypeDef variableChangedIndication;
 774   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 775   1              if (variableChangedIndication.flag == 0x5A)
 776   1              {
 777   2                      uint16_t variable[5];
 778   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 779   2                      switch (variableChangedIndication.addr)
 780   2                      {
 781   3                      case 0x009D:
 782   3                      case 0x009E:
 783   3                      case 0x009F:
 784   3                              timeModifyFlag = 1;
 785   3                              break;
 786   3      
 787   3                      case 0x80E0:
 788   3                              if (variable[0] == 1)
 789   3                              {
 790   4                                      if (timeModifyFlag == 1) // 由于时间会不断变化，故仅在修改时间的情况下保存时间，避免修改屏保时写入时间
 791   4                                      {
 792   5                                              uint8_t rtcSetData[6];
 793   5                                              read_dgus_vp(0x9D, rtcSetData, 4);
 794   5                                              Write_RTC(rtcSetData);
 795   5                                              timeModifyFlag = 0;
 796   5                                      }
 797   4                                      read_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
 798   4                                      Nor_Flash_write(BACKLIGHT_TIME_NORFLASH_ADDR, (uint8_t *)&backLightTime, 2);
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 14  

 799   4                                      write_dgus_vp(0x83, (uint8_t *)&backLightTime, 1);
 800   4                              }
 801   3                              break;
 802   3      
 803   3                      default:
 804   3                              break;
 805   3                      }
 806   2                      variableChangedIndication.flag = 0;
 807   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 808   2              }
 809   1      }
 810          
 811          void P35Func()
 812          {
 813   1              VariableChangedIndicationTypeDef variableChangedIndication;
 814   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 815   1              if (variableChangedIndication.flag == 0x5A)
 816   1              {
 817   2                      uint16_t variable[5];
 818   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 819   2                      switch (variableChangedIndication.addr)
 820   2                      {
 821   3                      case 0x8100:
 822   3                              if (variable[0] == 1)
 823   3                              {
 824   4                                      read_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
 825   4                                      dgusToNorFlash(SWITCH_MODULE_NORFLASH_ADDR, SWITCH_MODULE_SET_VP, SWITCH_MODULE_SIZE);
 826   4                                      modbusCenerate();
 827   4                              }
 828   3                              break;
 829   3      
 830   3                      default:
 831   3                              break;
 832   3                      }
 833   2                      memset(variable, 0, 5);
 834   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 835   2                      variableChangedIndication.flag = 0;
 836   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 837   2              }
 838   1      }
 839          
 840          void P39Func()
 841          {
 842   1              VariableChangedIndicationTypeDef variableChangedIndication;
 843   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 844   1              if (variableChangedIndication.flag == 0x5A)
 845   1              {
 846   2                      uint16_t variable[5];
 847   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 848   2                      switch (variableChangedIndication.addr)
 849   2                      {
 850   3                      case 0x8120:
 851   3                              if (variable[0] == 1)
 852   3                              {
 853   4                                      read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
 854   4                                      dgusToNorFlash(BATTERY_SET_NORFLASH_ADDR, BATTERY_SET_VP, BATTERY_SET_SIZE);
 855   4                                      modbusCenerate();
 856   4                              }
 857   3                              break;
 858   3                      case 0x9250:
 859   3                              read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet.batteryType, 1);
 860   3                              break;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 15  

 861   3                      case 0x9280:
 862   3                      {
 863   4                              if (batterySet.batteryType == XJ24)
 864   4                              {
 865   5                                      if (0 <= variable[0] && variable[0] <= 5)
 866   5                                      {
 867   6                                              uint16_t batteryModuleNum = variable[0];
 868   6                                              uint16_t cellNum;
 869   6                                              write_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 870   6      
 871   6                                              // 根据巡检数量设置电池节数上限
 872   6                                              read_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 873   6                                              if (cellNum > batteryModuleNum * 24)
 874   6                                              {
 875   7                                                      cellNum = batteryModuleNum * 24;
 876   7                                              }
 877   6                                              write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 878   6                                      }
 879   5                              }
 880   4                              else if (batterySet.batteryType == XJ55)
 881   4                              {
 882   5                                      if (0 <= variable[0] && variable[0] <= 2)
 883   5                                      {
 884   6                                              uint16_t batteryModuleNum = variable[0];
 885   6                                              uint16_t cellNum;
 886   6                                              write_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 887   6      
 888   6                                              // 根据巡检数量设置电池节数上限
 889   6                                              read_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 890   6                                              if (cellNum > batteryModuleNum * 55)
 891   6                                              {
 892   7                                                      cellNum = batteryModuleNum * 55;
 893   7                                              }
 894   6                                              write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 895   6                                      }
 896   5                              }
 897   4                      }
 898   3                      break;
 899   3                      case 0x9281:
 900   3                      {
 901   4                              if (batterySet.batteryType == XJ24)
 902   4                              {
 903   5                                      uint16_t batteryModuleNum;
 904   5                                      uint16_t cellNum = variable[0];
 905   5                                      read_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 906   5                                      if (cellNum > batteryModuleNum * 24)
 907   5                                      {
 908   6                                              cellNum = batteryModuleNum * 24;
 909   6                                      }
 910   5                                      write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 911   5                              }
 912   4                              else if (batterySet.batteryType == XJ55)
 913   4                              {
 914   5                                      uint16_t batteryModuleNum;
 915   5                                      uint16_t cellNum = variable[0];
 916   5                                      read_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 917   5                                      if (cellNum > batteryModuleNum * 55)
 918   5                                      {
 919   6                                              cellNum = batteryModuleNum * 55;
 920   6                                      }
 921   5                                      write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 922   5                              }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 16  

 923   4                      }
 924   3                      break;
 925   3                      case 0x9282:
 926   3                      {
 927   4                              if (batterySet.batteryType == XJ24)
 928   4                              {
 929   5                                      write_dgus_vp(0x9262, (uint8_t *)variable, 1);
 930   5                              }
 931   4                              else if (batterySet.batteryType == XJ55)
 932   4                              {
 933   5                                      write_dgus_vp(0x9272, (uint8_t *)variable, 1);
 934   5                              }
 935   4                      }
 936   3                      break;
 937   3                      case 0x9283:
 938   3                      {
 939   4                              if (batterySet.batteryType == XJ24)
 940   4                              {
 941   5                                      write_dgus_vp(0x9263, (uint8_t *)variable, 1);
 942   5                              }
 943   4                              else if (batterySet.batteryType == XJ55)
 944   4                              {
 945   5                                      write_dgus_vp(0x9273, (uint8_t *)variable, 1);
 946   5                              }
 947   4                      }
 948   3                      break;
 949   3                      case 0x9284:
 950   3                      {
 951   4                              if (batterySet.batteryType == XJ24)
 952   4                              {
 953   5                                      write_dgus_vp(0x9264, (uint8_t *)variable, 1);
 954   5                              }
 955   4                              else if (batterySet.batteryType == XJ55)
 956   4                              {
 957   5                                      write_dgus_vp(0x9274, (uint8_t *)variable, 1);
 958   5                              }
 959   4                      }
 960   3                      break;
 961   3                      case 0x9285:
 962   3                      {
 963   4                              if (batterySet.batteryType == XJ24)
 964   4                              {
 965   5                                      write_dgus_vp(0x9265, (uint8_t *)variable, 1);
 966   5                              }
 967   4                              else if (batterySet.batteryType == XJ55)
 968   4                              {
 969   5                                      write_dgus_vp(0x9275, (uint8_t *)variable, 1);
 970   5                              }
 971   4                      }
 972   3                      break;
 973   3                      case 0x9286:
 974   3                      {
 975   4                              if (batterySet.batteryType == XJ24)
 976   4                              {
 977   5                                      write_dgus_vp(0x9266, (uint8_t *)variable, 1);
 978   5                              }
 979   4                              else if (batterySet.batteryType == XJ55)
 980   4                              {
 981   5                                      write_dgus_vp(0x9276, (uint8_t *)variable, 1);
 982   5                              }
 983   4                      }
 984   3                      break;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 17  

 985   3                      default:
 986   3                              break;
 987   3                      }
 988   2                      // memset(variable, 0, 5);
 989   2                      // write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 990   2                      variableChangedIndication.flag = 0;
 991   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 992   2              }
 993   1              {
 994   2                      if (batterySet.batteryType == XJ24)
 995   2                      {
 996   3                              uint16_t sp; // 描述指针
 997   3                              sp = 0x9260;
 998   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
 999   3                              sp = 0x9261;
1000   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
1001   3                              sp = 0x9262;
1002   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
1003   3                              sp = 0x9263;
1004   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
1005   3                              sp = 0x9264;
1006   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
1007   3                              sp = 0x9265;
1008   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
1009   3                              sp = 0x9266;
1010   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
1011   3                      }
1012   2                      else if (batterySet.batteryType == XJ55)
1013   2                      {
1014   3                              uint16_t sp; // 描述指针
1015   3                              sp = 0x9270;
1016   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
1017   3                              sp = 0x9271;
1018   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
1019   3                              sp = 0x9272;
1020   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
1021   3                              sp = 0x9273;
1022   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
1023   3                              sp = 0x9274;
1024   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
1025   3                              sp = 0x9275;
1026   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
1027   3                              sp = 0x9276;
1028   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
1029   3                      }
1030   2              }
1031   1      }
1032          
1033          void p42Func()
1034          {
1035   1              VariableChangedIndicationTypeDef variableChangedIndication;
1036   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1037   1              if (variableChangedIndication.flag == 0x5A)
1038   1              {
1039   2                      uint16_t variable[5];
1040   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1041   2                      switch (variableChangedIndication.addr)
1042   2                      {
1043   3                      case 0x8140:
1044   3                              if (variable[0] == 1)
1045   3                              {
1046   4                                      read_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 18  

1047   4                                      dgusToNorFlash(INSULATION_SET_NORFLASH_ADDR, INSULATION_SET_VP, INSULATION_SET_SIZE);
1048   4                                      modbusCenerate();
1049   4                              }
1050   3                              break;
1051   3                      
1052   3                      case 0x92C1:
1053   3                      {
1054   4                              static MMODBUS AC_BusAlarm;
1055   4                              AC_BusAlarm.SlaveAddr = 0x32;
1056   4                              AC_BusAlarm.mode = 0x00;
1057   4                              AC_BusAlarm.flag = 0x00;
1058   4                              AC_BusAlarm.Order = 0x06;
1059   4                              AC_BusAlarm.Length = 1;
1060   4                              AC_BusAlarm.reserved = 0;
1061   4                              AC_BusAlarm.waitTime = 1000;
1062   4                              AC_BusAlarm.VPaddr = 0x92C1;
1063   4                              AC_BusAlarm.ModbusReg = 0x03;
1064   4                              AC_BusAlarm.databuff = NULL;
1065   4                              pushToEmergency(&AC_BusAlarm);
1066   4                      }
1067   3      
1068   3                      default:
1069   3                              break;
1070   3                      }
1071   2                      memset(variable, 0, 5);
1072   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1073   2                      variableChangedIndication.flag = 0;
1074   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1075   2              }
1076   1              {
1077   2                      write_dgus_vp(0x92C0,(uint8_t*)&AC_Insulation.alarmValue,1);
1078   2              }
1079   1      }
1080          
1081          void p44Func()
1082          {
1083   1              VariableChangedIndicationTypeDef variableChangedIndication;
1084   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1085   1              if (variableChangedIndication.flag == 0x5A)
1086   1              {
1087   2                      uint16_t variable[5];
1088   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1089   2                      switch (variableChangedIndication.addr)
1090   2                      {
1091   3                      case 0x8160:
1092   3                              if (variable[0] == 1)
1093   3                              {
1094   4                                      read_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
1095   4                                      dgusToNorFlash(CHARGE_MODULE_SET_NORFLASH_ADDR, CHARGE_MODULE_SET_VP, CHARGE_MODULE_SET_SIZE);
1096   4                                      modbusCenerate();
1097   4                              }
1098   3                              break;
1099   3      
1100   3                      default:
1101   3                              break;
1102   3                      }
1103   2                      memset(variable, 0, 5);
1104   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1105   2                      variableChangedIndication.flag = 0;
1106   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1107   2              }
1108   1      }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 19  

1109          
1110          void p48Func()
1111          {
1112   1              VariableChangedIndicationTypeDef variableChangedIndication;
1113   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1114   1              if (variableChangedIndication.flag == 0x5A)
1115   1              {
1116   2                      uint16_t variable[5];
1117   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1118   2                      switch (variableChangedIndication.addr)
1119   2                      {
1120   3                      case 0x8180:
1121   3                              if (variable[0] == 1)
1122   3                              {
1123   4                                      read_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
1124   4                                      dgusToNorFlash(DC_CONVERTER_SET_NORFLASH_ADDR, DC_CONVERTER_SET_VP, DC_CONVERTER_SET_SIZE);
1125   4                                      modbusCenerate();
1126   4                              }
1127   3                              break;
1128   3                      case 0x9360:
1129   3                              if (variable[0] == 1)
1130   3                              {
1131   4                                      if (DC_ConverterSet.Num > 0)
1132   4                                      {
1133   5                                              static MMODBUS DC_moduleOnOffCmd;
1134   5                                              static uint16_t DC_module_DI;
1135   5                                              dc_4850_Module[0].DI.onOffState = !dc_4850_Module[0].DI.onOffState;
1136   5                                              DC_module_DI = dc_4850_Module[0].DI.onOffState;
1137   5                                              DC_moduleOnOffCmd.SlaveAddr = 0xFE;
1138   5                                              DC_moduleOnOffCmd.mode = 0x00;
1139   5                                              DC_moduleOnOffCmd.flag = 0x00;
1140   5                                              DC_moduleOnOffCmd.Order = 0x06;
1141   5                                              DC_moduleOnOffCmd.Length = 1;
1142   5                                              DC_moduleOnOffCmd.reserved = 0x00;
1143   5                                              DC_moduleOnOffCmd.waitTime = 1000;
1144   5                                              DC_moduleOnOffCmd.VPaddr = 0;
1145   5                                              DC_moduleOnOffCmd.ModbusReg = 0x0005;
1146   5                                              DC_moduleOnOffCmd.databuff = &DC_module_DI;
1147   5                                              pushToEmergency(&DC_moduleOnOffCmd);
1148   5                                      }
1149   4                              }
1150   3                              break;
1151   3      
1152   3                      default:
1153   3                              break;
1154   3                      }
1155   2                      memset(variable, 0, 5);
1156   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1157   2                      variableChangedIndication.flag = 0;
1158   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1159   2              }
1160   1              {
1161   2                      uint16_t DC_Module_OnOffState = dc_4850_Module[0].DI.onOffState ? 1 : 0;
1162   2                      write_dgus_vp(0x9361, (uint8_t *)&DC_Module_OnOffState, 1);
1163   2              }
1164   1      }
1165          
1166          void p50Func()
1167          {
1168   1              VariableChangedIndicationTypeDef variableChangedIndication;
1169   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1170   1              if (variableChangedIndication.flag == 0x5A)
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 20  

1171   1              {
1172   2                      uint16_t variable[5];
1173   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1174   2                      switch (variableChangedIndication.addr)
1175   2                      {
1176   3                      case 0x81A0:
1177   3                              if (variable[0] == 1)
1178   3                              {
1179   4                                      read_dgus_vp(UPS_INV_SET_VP, (uint8_t *)&UPS_INV_Set, UPS_INV_SET_SIZE);
1180   4                                      dgusToNorFlash(UPS_INV_SET_NORFLASH_ADDR, UPS_INV_SET_VP, UPS_INV_SET_SIZE);
1181   4                                      modbusCenerate();
1182   4                              }
1183   3                              break;
1184   3      
1185   3                      default:
1186   3                              break;
1187   3                      }
1188   2                      memset(variable, 0, 5);
1189   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1190   2                      variableChangedIndication.flag = 0;
1191   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1192   2              }
1193   1      }
1194          
1195          void recovery(void)
1196          {
1197   1              AC_InfoSet.AC_InputChannel = 1;
1198   1              AC_InfoSet.threePhaseAC_VolMax = 4500;
1199   1              AC_InfoSet.threePhaseAC_VolMin = 3230;
1200   1              AC_InfoSet.singlePhaseAC_VolMax = 2800;
1201   1              AC_InfoSet.singlePhaseAC_VolMin = 1870;
1202   1              Nor_Flash_write(AC_INFO_NORFLASH_ADDR, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1203   1              write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1204   1      
1205   1              // DC_InfoSet.busVoltMax_220V = 2600;
1206   1              // DC_InfoSet.busVoltMin_220V = 2000;
1207   1              // DC_InfoSet.moduleVoltMax_220V = 2420;
1208   1              // DC_InfoSet.moduleVoltMin_220V = 2000;
1209   1              // DC_InfoSet.busVoltMax_110V = 1300;
1210   1              // DC_InfoSet.busVoltMin_110V = 1000;
1211   1              // DC_InfoSet.moduleVoltMax_110V = 1200;
1212   1              // DC_InfoSet.moduleVoltMin_110V = 1000;
1213   1              DC_InfoSet.loadHallRatio = 1000;
1214   1              DC_InfoSet.batteryHallRatio = 1000;
1215   1              Nor_Flash_write(DC_INFO_NORFLASH_ADDR, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1216   1              write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1217   1      }
1218          
1219          void p52Func()
1220          {
1221   1              VariableChangedIndicationTypeDef variableChangedIndication;
1222   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1223   1              if (variableChangedIndication.flag == 0x5A)
1224   1              {
1225   2                      uint16_t variable[5];
1226   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1227   2                      switch (variableChangedIndication.addr)
1228   2                      {
1229   3                      case 0x9400:
1230   3                              if (variable[0] == 1)
1231   3                              {
1232   4                                      recovery();
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 21  

1233   4                              }
1234   3                              break;
1235   3                      case 0x9401:
1236   3                              if (variable[0] == 1)
1237   3                              {
1238   4                                      // 清楚记录
1239   4                              }
1240   3                              break;
1241   3                      case 0x9402:
1242   3                              if (variable[0] == 1)
1243   3                              {
1244   4                                      // 重启触摸屏
1245   4                                      write_dgus_vp(0x04, (uint8_t *)"\x55\xAA\x5A\xA5", 2);
1246   4                              }
1247   3                              break;
1248   3      
1249   3                      default:
1250   3                              break;
1251   3                      }
1252   2                      memset(variable, 0, 5);
1253   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1254   2                      variableChangedIndication.flag = 0;
1255   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1256   2              }
1257   1      }
1258          
1259          void p68Func(void)
1260          {
1261   1      
1262   1              if (AC_InfoSet.singlePhaseThreePhaseSelection == THREE_PHASE)
1263   1              {
1264   2                      uint16_t sp;
1265   2                      sp = 0x94A0;
1266   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1267   2                      // sp = 0x94A0;
1268   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1269   2                      sp = 0x94A1;
1270   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1271   2                      sp = 0x94A3;
1272   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1273   2                      // sp = 0x94A4;
1274   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1275   2                      sp = 0x94A5;
1276   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
1277   2      
1278   2                      write_dgus_vp(0x94A0, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 6);
1279   2              }
1280   1              else if (AC_InfoSet.singlePhaseThreePhaseSelection == SINGLE_PHASE)
1281   1              {
1282   2                      uint16_t sp;
1283   2                      sp = 0xFFFF;
1284   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1285   2                      // sp = 0x94A0;
1286   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1287   2                      sp = 0xFFFF;
1288   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1289   2                      sp = 0xFFFF;
1290   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1291   2                      // sp = 0x94A4;
1292   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1293   2                      sp = 0xFFFF;
1294   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 22  

1295   2      
1296   2                      write_dgus_vp(0x94A1, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1297   2                      write_dgus_vp(0x94A4, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1298   2              }
1299   1      }
1300          
1301          void p70Func(void)
1302          {
1303   1              {
1304   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1305   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1306   2                      if (variableChangedIndication.flag == 0x5A)
1307   2                      {
1308   3                              uint16_t variable[5];
1309   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1310   3                              switch (variableChangedIndication.addr)
1311   3                              {
1312   4                              case 0x9530:
1313   4                                      if (variable[0] == 1)
1314   4                                      {
1315   5                                              if (chargeModuleSet.moduleNum >= 1)
1316   5                                              {
1317   6                                                      static MMODBUS chargeModuleOnOff = {0x01, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9540, 0x06, NULL};
1318   6                                                      chargeModule[0].DI.onOffState = !chargeModule[0].DI.onOffState;
1319   6                                                      write_dgus_vp(0x9540, (uint8_t *)&chargeModule[0].DI, 1);
1320   6                                                      pushToEmergency(&chargeModuleOnOff);
1321   6                                              }
1322   5                                      }
1323   4                                      break;
1324   4                              case 0x9531:
1325   4                                      if (variable[0] == 1)
1326   4                                      {
1327   5                                              if (chargeModuleSet.moduleNum >= 2)
1328   5                                              {
1329   6                                                      static MMODBUS chargeModuleOnOff = {0x02, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9541, 0x06, NULL};
1330   6                                                      chargeModule[1].DI.onOffState = !chargeModule[1].DI.onOffState;
1331   6                                                      write_dgus_vp(0x9541, (uint8_t *)&chargeModule[1].DI, 1);
1332   6                                                      pushToEmergency(&chargeModuleOnOff);
1333   6                                              }
1334   5                                      }
1335   4                                      break;
1336   4                              case 0x9532:
1337   4                                      if (variable[0] == 1)
1338   4                                      {
1339   5                                              if (chargeModuleSet.moduleNum >= 3)
1340   5                                              {
1341   6                                                      static MMODBUS chargeModuleOnOff = {0x03, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9542, 0x06, NULL};
1342   6                                                      chargeModule[2].DI.onOffState = !chargeModule[2].DI.onOffState;
1343   6                                                      write_dgus_vp(0x9542, (uint8_t *)&chargeModule[2].DI, 1);
1344   6                                                      pushToEmergency(&chargeModuleOnOff);
1345   6                                              }
1346   5                                      }
1347   4                                      break;
1348   4                              case 0x9533:
1349   4                                      if (variable[0] == 1)
1350   4                                      {
1351   5                                              if (chargeModuleSet.moduleNum >= 4)
1352   5                                              {
1353   6                                                      static MMODBUS chargeModuleOnOff = {0x04, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9543, 0x06, NULL};
1354   6                                                      chargeModule[3].DI.onOffState = !chargeModule[3].DI.onOffState;
1355   6                                                      write_dgus_vp(0x9543, (uint8_t *)&chargeModule[3].DI, 1);
1356   6                                                      pushToEmergency(&chargeModuleOnOff);
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 23  

1357   6                                              }
1358   5                                      }
1359   4                                      break;
1360   4                              case 0x9534:
1361   4                                      if (variable[0] == 1)
1362   4                                      {
1363   5                                              if (chargeModuleSet.moduleNum >= 5)
1364   5                                              {
1365   6                                                      static MMODBUS chargeModuleOnOff = {0x05, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9544, 0x06, NULL};
1366   6                                                      chargeModule[4].DI.onOffState = !chargeModule[4].DI.onOffState;
1367   6                                                      write_dgus_vp(0x9544, (uint8_t *)&chargeModule[4].DI, 1);
1368   6                                                      pushToEmergency(&chargeModuleOnOff);
1369   6                                              }
1370   5                                      }
1371   4                                      break;
1372   4                              case 0x9535:
1373   4                                      if (variable[0] == 1)
1374   4                                      {
1375   5                                              if (chargeModuleSet.moduleNum >= 6)
1376   5                                              {
1377   6                                                      static MMODBUS chargeModuleOnOff = {0x06, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9545, 0x06, NULL};
1378   6                                                      chargeModule[5].DI.onOffState = !chargeModule[5].DI.onOffState;
1379   6                                                      write_dgus_vp(0x9545, (uint8_t *)&chargeModule[5].DI, 1);
1380   6                                                      pushToEmergency(&chargeModuleOnOff);
1381   6                                              }
1382   5                                      }
1383   4                                      break;
1384   4                              case 0x9536:
1385   4                                      if (variable[0] == 1)
1386   4                                      {
1387   5                                              if (chargeModuleSet.moduleNum >= 7)
1388   5                                              {
1389   6                                                      static MMODBUS chargeModuleOnOff = {0x07, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9546, 0x06, NULL};
1390   6                                                      chargeModule[6].DI.onOffState = !chargeModule[6].DI.onOffState;
1391   6                                                      write_dgus_vp(0x9546, (uint8_t *)&chargeModule[6].DI, 1);
1392   6                                                      pushToEmergency(&chargeModuleOnOff);
1393   6                                              }
1394   5                                      }
1395   4                                      break;
1396   4                              case 0x9537:
1397   4                                      if (variable[0] == 1)
1398   4                                      {
1399   5                                              if (chargeModuleSet.moduleNum >= 8)
1400   5                                              {
1401   6                                                      static MMODBUS chargeModuleOnOff = {0x08, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9547, 0x06, NULL};
1402   6                                                      chargeModule[7].DI.onOffState = !chargeModule[7].DI.onOffState;
1403   6                                                      write_dgus_vp(0x9547, (uint8_t *)&chargeModule[7].DI, 1);
1404   6                                                      pushToEmergency(&chargeModuleOnOff);
1405   6                                              }
1406   5                                      }
1407   4                                      break;
1408   4      
1409   4                              default:
1410   4                                      break;
1411   4                              }
1412   3                              memset(variable, 0, 5);
1413   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1414   3                              variableChangedIndication.flag = 0;
1415   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1416   3                      }
1417   2              }
1418   1              {
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 24  

1419   2                      if (chargeModuleSet.moduleNum >= 1)
1420   2                      {
1421   3                              write_dgus_vp(0x9500, (uint8_t *)&chargeModule[0].outputVolt, 3);
1422   3                              write_dgus_vp(0x9503, (uint8_t *)&chargeModule[0].DI, 1);
1423   3                              // {
1424   3                              //      uint16_t temp = chargeModule.onOffState;
1425   3                              //      write_dgus_vp(0x9503, (uint8_t *)&temp, 1);
1426   3                              // }
1427   3                              {
1428   4                                      uint16_t temp = 0;
1429   4                                      write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1430   4                              }
1431   3                      }
1432   2                      else
1433   2                      {
1434   3                              uint16_t temp = 1;
1435   3                              write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1436   3                      }
1437   2                      if (chargeModuleSet.moduleNum >= 2)
1438   2                      {
1439   3                              write_dgus_vp(0x9504, (uint8_t *)&chargeModule[1].outputVolt, 3);
1440   3                              write_dgus_vp(0x9507, (uint8_t *)&chargeModule[1].DI, 1);
1441   3                              // {
1442   3                              //      uint16_t temp = chargeModule[1].DI.onOffState;
1443   3                              //      write_dgus_vp(0x9507, (uint8_t *)&temp, 1);
1444   3                              // }
1445   3                              {
1446   4                                      uint16_t temp = 0;
1447   4                                      write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
1448   4                              }
1449   3                      }
1450   2                      else
1451   2                      {
1452   3                              uint16_t temp = 1;
1453   3                              write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
1454   3                      }
1455   2                      if (chargeModuleSet.moduleNum >= 3)
1456   2                      {
1457   3                              write_dgus_vp(0x9508, (uint8_t *)&chargeModule[2].outputVolt, 3);
1458   3                              write_dgus_vp(0x950B, (uint8_t *)&chargeModule[2].DI, 1);
1459   3                              // {
1460   3                              //      uint16_t temp = chargeModule[2].DI.onOffState;
1461   3                              //      write_dgus_vp(0x950B, (uint8_t *)&temp, 1);
1462   3                              // }
1463   3                              {
1464   4                                      uint16_t temp = 0;
1465   4                                      write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1466   4                              }
1467   3                      }
1468   2                      else
1469   2                      {
1470   3                              uint16_t temp = 1;
1471   3                              write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1472   3                      }
1473   2                      if (chargeModuleSet.moduleNum >= 4)
1474   2                      {
1475   3                              write_dgus_vp(0x950C, (uint8_t *)&chargeModule[3].outputVolt, 3);
1476   3                              write_dgus_vp(0x950F, (uint8_t *)&chargeModule[3].DI, 1);
1477   3                              // {
1478   3                              //      uint16_t temp = chargeModule[3].DI.onOffState;
1479   3                              //      write_dgus_vp(0x950F, (uint8_t *)&temp, 1);
1480   3                              // }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 25  

1481   3                              {
1482   4                                      uint16_t temp = 0;
1483   4                                      write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1484   4                              }
1485   3                      }
1486   2                      else
1487   2                      {
1488   3                              uint16_t temp = 1;
1489   3                              write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1490   3                      }
1491   2                      if (chargeModuleSet.moduleNum >= 5)
1492   2                      {
1493   3                              write_dgus_vp(0x9510, (uint8_t *)&chargeModule[4].outputVolt, 3);
1494   3                              write_dgus_vp(0x9513, (uint8_t *)&chargeModule[4].DI, 1);
1495   3                              // {
1496   3                              //      uint16_t temp = chargeModule[4].DI.onOffState;
1497   3                              //      write_dgus_vp(0x9513, (uint8_t *)&temp, 1);
1498   3                              // }
1499   3                              {
1500   4                                      uint16_t temp = 0;
1501   4                                      write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1502   4                              }
1503   3                      }
1504   2                      else
1505   2                      {
1506   3                              uint16_t temp = 1;
1507   3                              write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1508   3                      }
1509   2                      if (chargeModuleSet.moduleNum >= 6)
1510   2                      {
1511   3                              write_dgus_vp(0x9514, (uint8_t *)&chargeModule[5].outputVolt, 3);
1512   3                              write_dgus_vp(0x9517, (uint8_t *)&chargeModule[5].DI, 1);
1513   3                              // {
1514   3                              //      uint16_t temp = chargeModule[5].DI.onOffState;
1515   3                              //      write_dgus_vp(0x9517, (uint8_t *)&temp, 1);
1516   3                              // }
1517   3                              {
1518   4                                      uint16_t temp = 0;
1519   4                                      write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1520   4                              }
1521   3                      }
1522   2                      else
1523   2                      {
1524   3                              uint16_t temp = 1;
1525   3                              write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1526   3                      }
1527   2                      if (chargeModuleSet.moduleNum >= 7)
1528   2                      {
1529   3                              write_dgus_vp(0x9518, (uint8_t *)&chargeModule[6].outputVolt, 3);
1530   3                              write_dgus_vp(0x951B, (uint8_t *)&chargeModule[6].DI, 1);
1531   3                              // {
1532   3                              //      uint16_t temp = chargeModule[6].DI.onOffState;
1533   3                              //      write_dgus_vp(0x951B, (uint8_t *)&temp, 1);
1534   3                              // }
1535   3                              {
1536   4                                      uint16_t temp = 0;
1537   4                                      write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1538   4                              }
1539   3                      }
1540   2                      else
1541   2                      {
1542   3                              uint16_t temp = 1;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 26  

1543   3                              write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1544   3                      }
1545   2                      if (chargeModuleSet.moduleNum >= 8)
1546   2                      {
1547   3                              write_dgus_vp(0x951C, (uint8_t *)&chargeModule[7].outputVolt, 3);
1548   3                              write_dgus_vp(0x951F, (uint8_t *)&chargeModule[7].DI, 1);
1549   3                              // {
1550   3                              //      uint16_t temp = chargeModule[7].DI.onOffState;
1551   3                              //      write_dgus_vp(0x951F, (uint8_t *)&temp, 1);
1552   3                              // }
1553   3                              {
1554   4                                      uint16_t temp = 0;
1555   4                                      write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
1556   4                              }
1557   3                      }
1558   2                      else
1559   2                      {
1560   3                              uint16_t temp = 1;
1561   3                              write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
1562   3                      }
1563   2              }
1564   1      }
1565          
1566          void p72Func(void)
1567          {
1568   1              uint16_t swState;
1569   1              uint16_t i;
1570   1              for (i = 0; i < switchModuleSet.synthesisCollection.alarmChannelNum; i++)
1571   1              {
1572   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1573   2                      {
1574   3                              swState = NORMAL;
1575   3                      }
1576   2                      else
1577   2                      {
1578   3                              swState = FAULT;
1579   3                      }
1580   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1581   2              }
1582   1              for (; i < 12; i++)
1583   1              {
1584   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1585   2                      {
1586   3                              swState = CLOSING;
1587   3                      }
1588   2                      else
1589   2                      {
1590   3                              swState = OPENING;
1591   3                      }
1592   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1593   2              }
1594   1              for (; i < 13; i++)
1595   1              {
1596   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1597   2                      {
1598   3                              swState = NORMAL;
1599   3                      }
1600   2                      else
1601   2                      {
1602   3                              swState = FAULT;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 27  

1603   3                      }
1604   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1605   2              }
1606   1              for (; i < 15; i++)
1607   1              {
1608   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1609   2                      {
1610   3                              swState = CLOSING;
1611   3                      }
1612   2                      else
1613   2                      {
1614   3                              swState = OPENING;
1615   3                      }
1616   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1617   2              }
1618   1      }
1619          
1620          void p75Func(void)
1621          {
1622   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1623   1              {
1624   2                      uint16_t i;
1625   2                      for (i = 0; i < 16; i++)
1626   2                      {
1627   3                              uint16_t swState;
1628   3                              swState = (remoteControlModule_ARD[0].sw1to16 >> i) & 0x01;
1629   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1630   3                      }
1631   2              }
1632   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1633   1              {
1634   2                      uint16_t i;
1635   2                      for (i = 0; i < 16; i++)
1636   2                      {
1637   3                              uint16_t swState;
1638   3                              swState = (remoteControlModule_TH[0].sw1to16 >> i) & 0x01;
1639   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1640   3                      }
1641   2              }
1642   1              {
1643   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1644   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1645   2                      if (variableChangedIndication.flag == 0x5A)
1646   2                      {
1647   3                              uint16_t variable[5];
1648   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1649   3                              switch (variableChangedIndication.addr)
1650   3                              {
1651   4                              case 0x9760:
1652   4                              case 0x9761:
1653   4                              case 0x9762:
1654   4                              case 0x9763:
1655   4                              case 0x9764:
1656   4                              case 0x9765:
1657   4                              case 0x9766:
1658   4                              case 0x9767:
1659   4                              case 0x9768:
1660   4                              case 0x9769:
1661   4                              case 0x976A:
1662   4                              case 0x976B:
1663   4                              case 0x976C:
1664   4                              case 0x976D:
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 28  

1665   4                              case 0x976E:
1666   4                              case 0x976F:
1667   4                              {
1668   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1669   5                                      {
1670   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
1671   6                                              if (variable[0] == 0)
1672   6                                              {
1673   7                                                      static MMODBUS rtuSwOff[16];
1674   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1675   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
1676   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1677   7                                                      rtuSwOff[offset].mode = 0x00;
1678   7                                                      rtuSwOff[offset].flag = 0x00;
1679   7                                                      rtuSwOff[offset].Order = 0x06;
1680   7                                                      rtuSwOff[offset].Length = 0x01;
1681   7                                                      rtuSwOff[offset].reserved = 0x00;
1682   7                                                      rtuSwOff[offset].waitTime = 1000;
1683   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
1684   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
1685   7                                                      rtuSwOff[offset].databuff = NULL;
1686   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1687   7                                                      pushToEmergency(rtuSwOff + offset);
1688   7                                              }
1689   6                                              else if (variable[0] == 1)
1690   6                                              {
1691   7                                                      static MMODBUS rtuSwOn[16];
1692   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1693   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
1694   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1695   7                                                      rtuSwOn[offset].mode = 0x00;
1696   7                                                      rtuSwOn[offset].flag = 0x00;
1697   7                                                      rtuSwOn[offset].Order = 0x06;
1698   7                                                      rtuSwOn[offset].Length = 0x01;
1699   7                                                      rtuSwOn[offset].reserved = 0x00;
1700   7                                                      rtuSwOn[offset].waitTime = 1000;
1701   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1702   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
1703   7                                                      rtuSwOn[offset].databuff = NULL;
1704   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1705   7                                                      pushToEmergency(rtuSwOn + offset);
1706   7                                              }
1707   6                                      }
1708   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1709   5                                      {
1710   6                                              if (variable[0] == 0)
1711   6                                              {
1712   7                                                      static MMODBUS rtuSwOff[16];
1713   7                                                      uint16_t OffVal = 0x0000;
1714   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1715   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1716   7                                                      rtuSwOff[offset].mode = 0x00;
1717   7                                                      rtuSwOff[offset].flag = 0x00;
1718   7                                                      rtuSwOff[offset].Order = 0x06;
1719   7                                                      rtuSwOff[offset].Length = 0x01;
1720   7                                                      rtuSwOff[offset].reserved = 0x00;
1721   7                                                      rtuSwOff[offset].waitTime = 1000;
1722   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
1723   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
1724   7                                                      rtuSwOff[offset].databuff = NULL;
1725   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OffVal, 1);
1726   7                                                      pushToEmergency(rtuSwOff + offset);
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 29  

1727   7                                              }
1728   6                                              else if (variable[0] == 1)
1729   6                                              {
1730   7                                                      static MMODBUS rtuSwOn[16];
1731   7                                                      uint16_t OnVal = 0xFFFF;
1732   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1733   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1734   7                                                      rtuSwOn[offset].mode = 0x00;
1735   7                                                      rtuSwOn[offset].flag = 0x00;
1736   7                                                      rtuSwOn[offset].Order = 0x06;
1737   7                                                      rtuSwOn[offset].Length = 0x01;
1738   7                                                      rtuSwOn[offset].reserved = 0x00;
1739   7                                                      rtuSwOn[offset].waitTime = 1000;
1740   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1741   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
1742   7                                                      rtuSwOn[offset].databuff = NULL;
1743   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OnVal, 1);
1744   7                                                      pushToEmergency(rtuSwOn + offset);
1745   7                                              }
1746   6                                      }
1747   5                              }
1748   4                              break;
1749   4      
1750   4                              default:
1751   4                                      break;
1752   4                              }
1753   3                              memset(variable, 0, 5);
1754   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1755   3                              variableChangedIndication.flag = 0;
1756   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1757   3                      }
1758   2              }
1759   1      }
1760          
1761          void p76Func(void)
1762          {
1763   1              uint16_t swState;
1764   1              uint16_t i;
1765   1              for (i = 0; i < 30; i++)
1766   1              {
1767   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[0])
1768   2                      {
1769   3                              if ((switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[0]
             -)
1770   3                              {
1771   4                                      swState = NORMAL;
1772   4                              }
1773   3                              else
1774   3                              {
1775   4                                      swState = FAULT;
1776   4                              }
1777   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1778   3                      }
1779   2                      else
1780   2                      {
1781   3                              if (switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001)
1782   3                              {
1783   4                                      swState = CLOSING;
1784   4                              }
1785   3                              else
1786   3                              {
1787   4                                      swState = OPENING;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 30  

1788   4                              }
1789   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1790   3                      }
1791   2              }
1792   1      }
1793          
1794          void p77Func(void)
1795          {
1796   1              uint16_t swState;
1797   1              uint16_t i;
1798   1              for (i = 0; i < 30; i++)
1799   1              {
1800   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[1])
1801   2                      {
1802   3                              if ((switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[1]
             -)
1803   3                              {
1804   4                                      swState = NORMAL;
1805   4                              }
1806   3                              else
1807   3                              {
1808   4                                      swState = FAULT;
1809   4                              }
1810   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1811   3                      }
1812   2                      else
1813   2                      {
1814   3                              if (switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001)
1815   3                              {
1816   4                                      swState = CLOSING;
1817   4                              }
1818   3                              else
1819   3                              {
1820   4                                      swState = OPENING;
1821   4                              }
1822   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1823   3                      }
1824   2              }
1825   1      }
1826          
1827          void p78Func(void)
1828          {
1829   1              uint16_t swState;
1830   1              uint16_t i;
1831   1              for (i = 0; i < 30; i++)
1832   1              {
1833   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[2])
1834   2                      {
1835   3                              if ((switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[2]
             -)
1836   3                              {
1837   4                                      swState = NORMAL;
1838   4                              }
1839   3                              else
1840   3                              {
1841   4                                      swState = FAULT;
1842   4                              }
1843   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1844   3                      }
1845   2                      else
1846   2                      {
1847   3                              if (switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001)
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 31  

1848   3                              {
1849   4                                      swState = CLOSING;
1850   4                              }
1851   3                              else
1852   3                              {
1853   4                                      swState = OPENING;
1854   4                              }
1855   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1856   3                      }
1857   2              }
1858   1      }
1859          void p79Func(void)
1860          {
1861   1              uint16_t swState;
1862   1              uint16_t i;
1863   1              for (i = 0; i < 30; i++)
1864   1              {
1865   2                      if (i < switchModuleSet.switchModule.alarmChannelNum[3])
1866   2                      {
1867   3                              if ((switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.accessMode[3]
             -)
1868   3                              {
1869   4                                      swState = NORMAL;
1870   4                              }
1871   3                              else
1872   3                              {
1873   4                                      swState = FAULT;
1874   4                              }
1875   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
1876   3                      }
1877   2                      else
1878   2                      {
1879   3                              if (switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001)
1880   3                              {
1881   4                                      swState = CLOSING;
1882   4                              }
1883   3                              else
1884   3                              {
1885   4                                      swState = OPENING;
1886   4                              }
1887   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
1888   3                      }
1889   2              }
1890   1      }
1891          
1892          void p80Func(void)
1893          {
1894   1              write_dgus_vp(0x9800, (uint8_t *)&synthesisCollection.closeBusVolt, 1);
1895   1      
1896   1              write_dgus_vp(0x9801, (uint8_t *)&synthesisCollection.controlBusVolt, 1);
1897   1      
1898   1              write_dgus_vp(0x9802, (uint8_t *)&synthesisCollection.controlBusCurr, 1);
1899   1      
1900   1              write_dgus_vp(0x9803, (uint8_t *)&synthesisCollection.batteryVolt, 1);
1901   1      
1902   1              write_dgus_vp(0x9804, (uint8_t *)&synthesisCollection.batteryCurr, 1);
1903   1      }
1904          
1905          void p82Func(void)
1906          {
1907   1              if (UPS_INV_Set.UPS_Num >= 1)
1908   1              {
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 32  

1909   2                      write_dgus_vp(0x9850, (uint8_t *)&ups[0].remoteMeasurement, 11);
1910   2                      write_dgus_vp(0x985B, (uint8_t *)&ups[0].remoteSignal, 1);
1911   2              }
1912   1              if (UPS_INV_Set.UPS_Num >= 2)
1913   1              {
1914   2                      write_dgus_vp(0x9860, (uint8_t *)&ups[1].remoteMeasurement, 11);
1915   2                      write_dgus_vp(0x986B, (uint8_t *)&ups[1].remoteSignal, 1);
1916   2              }
1917   1              {
1918   2                      uint16_t ups2Hide;
1919   2                      ups2Hide = (UPS_INV_Set.UPS_Num < 2) ? 1 : 0;
1920   2                      write_dgus_vp(0x9880, (uint8_t *)&ups2Hide, 1);
1921   2              }
1922   1      }
1923          
1924          void p85Func(void)
1925          {
1926   1              if (UPS_INV_Set.INV_Num >= 1)
1927   1              {
1928   2                      write_dgus_vp(0x98A0, (uint8_t *)&inv[0], 21);
1929   2              }
1930   1              if (UPS_INV_Set.INV_Num >= 2)
1931   1              {
1932   2                      write_dgus_vp(0x98C0, (uint8_t *)&inv[1], 21);
1933   2              }
1934   1              {
1935   2                      uint16_t inv2Hide;
1936   2                      inv2Hide = (UPS_INV_Set.INV_Num < 2) ? 1 : 0;
1937   2                      write_dgus_vp(0x98E0, (uint8_t *)&inv2Hide, 1);
1938   2              }
1939   1      }
1940          
1941          void p86Func(void)
1942          {
1943   1              uint16_t i;
1944   1              for (i = 0; i < DC_ConverterSet.Num; i++)
1945   1              {
1946   2                      uint16_t faultSta;
1947   2                      uint16_t protectSta;
1948   2                      write_dgus_vp(0x9900 + i, (uint8_t *)&dc_4850_Module[i].outputVolt, 1);
1949   2                      write_dgus_vp(0x9910 + i, (uint8_t *)&dc_4850_Module[i].outputCurr, 1);
1950   2                      faultSta = dc_4850_Module[i].DI.faultState;
1951   2                      write_dgus_vp(0x9920 + i, (uint8_t *)&faultSta, 1);
1952   2                      protectSta = dc_4850_Module[i].DI.protectState;
1953   2                      write_dgus_vp(0x9930 + i, (uint8_t *)&protectSta, 1);
1954   2              }
1955   1              for (i = 0; i < DC4850MODULE_MAX; i++)
1956   1              {
1957   2                      uint16_t DC_hide;
1958   2                      DC_hide = (i >= DC_ConverterSet.Num) ? 1 : 0;
1959   2                      write_dgus_vp(0x9940 + i, (uint8_t *)&DC_hide, 1);
1960   2              }
1961   1      }
1962          
1963          void p87Func(void)
1964          {
1965   1              uint16_t i;
1966   1              for (i = 0; i < 30; i++)
1967   1              {
1968   2                      int16_t insulationRes;
1969   2                      insulationRes = DC_Insulation[0].res[i];
1970   2                      insulationRes += i < insulationSet.DC.closeBus_1_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 33  

1971   2                      write_dgus_vp(0x9950 + i, (uint8_t *)&insulationRes, 1);
1972   2                      if (AC_Insulation.positiveBusToGroundVolt || AC_Insulation.negativeBusToGroundVolt)
1973   2                      {
1974   3                              uint16_t temp = 1;
1975   3                              if (insulationRes <= insulationSet.DC.resAlarm)
1976   3                              {
1977   4                                      temp = 0;
1978   4                              }
1979   3                              write_dgus_vp(0x9970 + i, (uint8_t *)&temp, 1);
1980   3                      }
1981   2              }
1982   1      
1983   1              if (sysInfoSet.siliconChain == 1)
1984   1              {
1985   2                      int16_t temp;
1986   2                      temp = DC_Insulation[0].closeBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
1987   2                      write_dgus_vp(0x9990, (uint8_t *)&temp, 1);
1988   2      
1989   2                      temp = DC_Insulation[0].controlBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
1990   2                      write_dgus_vp(0x9991, (uint8_t *)&temp, 1);
1991   2              }
1992   1              else if (sysInfoSet.siliconChain == 0)
1993   1              {
1994   2                      int32_t batteryVoltSum;   // 电池巡检电压总和
1995   2                      int32_t chargeModuleVolt; // 充电模块电压
1996   2                      int16_t displayVolt;
1997   2                      uint16_t i;
1998   2      
1999   2                      read_dgus_vp(0xb020, (uint8_t *)&batteryVoltSum, 1);
2000   2      
2001   2                      chargeModuleVolt = 0;
2002   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
2003   2                      {
2004   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
2005   3                              {
2006   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
2007   4                              }
2008   3                      }
2009   2      
2010   2                      displayVolt = MAX(batteryVoltSum, chargeModuleVolt) - DC_Insulation[0].controlBusToGroundVolt;
2011   2                      write_dgus_vp(0x9990, (uint8_t *)&displayVolt, 1);
2012   2                      write_dgus_vp(0x9991, (uint8_t *)&displayVolt, 1);
2013   2              }
2014   1      
2015   1              write_dgus_vp(0x9992, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
2016   1      
2017   1              write_dgus_vp(0x9993, (uint8_t *)&AC_Insulation.alarmValue, 1);
2018   1              // write_dgus_vp(0x9993, (uint8_t *)&insulationSet.AC.voltToGroundAlarm, 1); // 有歧义
2019   1      }
2020          
2021          void p88Func(void)
2022          {
2023   1              uint16_t i;
2024   1              for (i = 0; i < 30; i++)
2025   1              {
2026   2                      uint16_t insulationRes;
2027   2                      insulationRes = DC_Insulation[1].res[i];
2028   2                      insulationRes += i < insulationSet.DC.closeBus_2_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
2029   2                      write_dgus_vp(0x99A0 + i, (uint8_t *)&insulationRes, 1);
2030   2                      if (AC_Insulation.positiveBusToGroundVolt || AC_Insulation.negativeBusToGroundVolt)
2031   2                      {
2032   3                              uint16_t temp = 1;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 34  

2033   3                              if (insulationRes <= insulationSet.DC.resAlarm)
2034   3                              {
2035   4                                      temp = 0;
2036   4                              }
2037   3                              write_dgus_vp(0x99C0 + i, (uint8_t *)&temp, 1);
2038   3                      }
2039   2              }
2040   1      
2041   1              if (sysInfoSet.siliconChain == 1)
2042   1              {
2043   2                      int16_t temp;
2044   2                      temp = DC_Insulation[0].closeBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
2045   2                      write_dgus_vp(0x99E0, (uint8_t *)&temp, 1);
2046   2      
2047   2                      temp = DC_Insulation[0].controlBusToGroundVolt - DC_Insulation[0].busToGroundVolt;
2048   2                      write_dgus_vp(0x99E1, (uint8_t *)&temp, 1);
2049   2              }
2050   1              else if (sysInfoSet.siliconChain == 0)
2051   1              {
2052   2                      int32_t batteryVoltSum;   // 电池巡检电压总和
2053   2                      int32_t chargeModuleVolt; // 充电模块电压
2054   2                      int16_t displayVolt;
2055   2                      uint16_t i;
2056   2      
2057   2                      read_dgus_vp(0xb020, (uint8_t *)&batteryVoltSum, 1);
2058   2      
2059   2                      chargeModuleVolt = 0;
2060   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
2061   2                      {
2062   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
2063   3                              {
2064   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
2065   4                              }
2066   3                      }
2067   2      
2068   2                      displayVolt = MAX(batteryVoltSum, chargeModuleVolt) - DC_Insulation[0].controlBusToGroundVolt;
2069   2                      write_dgus_vp(0x99E0, (uint8_t *)&displayVolt, 1);
2070   2                      write_dgus_vp(0x99E1, (uint8_t *)&displayVolt, 1);
2071   2              }
2072   1      
2073   1              write_dgus_vp(0x99E2, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
2074   1      
2075   1              write_dgus_vp(0x99E3, (uint8_t *)&AC_Insulation.alarmValue, 1);
2076   1      
2077   1      }
2078          
2079          void p94Func(void)
2080          {
2081   1              uint16_t i;
2082   1              if (batterySet.batteryType == XJ24)
2083   1              {
2084   2                      for (i = 0; i < 60; i++)
2085   2                      {
2086   3                              if (i < batterySet.xj24.cellNum)
2087   3                              {
2088   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
2089   4                              }
2090   3                              else
2091   3                              {
2092   4                                      uint16_t temp = 0;
2093   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
2094   4                              }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 35  

2095   3                      }
2096   2              }
2097   1              else if (batterySet.batteryType == XJ55)
2098   1              {
2099   2                      for (i = 0; i < 60; i++)
2100   2                      {
2101   3                              if (i < batterySet.xj24.cellNum)
2102   3                              {
2103   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
2104   4                              }
2105   3                              else
2106   3                              {
2107   4                                      uint16_t temp = 0;
2108   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
2109   4                              }
2110   3                      }
2111   2              }
2112   1      }
2113          
2114          void p113Func(void)
2115          {
2116   1              uint16_t i;
2117   1              if (batterySet.batteryType == XJ24)
2118   1              {
2119   2                      for (i = 60; i < 120; i++)
2120   2                      {
2121   3                              if (i < batterySet.xj24.cellNum)
2122   3                              {
2123   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
2124   4                              }
2125   3                              else
2126   3                              {
2127   4                                      uint16_t temp = 0;
2128   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
2129   4                              }
2130   3                      }
2131   2              }
2132   1              else if (batterySet.batteryType == XJ55)
2133   1              {
2134   2                      for (i = 60; i < 120; i++)
2135   2                      {
2136   3                              if (i < batterySet.xj24.cellNum)
2137   3                              {
2138   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
2139   4                              }
2140   3                              else
2141   3                              {
2142   4                                      uint16_t temp = 0;
2143   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
2144   4                              }
2145   3                      }
2146   2              }
2147   1      }
2148          
2149          void p114Func()
2150          {
2151   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
2152   1              {
2153   2                      uint16_t i;
2154   2                      for (i = 0; i < 16; i++)
2155   2                      {
2156   3                              uint16_t swState;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 36  

2157   3                              swState = (remoteControlModule_ARD[1].sw1to16 >> i) & 0x01;
2158   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
2159   3                      }
2160   2              }
2161   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
2162   1              {
2163   2                      uint16_t i;
2164   2                      for (i = 0; i < 16; i++)
2165   2                      {
2166   3                              uint16_t swState;
2167   3                              swState = (remoteControlModule_TH[1].sw1to16 >> i) & 0x01;
2168   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
2169   3                      }
2170   2              }
2171   1              {
2172   2                      VariableChangedIndicationTypeDef variableChangedIndication;
2173   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
2174   2                      if (variableChangedIndication.flag == 0x5A)
2175   2                      {
2176   3                              uint16_t variable[5];
2177   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
2178   3                              switch (variableChangedIndication.addr)
2179   3                              {
2180   4                              case 0x97B0:
2181   4                              case 0x97B1:
2182   4                              case 0x97B2:
2183   4                              case 0x97B3:
2184   4                              case 0x97B4:
2185   4                              case 0x97B5:
2186   4                              case 0x97B6:
2187   4                              case 0x97B7:
2188   4                              case 0x97B8:
2189   4                              case 0x97B9:
2190   4                              case 0x97BA:
2191   4                              case 0x97BB:
2192   4                              case 0x97BC:
2193   4                              case 0x97BD:
2194   4                              case 0x97BE:
2195   4                              case 0x97BF:
2196   4                              {
2197   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
2198   5                                      {
2199   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
2200   6                                              if (variable[0] == 0)
2201   6                                              {
2202   7                                                      static MMODBUS rtuSwOff[16];
2203   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2204   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
2205   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2206   7                                                      rtuSwOff[offset].mode = 0x00;
2207   7                                                      rtuSwOff[offset].flag = 0x00;
2208   7                                                      rtuSwOff[offset].Order = 0x06;
2209   7                                                      rtuSwOff[offset].Length = 0x01;
2210   7                                                      rtuSwOff[offset].reserved = 0x00;
2211   7                                                      rtuSwOff[offset].waitTime = 1000;
2212   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2213   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
2214   7                                                      rtuSwOff[offset].databuff = NULL;
2215   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2216   7                                                      pushToEmergency(rtuSwOff + offset);
2217   7                                              }
2218   6                                              else if (variable[0] == 1)
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 37  

2219   6                                              {
2220   7                                                      static MMODBUS rtuSwOn[16];
2221   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2222   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
2223   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2224   7                                                      rtuSwOn[offset].mode = 0x00;
2225   7                                                      rtuSwOn[offset].flag = 0x00;
2226   7                                                      rtuSwOn[offset].Order = 0x06;
2227   7                                                      rtuSwOn[offset].Length = 0x01;
2228   7                                                      rtuSwOn[offset].reserved = 0x00;
2229   7                                                      rtuSwOn[offset].waitTime = 1000;
2230   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2231   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
2232   7                                                      rtuSwOn[offset].databuff = NULL;
2233   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2234   7                                                      pushToEmergency(rtuSwOn + offset);
2235   7                                              }
2236   6                                      }
2237   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
2238   5                                      {
2239   6                                              if (variable[0] == 0)
2240   6                                              {
2241   7                                                      static MMODBUS rtuSwOff[16];
2242   7                                                      uint16_t OffVal = 0x0000;
2243   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2244   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2245   7                                                      rtuSwOff[offset].mode = 0x00;
2246   7                                                      rtuSwOff[offset].flag = 0x00;
2247   7                                                      rtuSwOff[offset].Order = 0x06;
2248   7                                                      rtuSwOff[offset].Length = 0x01;
2249   7                                                      rtuSwOff[offset].reserved = 0x00;
2250   7                                                      rtuSwOff[offset].waitTime = 1000;
2251   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2252   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
2253   7                                                      rtuSwOff[offset].databuff = NULL;
2254   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OffVal, 1);
2255   7                                                      pushToEmergency(rtuSwOff + offset);
2256   7                                              }
2257   6                                              else if (variable[0] == 1)
2258   6                                              {
2259   7                                                      static MMODBUS rtuSwOn[16];
2260   7                                                      uint16_t OnVal = 0xFFFF;
2261   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2262   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2263   7                                                      rtuSwOn[offset].mode = 0x00;
2264   7                                                      rtuSwOn[offset].flag = 0x00;
2265   7                                                      rtuSwOn[offset].Order = 0x06;
2266   7                                                      rtuSwOn[offset].Length = 0x01;
2267   7                                                      rtuSwOn[offset].reserved = 0x00;
2268   7                                                      rtuSwOn[offset].waitTime = 1000;
2269   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2270   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
2271   7                                                      rtuSwOn[offset].databuff = NULL;
2272   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OnVal, 1);
2273   7                                                      pushToEmergency(rtuSwOn + offset);
2274   7                                              }
2275   6                                      }
2276   5                              }
2277   4                              break;
2278   4      
2279   4                              default:
2280   4                                      break;
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 38  

2281   4                              }
2282   3                              memset(variable, 0, 5);
2283   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
2284   3                              variableChangedIndication.flag = 0;
2285   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
2286   3                      }
2287   2              }
2288   1      }
2289          
2290          code void (*PagePointer[])(void) = {
2291                  P0Func,
2292                  NULL,
2293                  P2Func,
2294                  NULL,
2295                  NULL,
2296                  NULL,
2297                  NULL,
2298                  NULL,
2299                  NULL,
2300                  NULL,
2301                  NULL,
2302                  P11Func,
2303                  P12Func,
2304                  NULL,                             // 13
2305                  NULL,                             // 14
2306                  NULL,                             // 15
2307                  NULL,                             // 16
2308                  NULL,                             // 17
2309                  P18Func,                          // 18
2310                  NULL,                             // 19
2311                  NULL,                             // 20
2312                  NULL,                             // 21
2313                  P22Func,                          // 22
2314                  NULL,                             // 23
2315                  NULL,                             // 24
2316                  NULL,                             // 25
2317                  P26Func,                          // 26
2318                  NULL,                             // 27
2319                  NULL,                             // 28
2320                  P29Func,                          // 29
2321                  NULL,                             // 30
2322                  NULL,                             // 31
2323                  NULL,                             // 32
2324                  P33Func,                          // 33
2325                  NULL,                             // 34
2326                  P35Func,                          // 35
2327                  NULL,                             // 36
2328                  NULL,                             // 37
2329                  NULL,                             // 38
2330                  P39Func,                          // 39
2331                  NULL,                             // 40
2332                  NULL,                             // 41
2333                  p42Func,                          // 42
2334                  NULL,                             // 43
2335                  p44Func,                          // 44
2336                  NULL,                             // 45
2337                  NULL,                             // 46
2338                  NULL,                             // 47
2339                  p48Func,                          // 48
2340                  NULL,                             // 49
2341                  p50Func,                          // 50
2342                  NULL,                             // 51
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 39  

2343                  p52Func,                          // 52
2344                  NULL,                             // 53
2345                  NULL,                             // 54
2346                  NULL,                             // 55
2347                  NULL,                             // 56
2348                  NULL,                             // 57
2349                  NULL,                             // 58
2350                  realTimeAlarmDisplay, // 59
2351                  NULL,                             // 60
2352                  historyAlarmDisplay,  // 61
2353                  NULL,                             // 62
2354                  NULL,                             // 63
2355                  NULL,                             // 64
2356                  NULL,                             // 65
2357                  NULL,                             // 66
2358                  NULL,                             // 67
2359                  p68Func,                          // 68
2360                  NULL,                             // 69
2361                  p70Func,                          // 70
2362                  NULL,                             // 71
2363                  p72Func,                          // 72
2364                  NULL,                             // 73
2365                  NULL,                             // 74
2366                  p75Func,                          // 75
2367                  p76Func,                          // 76
2368                  p77Func,                          // 77
2369                  p78Func,                          // 78
2370                  p79Func,                          // 79
2371                  p80Func,                          // 80
2372                  NULL,                             // 81
2373                  p82Func,                          // 82
2374                  NULL,                             // 83
2375                  NULL,                             // 84
2376                  p85Func,                          // 85
2377                  p86Func,                          // 86
2378                  p87Func,                          // 87
2379                  p88Func,                          // 88
2380                  NULL,                             // 89
2381                  NULL,                             // 90
2382                  NULL,                             // 91
2383                  NULL,                             // 92
2384                  NULL,                             // 93
2385                  p94Func,                          // 94
2386                  NULL,                             // 95
2387                  NULL,                             // 96
2388                  NULL,                             // 97
2389                  NULL,                             // 98
2390                  NULL,                             // 99
2391                  permissionLogin,          // 100
2392                  NULL,                             // 101
2393                  passwordModify,           // 102
2394                  NULL,                             // 103
2395                  NULL,                             // 104
2396                  NULL,                             // 105
2397                  NULL,                             // 106
2398                  NULL,                             // 107
2399                  NULL,                             // 108
2400                  NULL,                             // 109
2401                  NULL,                             // 110
2402                  NULL,                             // 111
2403                  NULL,                             // 112
2404                  p113Func,                         // 113
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 40  

2405                  p114Func,                         // 114
2406                  NULL,                             // 115s
2407          };
2408          
2409          // code void (*pageOpenTreat[])(void) =
2410          // {
2411          
2412          // }
2413          
2414          /**
2415           * @brief 打开某页时执行的功能，主要为更新一次当前页的数据
2416           *
2417           * @param page
2418           */
2419          void pageOpenTreat(uint16_t page)
2420          {
2421   1              switch (page)
2422   1              {
2423   2              case 11:
2424   2                      write_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE); // 进入页面时刷新数据
2425   2                      break;
2426   2              case 12:
2427   2                      write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
2428   2                      break;
2429   2              case 18:
2430   2                      write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
2431   2                      break;
2432   2              case 22:
2433   2                      write_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
2434   2                      break;
2435   2              case 29:
2436   2                      write_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, BATTERY_SET_SIZE);
2437   2                      break;
2438   2              case 33:
2439   2              {
2440   3                      uint8_t rtc[6];
2441   3                      memcpy(rtc, RTCdata, 3);
2442   3                      memcpy(rtc + 3, RTCdata + 4, 3);
2443   3                      write_dgus_vp(0x9D, (uint8_t *)&rtc, 3);
2444   3                      write_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
2445   3              }
2446   2              break;
2447   2              case 35:
2448   2                      write_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
2449   2                      break;
2450   2              case 39:
2451   2                      write_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
2452   2                      break;
2453   2              case 42:
2454   2                      write_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
2455   2                      break;
2456   2              case 44:
2457   2                      write_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
2458   2                      break;
2459   2              case 48:
2460   2                      write_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
2461   2                      break;
2462   2      
2463   2              default:
2464   2                      break;
2465   2              }
2466   1      }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 41  

2467          void PageFunction(void)
2468          {
2469   1              u16 pageid;
2470   1      
2471   1              static uint16_t oldPageid = 0;
2472   1      
2473   1              // EA = 0;
2474   1              ADR_H = 0x00;
2475   1              ADR_M = 0x00;
2476   1              ADR_L = 0x0a;
2477   1              ADR_INC = 1;
2478   1              RAMMODE = 0xAF;
2479   1              while (!APP_ACK)
2480   1                      ;
2481   1              APP_EN = 1;
2482   1              while (APP_EN)
2483   1                      ;
2484   1              pageid = DATA3;
2485   1              pageid <<= 8;
2486   1              pageid |= DATA2;
2487   1              RAMMODE = 0;
2488   1              EA = 1;
2489   1              if (PagePointer[pageid] != 0)
2490   1              {
2491   2                      PagePointer[pageid]();
2492   2              }
2493   1      
2494   1              if (pageid != oldPageid)
2495   1              {
2496   2                      pageOpenTreat(pageid);
2497   2                      oldPageid = pageid;
2498   2              }
2499   1      }
2500          
2501          /**
2502           * @brief 打开屏保，CFG未设置屏保的情况下，可以通过该代码设置
2503           *
2504           */
2505          void openScreenProtection(void)
2506          {
2507   1              // 打开屏保
2508   1              uint16_t data_0x80[2];
2509   1              data_0x80[0] = 0x5A00;
2510   1              read_dgus_vp(0x81, (uint8_t *)(data_0x80 + 1), 1);
2511   1              data_0x80[1] |= 0x01 << 2;
2512   1              write_dgus_vp(0x80, (uint8_t *)data_0x80, 2);
2513   1      
2514   1              { // 设置屏保亮度
2515   2                      struct
2516   2                      {
2517   2                              uint8_t OpenLuminance;           // 开启亮度
2518   2                              uint8_t protectionLuminance; // 屏保亮度
2519   2                      } screenLuminance;                               // 屏幕亮度
2520   2                      read_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2521   2                      screenLuminance.protectionLuminance = 0;
2522   2                      write_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2523   2              }
2524   1      }
2525          
2526          void weekDisplay(void)
2527          {
2528   1              uint16_t weekday = RTCdata[3];
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 42  

2529   1              write_dgus_vp(0xB000, (uint8_t *)&weekday, 1);
2530   1      }
2531          
2532          /**
2533           * @brief 充电模式切换为浮充或均充
2534           *
2535           * @param chargeMode ：FLOAT_CHARGE/EQUALIZE_CHARGE
2536           */
2537          void chargeModeSwitch(uint16_t chargeMode)
2538          {
2539   1              static MMODBUS chargeCmd;
2540   1              if (chargeMode == FLOAT_CHARGE)
2541   1              {
2542   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2543   2                      chargeCmd.mode = 0x00;
2544   2                      chargeCmd.flag = 0x00;
2545   2                      chargeCmd.Order = 0x06;
2546   2                      chargeCmd.Length = 1;
2547   2                      chargeCmd.reserved = 0x00;
2548   2                      chargeCmd.waitTime = 1000;
2549   2                      chargeCmd.VPaddr = 0;
2550   2                      chargeCmd.ModbusReg = 0X0000;
2551   2                      chargeCmd.databuff = &batteryInfoSet.floatChargeVolt;
2552   2                      synthesisCollection.closeBusVolt = batteryInfoSet.floatChargeVolt; // 防止重复发送数据
2553   2              }
2554   1              else if (chargeMode == EQUALIZE_CHARGE)
2555   1              {
2556   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2557   2                      chargeCmd.mode = 0x00;
2558   2                      chargeCmd.flag = 0x00;
2559   2                      chargeCmd.Order = 0x06;
2560   2                      chargeCmd.Length = 1;
2561   2                      chargeCmd.reserved = 0x00;
2562   2                      chargeCmd.waitTime = 1000;
2563   2                      chargeCmd.VPaddr = 0;
2564   2                      chargeCmd.ModbusReg = 0X0000;
2565   2                      chargeCmd.databuff = &batteryInfoSet.equalizeChargeVolt;
2566   2                      synthesisCollection.closeBusVolt = batteryInfoSet.equalizeChargeVolt;
2567   2              }
2568   1              pushToEmergency(&chargeCmd);
2569   1      }
2570          void batteryManage(void)
2571          {
2572   1              static int32_t totalSecond = 0;
2573   1              static uint16_t chargeState = FLOAT_CHARGE; // 充电状态：均充/浮充
2574   1              int16_t batteryCurr;                                            // 霍尔变比后电池组电流
2575   1      
2576   1              batteryCurr = (int32_t)synthesisCollection.batteryCurr * (int32_t)DC_InfoSet.batteryHallRatio / 100;
2577   1      
2578   1              {
2579   2                      if (batteryCurr < 0)
2580   2                      {
2581   3                              chargeState = DISCHARGE;
2582   3                              KillTimer(CHARGE_TIMER);
2583   3                              totalSecond = 0;
2584   3                      }
2585   2                      else if (batteryCurr >= 0)
2586   2                      {
2587   3                              if (synthesisCollection.closeBusVolt >= batteryInfoSet.equalizeChargeVolt)
2588   3                              { // 根据电压判断均充浮充
2589   4                                      if (chargeState != EQUALIZE_CHARGE)
2590   4                                      {
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 43  

2591   5                                              chargeState = EQUALIZE_CHARGE;
2592   5                                              StartTimer(CHARGE_TIMER, 1000);
2593   5                                              totalSecond = (int32_t)batteryInfoSet.equalizeChargeHour * 60 * 60;
2594   5                                      }
2595   4                              }
2596   3                              else if (synthesisCollection.closeBusVolt <= batteryInfoSet.floatChargeVolt)
2597   3                              {
2598   4                                      if (chargeState != FLOAT_CHARGE)
2599   4                                      {
2600   5                                              chargeState = FLOAT_CHARGE;
2601   5                                              StartTimer(CHARGE_TIMER, 1000);
2602   5                                              totalSecond = (int32_t)batteryInfoSet.floatChargeDay * 24 * 60 * 60;
2603   5                                      }
2604   4                              }
2605   3      
2606   3                              {
2607   4                                      int32_t equalizeCurr; // 均充电流
2608   4                                      int32_t floatCurr;        // 浮充电流
2609   4                                      equalizeCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.floatToEqualizeChargeCur / 100
             -0;
2610   4                                      floatCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.equalizeToFloatChargeCur / 1000;
2611   4                                      if (batteryCurr >= equalizeCurr)
2612   4                                      {
2613   5                                              if (chargeState != EQUALIZE_CHARGE)
2614   5                                              {
2615   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2616   6                                              }
2617   5                                      }
2618   4                                      else if (batteryCurr <= floatCurr)
2619   4                                      {
2620   5                                              if (chargeState != FLOAT_CHARGE)
2621   5                                              {
2622   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2623   6                                              }
2624   5                                      }
2625   4                              }
2626   3      
2627   3                              if (GetTimeOutFlag(CHARGE_TIMER))
2628   3                              {
2629   4                                      totalSecond--;
2630   4                                      if (totalSecond <= 0)
2631   4                                      {
2632   5                                              if (chargeState == FLOAT_CHARGE)
2633   5                                              {
2634   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2635   6                                              }
2636   5                                              else if (chargeState == EQUALIZE_CHARGE)
2637   5                                              {
2638   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2639   6                                              }
2640   5                                      }
2641   4                                      StartTimer(CHARGE_TIMER, 1000);
2642   4                                      {
2643   5                                              timeTypeDef chargeTime;
2644   5                                              chargeTime.day = totalSecond / 60 / 60 / 24;
2645   5                                              chargeTime.hour = totalSecond / 60 / 60 % 24;
2646   5                                              chargeTime.minite = totalSecond / 60 % 60;
2647   5                                              chargeTime.second = totalSecond % 60;
2648   5                                              write_dgus_vp(0xB010, (uint8_t *)&chargeTime, 10);
2649   5                                      }
2650   4                              }
2651   3                      }
C51 COMPILER V9.60.7.0   UI                                                                05/06/2023 14:45:50 PAGE 44  

2652   2                      write_dgus_vp(0xB002, (uint8_t *)&chargeState, 1);
2653   2              }
2654   1      }
2655          
2656          int16_t batteryVoltSum;
2657          
2658          void batteryVoltDisplay()
2659          {
2660   1              int16_t sum;
2661   1              uint16_t i;
2662   1              if (batterySet.xj24.cellNum > 0)
2663   1              {
2664   2                      if (batterySet.batteryType == XJ24)
2665   2                      {
2666   3                              sum = 0;
2667   3                              for (i = 0; i < batterySet.xj24.cellNum; i++)
2668   3                              {
2669   4                                      sum += battery_xj24[i / 24].volt[i % 24];
2670   4                              }
2671   3                      }
2672   2                      else if (batterySet.batteryType == XJ55)
2673   2                      {
2674   3                              sum = 0;
2675   3                              for (i = 0; i < batterySet.xj55.cellNum; i++)
2676   3                              {
2677   4                                      sum += battery_xj55[i / 55].volt[i % 55];
2678   4                              }
2679   3                      }
2680   2              }
2681   1              else if (batterySet.xj24.cellNum == 0)
2682   1              {
2683   2                      sum = synthesisCollection.batteryVolt;
2684   2              }
2685   1              batteryVoltSum = sum;
2686   1              write_dgus_vp(0xB020, (uint8_t *)&batteryVoltSum, 1);
2687   1      }
2688          
2689          void batteryCurrDisplay(void)
2690          {
2691   1              write_dgus_vp(0xB022, (uint8_t *)&synthesisCollection.batteryCurr, 1);
2692   1      }
2693          
2694          void publicUI(void)
2695          {
2696   1              weekDisplay();
2697   1              batteryVoltDisplay();
2698   1              batteryCurrDisplay();
2699   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  20206    ----
   CONSTANT SIZE    =    353    ----
   XDATA SIZE       =   2248     384
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
