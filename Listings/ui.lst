C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UI
OBJECT MODULE PLACED IN .\Objects\ui.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\ui.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.\li
                    -b) DEBUG OBJECTEXTEND PRINT(.\Listings\ui.lst) OBJECT(.\Objects\ui.obj)

line level    source

   1          #include "ui.h"
   2          #include "modbus.h"
   3          #include <STRING.H>
   4          #include "permission.h"
   5          #include "debug.h"
   6          #include "norflash.h"
   7          #include <STDLIB.H>
   8          #include "rtc.h"
   9          #include "const.h"
  10          #include "data.h"
  11          #include "umath.h"
  12          #include "timer.h"
  13          #include "alarm.h"
  14          
  15          #define testDis 0
  16          void testDisplayNum(u16 addr, u16 num)
  17          {
  18   1      #if testDis
              
              #else
  21   1              write_dgus_vp(addr, (u8 *)&num, 1);
  22   1      #endif
  23   1      }
  24          
  25          // 读取按键0x1000的值
  26          u8 getTouch(void)
  27          {
  28   1              u8 tmp;
  29   1              // EA = 0;
  30   1              ADR_H = 0x00;
  31   1              ADR_M = 0x08; // 0x1000
  32   1              ADR_L = 0x00;
  33   1              ADR_INC = 1;
  34   1              RAMMODE = 0xAF;
  35   1              while (!APP_ACK)
  36   1                      ;
  37   1              APP_EN = 1;
  38   1              while (APP_EN)
  39   1                      ;
  40   1              // str[0] = DATA3;
  41   1              tmp = DATA2;
  42   1              // EA = 1;
  43   1              RAMMODE = 0;
  44   1              return tmp;
  45   1      }
  46          
  47          // 清除按键0x1000的值
  48          void clrTouch(void)
  49          {
  50   1              // EA = 0;
  51   1              ADR_H = 0x00;
  52   1              ADR_M = 0x08; // 0x1000
  53   1              ADR_L = 0x00;
  54   1              ADR_INC = 1;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 2   

  55   1              RAMMODE = 0x8C;
  56   1              while (!APP_ACK)
  57   1                      ;
  58   1              DATA3 = 0;
  59   1              DATA2 = 0;
  60   1              APP_EN = 1;
  61   1              while (APP_EN)
  62   1                      ;
  63   1              RAMMODE = 0;
  64   1              // EA = 1;
  65   1      }
  66          
  67          void P0Func(void)
  68          {
  69   1              VariableChangedIndicationTypeDef variableChangedIndication;
  70   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
  71   1              if (variableChangedIndication.flag == 0x5A)
  72   1              {
  73   2                      uint16_t variable[5];
  74   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
  75   2                      switch (variableChangedIndication.addr)
  76   2                      {
  77   3                      case 0x8000:
  78   3                              if (variable[0] == 1)
  79   3                              {
  80   4                                      if (manager.loginFlag || admin.loginFlag)
  81   4                                      {
  82   5                                              Page_Change(SYS_FUNCTION_TABLE_PAGE);
  83   5                                      }
  84   4                                      else
  85   4                                      {
  86   5                                              passwordLogin(SYS_FUNCTION_TABLE_PAGE);
  87   5                                      }
  88   4                              }
  89   3                              break;
  90   3                      case 0x8001:
  91   3                              if (variable[0] == 1)
  92   3                              {
  93   4                                      if (manager.loginFlag || admin.loginFlag)
  94   4                                      {
  95   5                                              Page_Change(BATTERY_MANAGER_PAGE);
  96   5                                      }
  97   4                                      else
  98   4                                      {
  99   5                                              passwordLogin(BATTERY_MANAGER_PAGE);
 100   5                                      }
 101   4                              }
 102   3                              break;
 103   3                      case 0x8006:
 104   3                              if (variable[0] == 1)
 105   3                              {
 106   4                                      if (chargeModuleSet.moduleNum > 0)
 107   4                                      {
 108   5                                              Page_Change(CHARGE_DATA_PAGE);
 109   5                                      }
 110   4                              }
 111   3                              break;
 112   3                      case 0x8007:
 113   3                              if (variable[0] == 1)
 114   3                              {
 115   4                                      if (batterySet.batteryType == XJ24)
 116   4                                      {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 3   

 117   5                                              if (batterySet.xj24.batteryModuleNum > 0)
 118   5                                              {
 119   6                                                      Page_Change(BATTERY_DATA_PAGE);
 120   6                                              }
 121   5                                      }
 122   4                                      else if (batterySet.batteryType == XJ55)
 123   4                                      {
 124   5                                              if (batterySet.xj55.batteryModuleNum > 0)
 125   5                                              {
 126   6                                                      Page_Change(BATTERY_DATA_PAGE);
 127   6                                              }
 128   5                                      }
 129   4                              }
 130   3                              break;
 131   3                      case 0x8008:
 132   3                              if (variable[0] == 1)
 133   3                              {
 134   4                                      if (switchModuleSet.switchModule.switchNum > 0)
 135   4                                      {
 136   5                                              Page_Change(SWITCH_MODULE_DATA_PAGE);
 137   5                                      }
 138   4                              }
 139   3                              break;
 140   3                      case 0x800A:
 141   3                              if (variable[0] == 1)
 142   3                              {
 143   4                                      if (UPS_INV_Set.UPS_Num > 0)
 144   4                                      {
 145   5                                              Page_Change(UPS_DATA_PAGE);
 146   5                                      }
 147   4                              }
 148   3                              break;
 149   3                      case 0x800B:
 150   3                              if (variable[0] == 1)
 151   3                              {
 152   4                                      if (DC_ConverterSet.Num > 0)
 153   4                                      {
 154   5                                              Page_Change(DC_CONVERTER_DATA_PAGE);
 155   5                                      }
 156   4                              }
 157   3                              break;
 158   3                      case 0x800C:
 159   3                              if (variable[0] == 1)
 160   3                              {
 161   4                                      if (insulationSet.DC.Num > 0)
 162   4                                      {
 163   5                                              Page_Change(INSULATION_DATA_PAGE);
 164   5                                      }
 165   4                                      else
 166   4                                      {
 167   5                                              Page_Change(NON_INSULATION_DATA_PAGE);
 168   5                                      }
 169   4                              }
 170   3                              break;
 171   3                      default:
 172   3                              break;
 173   3                      }
 174   2                      memset(variable, 0, 5);
 175   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 176   2                      variableChangedIndication.flag = 0;
 177   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 178   2              }
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 4   

 179   1      
 180   1              if (manager.loginFlag)
 181   1              {
 182   2                      manager.loginFlag = 0;
 183   2              }
 184   1              if (admin.loginFlag)
 185   1              {
 186   2                      admin.loginFlag = 0;
 187   2              }
 188   1      }
 189          
 190          void P2Func(void)
 191          {
 192   1              VariableChangedIndicationTypeDef variableChangedIndication;
 193   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 194   1              if (variableChangedIndication.flag == 0x5A)
 195   1              {
 196   2                      uint16_t variable[5];
 197   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 198   2                      switch (variableChangedIndication.addr)
 199   2                      {
 200   3                      case 0x8020:
 201   3                              if (variable[0] == 1)
 202   3                              {
 203   4                                      if (manager.loginFlag || admin.loginFlag)
 204   4                                      {
 205   5                                              Page_Change(SYS_INFO_PAGE);
 206   5                                      }
 207   4                                      else
 208   4                                      {
 209   5                                              passwordLogin(SYS_INFO_PAGE);
 210   5                                      }
 211   4                              }
 212   3                              break;
 213   3                      case 0x8021:
 214   3                              if (variable[0] == 1)
 215   3                              {
 216   4                                      if (manager.loginFlag || admin.loginFlag)
 217   4                                      {
 218   5                                              Page_Change(SWITCH_MODULE_SET_PAGE);
 219   5                                      }
 220   4                                      else
 221   4                                      {
 222   5                                              passwordLogin(SWITCH_MODULE_SET_PAGE);
 223   5                                      }
 224   4                              }
 225   3                              break;
 226   3                      case 0x8022:
 227   3                              if (variable[0] == 1)
 228   3                              {
 229   4                                      if (manager.loginFlag || admin.loginFlag)
 230   4                                      {
 231   5                                              Page_Change(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 232   5                                      }
 233   4                                      else
 234   4                                      {
 235   5                                              passwordLogin(SERIES_BATTERY_INSPECTION_DEVICE_SET_PAGE);
 236   5                                      }
 237   4                              }
 238   3                              break;
 239   3                      case 0x8023:
 240   3                              if (variable[0] == 1)
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 5   

 241   3                              {
 242   4                                      if (manager.loginFlag || admin.loginFlag)
 243   4                                      {
 244   5                                              Page_Change(INSULATION_SET_PAGE);
 245   5                                      }
 246   4                                      else
 247   4                                      {
 248   5                                              passwordLogin(INSULATION_SET_PAGE);
 249   5                                      }
 250   4                              }
 251   3                              break;
 252   3                      case 0x8024:
 253   3                              if (variable[0] == 1)
 254   3                              {
 255   4                                      if (manager.loginFlag || admin.loginFlag)
 256   4                                      {
 257   5                                              Page_Change(CHARGER_MODULE_SET_PAGE);
 258   5                                      }
 259   4                                      else
 260   4                                      {
 261   5                                              passwordLogin(CHARGER_MODULE_SET_PAGE);
 262   5                                      }
 263   4                              }
 264   3                              break;
 265   3                      case 0x8025:
 266   3                              if (variable[0] == 1)
 267   3                              {
 268   4                                      if (manager.loginFlag || admin.loginFlag)
 269   4                                      {
 270   5                                              Page_Change(DC_MODULE_SET_PAGE);
 271   5                                      }
 272   4                                      else
 273   4                                      {
 274   5                                              passwordLogin(DC_MODULE_SET_PAGE);
 275   5                                      }
 276   4                              }
 277   3                              break;
 278   3                      case 0x8026:
 279   3                              if (variable[0] == 1)
 280   3                              {
 281   4                                      if (manager.loginFlag || admin.loginFlag)
 282   4                                      {
 283   5                                              Page_Change(UPS_INV_SET_PAGE);
 284   5                                      }
 285   4                                      else
 286   4                                      {
 287   5                                              passwordLogin(UPS_INV_SET_PAGE);
 288   5                                      }
 289   4                              }
 290   3                              break;
 291   3                      case 0x8027:
 292   3                              if (variable[0] == 1)
 293   3                              {
 294   4                                      if (admin.loginFlag)
 295   4                                      {
 296   5                                              Page_Change(RECOVERY_PAGE);
 297   5                                      }
 298   4                                      else
 299   4                                      {
 300   5                                              passwordLogin(RECOVERY_PAGE);
 301   5                                      }
 302   4                              }
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 6   

 303   3                              break;
 304   3      
 305   3                      default:
 306   3                              break;
 307   3                      }
 308   2                      memset(variable, 0, 5);
 309   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 310   2                      variableChangedIndication.flag = 0;
 311   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 312   2              }
 313   1      }
 314          
 315          void P11Func(void)
 316          {
 317   1              VariableChangedIndicationTypeDef variableChangedIndication;
 318   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 319   1              if (variableChangedIndication.flag == 0x5A)
 320   1              {
 321   2                      uint16_t variable[5];
 322   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 323   2                      switch (variableChangedIndication.addr)
 324   2                      {
 325   3                      case 0x8041:
 326   3                              if (variable[0] == 1)
 327   3                              {
 328   4                                      read_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE);
 329   4                                      dgusToNorFlash(SYS_INFO_NORFLASH_ADDR, SYS_INFO_VP, SYS_INFO_SIZE);
 330   4                                      modbusCenerate();
 331   4                                      // DEBUGINFO("save sysInfo");
 332   4                              }
 333   3                              break;
 334   3                      default:
 335   3                              break;
 336   3                      }
 337   2                      memset(variable, 0, 5);
 338   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 339   2      
 340   2                      variableChangedIndication.flag = 0;
 341   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 342   2              }
 343   1      }
 344          
 345          void P12Func()
 346          {
 347   1              VariableChangedIndicationTypeDef variableChangedIndication;
 348   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 349   1              if (variableChangedIndication.flag == 0x5A)
 350   1              {
 351   2                      uint16_t variable[5];
 352   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 353   2                      switch (variableChangedIndication.addr)
 354   2                      {
 355   3                      case 0x8060:
 356   3                              if (variable[0] == 1)
 357   3                              {
 358   4                                      read_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
 359   4                                      dgusToNorFlash(AC_INFO_NORFLASH_ADDR, AC_INFO_VP, AC_INFO_SIZE);
 360   4                                      modbusCenerate();
 361   4                              }
 362   3                              break;
 363   3                      default:
 364   3                              break;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 7   

 365   3                      }
 366   2                      memset(variable, 0, 5);
 367   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 368   2      
 369   2                      variableChangedIndication.flag = 0;
 370   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 371   2              }
 372   1      }
 373          
 374          void P18Func()
 375          {
 376   1              VariableChangedIndicationTypeDef variableChangedIndication;
 377   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 378   1              if (variableChangedIndication.flag == 0x5A)
 379   1              {
 380   2                      uint16_t variable[5];
 381   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 382   2                      switch (variableChangedIndication.addr)
 383   2                      {
 384   3                      case 0x8060:
 385   3                              if (variable[0] == 1)
 386   3                              {
 387   4                                      read_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
 388   4                                      dgusToNorFlash(DC_INFO_NORFLASH_ADDR, DC_INFO_VP, DC_INFO_SIZE);
 389   4                                      modbusCenerate();
 390   4                              }
 391   3                              break;
 392   3                      case 0x90B1:
 393   3                      {
 394   4                              if (sysInfoSet.siliconChain == 0)
 395   4                              {
 396   5                                      write_dgus_vp(0x90A1, (uint8_t *)&variable, 1);
 397   5                              }
 398   4                              else
 399   4                              {
 400   5                                      write_dgus_vp(0x90A5, (uint8_t *)&variable, 1);
 401   5                              }
 402   4                      }
 403   3                      break;
 404   3                      case 0x90B2:
 405   3                      {
 406   4                              if (sysInfoSet.siliconChain == 0)
 407   4                              {
 408   5                                      write_dgus_vp(0x90A2, (uint8_t *)&variable, 1);
 409   5                              }
 410   4                              else
 411   4                              {
 412   5                                      write_dgus_vp(0x90A6, (uint8_t *)&variable, 1);
 413   5                              }
 414   4                      }
 415   3                      break;
 416   3                      case 0x90B3:
 417   3                      {
 418   4                              if (sysInfoSet.siliconChain == 0)
 419   4                              {
 420   5                                      write_dgus_vp(0x90A3, (uint8_t *)&variable, 1);
 421   5                              }
 422   4                              else
 423   4                              {
 424   5                                      write_dgus_vp(0x90A7, (uint8_t *)&variable, 1);
 425   5                              }
 426   4                      }
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 8   

 427   3                      break;
 428   3                      case 0x90B4:
 429   3                      {
 430   4                              if (sysInfoSet.siliconChain == 0)
 431   4                              {
 432   5                                      write_dgus_vp(0x90A4, (uint8_t *)&variable, 1);
 433   5                              }
 434   4                              else
 435   4                              {
 436   5                                      write_dgus_vp(0x90A8, (uint8_t *)&variable, 1);
 437   5                              }
 438   4                      }
 439   3                      break;
 440   3                      default:
 441   3                              break;
 442   3                      }
 443   2                      memset(variable, 0, 5);
 444   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)variable, variableChangedIndication.len);
 445   2      
 446   2                      variableChangedIndication.flag = 0;
 447   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 448   2              }
 449   1      
 450   1              {
 451   2                      if (sysInfoSet.sysVoltageGrade == SYSTEM_220V)
 452   2                      {
 453   3                              uint16_t sp; // 描述指针
 454   3                              sp = 0x90A1;
 455   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 456   3                              sp = 0x90A2;
 457   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 458   3                              sp = 0x90A3;
 459   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 460   3                              sp = 0x90A4;
 461   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 462   3                      }
 463   2                      else if (sysInfoSet.sysVoltageGrade == SYSTEM_110V)
 464   2                      {
 465   3                              uint16_t sp; // 描述指针
 466   3                              sp = 0x90A5;
 467   3                              write_dgus_vp(0x5000, (uint8_t *)&sp, 1);
 468   3                              sp = 0x90A6;
 469   3                              write_dgus_vp(0x5020, (uint8_t *)&sp, 1);
 470   3                              sp = 0x90A7;
 471   3                              write_dgus_vp(0x5040, (uint8_t *)&sp, 1);
 472   3                              sp = 0x90A8;
 473   3                              write_dgus_vp(0x5060, (uint8_t *)&sp, 1);
 474   3                      }
 475   2              }
 476   1      }
 477          
 478          void P22Func()
 479          {
 480   1              VariableChangedIndicationTypeDef variableChangedIndication;
 481   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 482   1              if (variableChangedIndication.flag == 0x5A)
 483   1              {
 484   2                      uint16_t variable[5];
 485   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 486   2                      switch (variableChangedIndication.addr)
 487   2                      {
 488   3                      case 0x8080:
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 9   

 489   3                              if (variable[0] == 1)
 490   3                              {
 491   4                                      read_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
 492   4                                      dgusToNorFlash(BATTERY_INFO_NORFLASH_ADDR, BATTERY_INFO_VP, BATTERY_SET_SIZE);
 493   4                                      modbusCenerate();
 494   4                              }
 495   3                              break;
 496   3                      case 0x9120:
 497   3                              if (variable[0] == 1)
 498   3                              {
 499   4                                      chargeModeSwitch(FLOAT_CHARGE);
 500   4                              }
 501   3                              break;
 502   3                      case 0x9121:
 503   3                              if (variable[0] == 1)
 504   3                              {
 505   4                                      chargeModeSwitch(EQUALIZE_CHARGE);
 506   4                              }
 507   3                              break;
 508   3                      default:
 509   3                              break;
 510   3                      }
 511   2                      memset(variable, 0, 5);
 512   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 513   2      
 514   2                      variableChangedIndication.flag = 0;
 515   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 516   2              }
 517   1      }
 518          
 519          void P26Func()
 520          {
 521   1              VariableChangedIndicationTypeDef variableChangedIndication;
 522   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 523   1              if (variableChangedIndication.flag == 0x5A)
 524   1              {
 525   2                      uint16_t variable[5];
 526   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 527   2                      switch (variableChangedIndication.addr)
 528   2                      {
 529   3                      case 0x9150:
 530   3                              if (variable[0] == 1)
 531   3                              {
 532   4                                      passwordLogin(26);
 533   4                              }
 534   3                              break;
 535   3                      case 0x9152:
 536   3                              if (variable[0] == 1)
 537   3                              {
 538   4                                      manager.loginFlag = 0;
 539   4                                      admin.loginFlag = 0;
 540   4                              }
 541   3                              break;
 542   3                      default:
 543   3                              break;
 544   3                      }
 545   2                      memset(variable, 0, 5);
 546   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 547   2                      variableChangedIndication.flag = 0;
 548   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 549   2              }
 550   1      
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 10  

 551   1              { // 当前登录用户显示
 552   2                      int16_t userNum;
 553   2                      if (admin.loginFlag)
 554   2                      {
 555   3                              userNum = 2;
 556   3                      }
 557   2                      else if (manager.loginFlag)
 558   2                      {
 559   3                              userNum = 1;
 560   3                      }
 561   2                      else
 562   2                      {
 563   3                              userNum = 0;
 564   3                      }
 565   2                      write_dgus_vp(0x9160, (uint8_t *)&userNum, 1);
 566   2              }
 567   1      }
 568          
 569          void P29Func()
 570          {
 571   1              VariableChangedIndicationTypeDef variableChangedIndication;
 572   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 573   1              if (variableChangedIndication.flag == 0x5A)
 574   1              {
 575   2                      uint16_t variable[5];
 576   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 577   2                      switch (variableChangedIndication.addr)
 578   2                      {
 579   3                      case 0x80C0:
 580   3                              if (variable[0] == 1)
 581   3                              {
 582   4                                      read_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, SPECIAL_PARA_SIZE);
 583   4                                      dgusToNorFlash(SPECIAL_PARA_NORFLASH_ADDR, SPECIAL_PARA_VP, SPECIAL_PARA_SIZE);
 584   4                                      modbusCenerate();
 585   4                              }
 586   3                              break;
 587   3                      // case 0x80C1:
 588   3                      //      if (variable[0] == 1)
 589   3                      //      {
 590   3                      //              manager.loginFlag = 0;
 591   3                      //              admin.loginFlag = 0;
 592   3                      //      }
 593   3                      //      break;
 594   3                      default:
 595   3                              break;
 596   3                      }
 597   2                      memset(variable, 0, 5);
 598   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 599   2                      variableChangedIndication.flag = 0;
 600   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 601   2              }
 602   1      }
 603          
 604          void P33Func()
 605          {
 606   1              static uint8_t timeModifyFlag = 0; // 时间修改标记
 607   1              VariableChangedIndicationTypeDef variableChangedIndication;
 608   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 609   1              if (variableChangedIndication.flag == 0x5A)
 610   1              {
 611   2                      uint16_t variable[5];
 612   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 11  

 613   2                      switch (variableChangedIndication.addr)
 614   2                      {
 615   3                      case 0x009D:
 616   3                      case 0x009E:
 617   3                      case 0x009F:
 618   3                              timeModifyFlag = 1;
 619   3                              break;
 620   3      
 621   3                      case 0x80E0:
 622   3                              if (variable[0] == 1)
 623   3                              {
 624   4                                      if (timeModifyFlag == 1) // 由于时间会不断变化，故仅在修改时间的情况下保存时间，避免修改屏保时写入时间
 625   4                                      {
 626   5                                              uint8_t rtcSetData[6];
 627   5                                              read_dgus_vp(0x9D, rtcSetData, 4);
 628   5                                              Write_RTC(rtcSetData);
 629   5                                              timeModifyFlag = 0;
 630   5                                      }
 631   4                                      read_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
 632   4                                      Nor_Flash_write(BACKLIGHT_TIME_NORFLASH_ADDR, (uint8_t *)&backLightTime, 2);
 633   4                                      write_dgus_vp(0x83, (uint8_t *)&backLightTime, 1);
 634   4                              }
 635   3                              break;
 636   3      
 637   3                      default:
 638   3                              break;
 639   3                      }
 640   2                      variableChangedIndication.flag = 0;
 641   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 642   2              }
 643   1      }
 644          
 645          void P35Func()
 646          {
 647   1              VariableChangedIndicationTypeDef variableChangedIndication;
 648   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 649   1              if (variableChangedIndication.flag == 0x5A)
 650   1              {
 651   2                      uint16_t variable[5];
 652   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 653   2                      switch (variableChangedIndication.addr)
 654   2                      {
 655   3                      case 0x8100:
 656   3                              if (variable[0] == 1)
 657   3                              {
 658   4                                      read_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
 659   4                                      dgusToNorFlash(SWITCH_MODULE_NORFLASH_ADDR, SWITCH_MODULE_SET_VP, SWITCH_MODULE_SIZE);
 660   4                                      modbusCenerate();
 661   4                              }
 662   3                              break;
 663   3      
 664   3                      default:
 665   3                              break;
 666   3                      }
 667   2                      memset(variable, 0, 5);
 668   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 669   2                      variableChangedIndication.flag = 0;
 670   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 671   2              }
 672   1      }
 673          
 674          void P39Func()
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 12  

 675          {
 676   1              VariableChangedIndicationTypeDef variableChangedIndication;
 677   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 678   1              if (variableChangedIndication.flag == 0x5A)
 679   1              {
 680   2                      uint16_t variable[5];
 681   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 682   2                      switch (variableChangedIndication.addr)
 683   2                      {
 684   3                      case 0x8120:
 685   3                              if (variable[0] == 1)
 686   3                              {
 687   4                                      read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
 688   4                                      dgusToNorFlash(BATTERY_SET_NORFLASH_ADDR, BATTERY_SET_VP, BATTERY_SET_SIZE);
 689   4                                      modbusCenerate();
 690   4                              }
 691   3                              break;
 692   3                      case 0x9250:
 693   3                              read_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet.batteryType, 1);
 694   3                              break;
 695   3                      case 0x9280:
 696   3                      {
 697   4                              if (batterySet.batteryType == XJ24)
 698   4                              {
 699   5                                      if (0 <= variable[0] && variable[0] <= 5)
 700   5                                      {
 701   6                                              uint16_t batteryModuleNum = variable[0];
 702   6                                              uint16_t cellNum;
 703   6                                              write_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 704   6      
 705   6                                              // 根据巡检数量设置电池节数上限
 706   6                                              read_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 707   6                                              if (cellNum > batteryModuleNum * 24)
 708   6                                              {
 709   7                                                      cellNum = batteryModuleNum * 24;
 710   7                                              }
 711   6                                              write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 712   6                                      }
 713   5                              }
 714   4                              else if (batterySet.batteryType == XJ55)
 715   4                              {
 716   5                                      if (0 <= variable[0] && variable[0] <= 2)
 717   5                                      {
 718   6                                              uint16_t batteryModuleNum = variable[0];
 719   6                                              uint16_t cellNum;
 720   6                                              write_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 721   6      
 722   6                                              // 根据巡检数量设置电池节数上限
 723   6                                              read_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 724   6                                              if (cellNum > batteryModuleNum * 55)
 725   6                                              {
 726   7                                                      cellNum = batteryModuleNum * 55;
 727   7                                              }
 728   6                                              write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 729   6                                      }
 730   5                              }
 731   4                      }
 732   3                      break;
 733   3                      case 0x9281:
 734   3                      {
 735   4                              if (batterySet.batteryType == XJ24)
 736   4                              {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 13  

 737   5                                      uint16_t batteryModuleNum;
 738   5                                      uint16_t cellNum = variable[0];
 739   5                                      read_dgus_vp(0x9260, (uint8_t *)&batteryModuleNum, 1);
 740   5                                      if (cellNum > batteryModuleNum * 24)
 741   5                                      {
 742   6                                              cellNum = batteryModuleNum * 24;
 743   6                                      }
 744   5                                      write_dgus_vp(0x9261, (uint8_t *)&cellNum, 1);
 745   5                              }
 746   4                              else if (batterySet.batteryType == XJ55)
 747   4                              {
 748   5                                      uint16_t batteryModuleNum;
 749   5                                      uint16_t cellNum = variable[0];
 750   5                                      read_dgus_vp(0x9270, (uint8_t *)&batteryModuleNum, 1);
 751   5                                      if (cellNum > batteryModuleNum * 55)
 752   5                                      {
 753   6                                              cellNum = batteryModuleNum * 55;
 754   6                                      }
 755   5                                      write_dgus_vp(0x9271, (uint8_t *)&cellNum, 1);
 756   5                              }
 757   4                      }
 758   3                      break;
 759   3                      case 0x9282:
 760   3                      {
 761   4                              if (batterySet.batteryType == XJ24)
 762   4                              {
 763   5                                      write_dgus_vp(0x9262, (uint8_t *)variable, 1);
 764   5                              }
 765   4                              else if (batterySet.batteryType == XJ55)
 766   4                              {
 767   5                                      write_dgus_vp(0x9272, (uint8_t *)variable, 1);
 768   5                              }
 769   4                      }
 770   3                      break;
 771   3                      case 0x9283:
 772   3                      {
 773   4                              if (batterySet.batteryType == XJ24)
 774   4                              {
 775   5                                      write_dgus_vp(0x9263, (uint8_t *)variable, 1);
 776   5                              }
 777   4                              else if (batterySet.batteryType == XJ55)
 778   4                              {
 779   5                                      write_dgus_vp(0x9273, (uint8_t *)variable, 1);
 780   5                              }
 781   4                      }
 782   3                      break;
 783   3                      case 0x9284:
 784   3                      {
 785   4                              if (batterySet.batteryType == XJ24)
 786   4                              {
 787   5                                      write_dgus_vp(0x9264, (uint8_t *)variable, 1);
 788   5                              }
 789   4                              else if (batterySet.batteryType == XJ55)
 790   4                              {
 791   5                                      write_dgus_vp(0x9274, (uint8_t *)variable, 1);
 792   5                              }
 793   4                      }
 794   3                      break;
 795   3                      case 0x9285:
 796   3                      {
 797   4                              if (batterySet.batteryType == XJ24)
 798   4                              {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 14  

 799   5                                      write_dgus_vp(0x9265, (uint8_t *)variable, 1);
 800   5                              }
 801   4                              else if (batterySet.batteryType == XJ55)
 802   4                              {
 803   5                                      write_dgus_vp(0x9275, (uint8_t *)variable, 1);
 804   5                              }
 805   4                      }
 806   3                      break;
 807   3                      case 0x9286:
 808   3                      {
 809   4                              if (batterySet.batteryType == XJ24)
 810   4                              {
 811   5                                      write_dgus_vp(0x9266, (uint8_t *)variable, 1);
 812   5                              }
 813   4                              else if (batterySet.batteryType == XJ55)
 814   4                              {
 815   5                                      write_dgus_vp(0x9276, (uint8_t *)variable, 1);
 816   5                              }
 817   4                      }
 818   3                      break;
 819   3                      default:
 820   3                              break;
 821   3                      }
 822   2                      // memset(variable, 0, 5);
 823   2                      // write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 824   2                      variableChangedIndication.flag = 0;
 825   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 826   2              }
 827   1              {
 828   2                      if (batterySet.batteryType == XJ24)
 829   2                      {
 830   3                              uint16_t sp; // 描述指针
 831   3                              sp = 0x9260;
 832   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
 833   3                              sp = 0x9261;
 834   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
 835   3                              sp = 0x9262;
 836   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
 837   3                              sp = 0x9263;
 838   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
 839   3                              sp = 0x9264;
 840   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
 841   3                              sp = 0x9265;
 842   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
 843   3                              sp = 0x9266;
 844   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
 845   3                      }
 846   2                      else if (batterySet.batteryType == XJ55)
 847   2                      {
 848   3                              uint16_t sp; // 描述指针
 849   3                              sp = 0x9270;
 850   3                              write_dgus_vp(0x5200, (uint8_t *)&sp, 1);
 851   3                              sp = 0x9271;
 852   3                              write_dgus_vp(0x5220, (uint8_t *)&sp, 1);
 853   3                              sp = 0x9272;
 854   3                              write_dgus_vp(0x5240, (uint8_t *)&sp, 1);
 855   3                              sp = 0x9273;
 856   3                              write_dgus_vp(0x5260, (uint8_t *)&sp, 1);
 857   3                              sp = 0x9274;
 858   3                              write_dgus_vp(0x5280, (uint8_t *)&sp, 1);
 859   3                              sp = 0x9275;
 860   3                              write_dgus_vp(0x52A0, (uint8_t *)&sp, 1);
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 15  

 861   3                              sp = 0x9276;
 862   3                              write_dgus_vp(0x52C0, (uint8_t *)&sp, 1);
 863   3                      }
 864   2              }
 865   1      }
 866          
 867          void p42Func()
 868          {
 869   1              VariableChangedIndicationTypeDef variableChangedIndication;
 870   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 871   1              if (variableChangedIndication.flag == 0x5A)
 872   1              {
 873   2                      uint16_t variable[5];
 874   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 875   2                      switch (variableChangedIndication.addr)
 876   2                      {
 877   3                      case 0x8140:
 878   3                              if (variable[0] == 1)
 879   3                              {
 880   4                                      read_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
 881   4                                      dgusToNorFlash(INSULATION_SET_NORFLASH_ADDR, INSULATION_SET_VP, INSULATION_SET_SIZE);
 882   4                                      modbusCenerate();
 883   4                              }
 884   3                              break;
 885   3      
 886   3                      default:
 887   3                              break;
 888   3                      }
 889   2                      memset(variable, 0, 5);
 890   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 891   2                      variableChangedIndication.flag = 0;
 892   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 893   2              }
 894   1      }
 895          
 896          void p44Func()
 897          {
 898   1              VariableChangedIndicationTypeDef variableChangedIndication;
 899   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 900   1              if (variableChangedIndication.flag == 0x5A)
 901   1              {
 902   2                      uint16_t variable[5];
 903   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 904   2                      switch (variableChangedIndication.addr)
 905   2                      {
 906   3                      case 0x8160:
 907   3                              if (variable[0] == 1)
 908   3                              {
 909   4                                      read_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
 910   4                                      dgusToNorFlash(CHARGE_MODULE_SET_NORFLASH_ADDR, CHARGE_MODULE_SET_VP, CHARGE_MODULE_SET_SIZE);
 911   4                                      modbusCenerate();
 912   4                              }
 913   3                              break;
 914   3      
 915   3                      default:
 916   3                              break;
 917   3                      }
 918   2                      memset(variable, 0, 5);
 919   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 920   2                      variableChangedIndication.flag = 0;
 921   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 922   2              }
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 16  

 923   1      }
 924          
 925          void p48Func()
 926          {
 927   1              VariableChangedIndicationTypeDef variableChangedIndication;
 928   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 929   1              if (variableChangedIndication.flag == 0x5A)
 930   1              {
 931   2                      uint16_t variable[5];
 932   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 933   2                      switch (variableChangedIndication.addr)
 934   2                      {
 935   3                      case 0x8180:
 936   3                              if (variable[0] == 1)
 937   3                              {
 938   4                                      read_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
 939   4                                      dgusToNorFlash(DC_CONVERTER_SET_NORFLASH_ADDR, DC_CONVERTER_SET_VP, DC_CONVERTER_SET_SIZE);
 940   4                                      modbusCenerate();
 941   4                              }
 942   3                              break;
 943   3                      case 0x9360:
 944   3                              if (variable[0] == 1)
 945   3                              {
 946   4                                      if (DC_ConverterSet.Num > 0)
 947   4                                      {
 948   5                                              static MMODBUS DC_moduleOnOffCmd;
 949   5                                              static uint16_t DC_module_DI;
 950   5                                              dc_4850_Module[0].DI.onOffState = !dc_4850_Module[0].DI.onOffState;
 951   5                                              DC_module_DI = dc_4850_Module[0].DI.onOffState;
 952   5                                              DC_moduleOnOffCmd.SlaveAddr = 0xFE;
 953   5                                              DC_moduleOnOffCmd.mode = 0x00;
 954   5                                              DC_moduleOnOffCmd.flag = 0x00;
 955   5                                              DC_moduleOnOffCmd.Order = 0x06;
 956   5                                              DC_moduleOnOffCmd.Length = 1;
 957   5                                              DC_moduleOnOffCmd.reserved = 0x00;
 958   5                                              DC_moduleOnOffCmd.waitTime = 1000;
 959   5                                              DC_moduleOnOffCmd.VPaddr = 0;
 960   5                                              DC_moduleOnOffCmd.ModbusReg = 0x0005;
 961   5                                              DC_moduleOnOffCmd.databuff = &DC_module_DI;
 962   5                                              pushToEmergency(&DC_moduleOnOffCmd);
 963   5                                      }
 964   4                              }
 965   3                              break;
 966   3      
 967   3                      default:
 968   3                              break;
 969   3                      }
 970   2                      memset(variable, 0, 5);
 971   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 972   2                      variableChangedIndication.flag = 0;
 973   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 974   2              }
 975   1              {
 976   2                      uint16_t DC_Module_OnOffState = dc_4850_Module[0].DI.onOffState ? 1 : 0;
 977   2                      write_dgus_vp(0x9361, (uint8_t *)&DC_Module_OnOffState, 1);
 978   2              }
 979   1      }
 980          
 981          void p50Func()
 982          {
 983   1              VariableChangedIndicationTypeDef variableChangedIndication;
 984   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 17  

 985   1              if (variableChangedIndication.flag == 0x5A)
 986   1              {
 987   2                      uint16_t variable[5];
 988   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
 989   2                      switch (variableChangedIndication.addr)
 990   2                      {
 991   3                      case 0x81A0:
 992   3                              if (variable[0] == 1)
 993   3                              {
 994   4                                      read_dgus_vp(UPS_INV_SET_VP, (uint8_t *)&UPS_INV_Set, UPS_INV_SET_SIZE);
 995   4                                      dgusToNorFlash(UPS_INV_SET_NORFLASH_ADDR, UPS_INV_SET_VP, UPS_INV_SET_SIZE);
 996   4                                      modbusCenerate();
 997   4                              }
 998   3                              break;
 999   3      
1000   3                      default:
1001   3                              break;
1002   3                      }
1003   2                      memset(variable, 0, 5);
1004   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1005   2                      variableChangedIndication.flag = 0;
1006   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1007   2              }
1008   1      }
1009          
1010          void recovery(void)
1011          {
1012   1              AC_InfoSet.AC_InputChannel = 1;
1013   1              AC_InfoSet.threePhaseAC_VolMax = 4500;
1014   1              AC_InfoSet.threePhaseAC_VolMin = 3230;
1015   1              AC_InfoSet.singlePhaseAC_VolMax = 2800;
1016   1              AC_InfoSet.singlePhaseAC_VolMin = 1870;
1017   1              Nor_Flash_write(AC_INFO_NORFLASH_ADDR, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1018   1              write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
1019   1      
1020   1              DC_InfoSet.busVoltMax_220V = 2600;
1021   1              DC_InfoSet.busVoltMin_220V = 2000;
1022   1              DC_InfoSet.moduleVoltMax_220V = 2420;
1023   1              DC_InfoSet.moduleVoltMin_220V = 2000;
1024   1              DC_InfoSet.busVoltMax_110V = 1300;
1025   1              DC_InfoSet.busVoltMin_110V = 1000;
1026   1              DC_InfoSet.moduleVoltMax_110V = 1200;
1027   1              DC_InfoSet.moduleVoltMin_110V = 1000;
1028   1              DC_InfoSet.loadHallRatio = 1000;
1029   1              DC_InfoSet.batteryHallRatio = 1000;
1030   1              Nor_Flash_write(DC_INFO_NORFLASH_ADDR, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1031   1              write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
1032   1      }
1033          
1034          void p52Func()
1035          {
1036   1              VariableChangedIndicationTypeDef variableChangedIndication;
1037   1              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1038   1              if (variableChangedIndication.flag == 0x5A)
1039   1              {
1040   2                      uint16_t variable[5];
1041   2                      read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1042   2                      switch (variableChangedIndication.addr)
1043   2                      {
1044   3                      case 0x9400:
1045   3                              if (variable[0] == 1)
1046   3                              {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 18  

1047   4                                      recovery();
1048   4                              }
1049   3                              break;
1050   3                      case 0x9401:
1051   3                              if (variable[0] == 1)
1052   3                              {
1053   4                                      // 清楚记录
1054   4                              }
1055   3                              break;
1056   3                      case 0x9402:
1057   3                              if (variable[0] == 1)
1058   3                              {
1059   4                                      // 重启触摸屏
1060   4                                      write_dgus_vp(0x04, (uint8_t *)"\x55\xAA\x5A\xA5", 2);
1061   4                              }
1062   3                              break;
1063   3      
1064   3                      default:
1065   3                              break;
1066   3                      }
1067   2                      memset(variable, 0, 5);
1068   2                      write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1069   2                      variableChangedIndication.flag = 0;
1070   2                      write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1071   2              }
1072   1      }
1073          
1074          void p68Func(void)
1075          {
1076   1      
1077   1              if (AC_InfoSet.singlePhaseThreePhaseSelection == THREE_PHASE)
1078   1              {
1079   2                      uint16_t sp;
1080   2                      sp = 0x94A0;
1081   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1082   2                      // sp = 0x94A0;
1083   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1084   2                      sp = 0x94A1;
1085   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1086   2                      sp = 0x94A3;
1087   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1088   2                      // sp = 0x94A4;
1089   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1090   2                      sp = 0x94A5;
1091   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
1092   2      
1093   2                      write_dgus_vp(0x94A0, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 6);
1094   2              }
1095   1              else if (AC_InfoSet.singlePhaseThreePhaseSelection == SINGLE_PHASE)
1096   1              {
1097   2                      uint16_t sp;
1098   2                      sp = 0xFFFF;
1099   2                      write_dgus_vp(0x5400, (uint8_t *)&sp, 1);
1100   2                      // sp = 0x94A0;
1101   2                      // write_dgus_vp(0x5420, (uint8_t *)&sp, 1);
1102   2                      sp = 0xFFFF;
1103   2                      write_dgus_vp(0x5440, (uint8_t *)&sp, 1);
1104   2                      sp = 0xFFFF;
1105   2                      write_dgus_vp(0x5460, (uint8_t *)&sp, 1);
1106   2                      // sp = 0x94A4;
1107   2                      // write_dgus_vp(0x5480, (uint8_t *)&sp, 1);
1108   2                      sp = 0xFFFF;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 19  

1109   2                      write_dgus_vp(0x54A0, (uint8_t *)&sp, 1);
1110   2      
1111   2                      write_dgus_vp(0x94A1, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1112   2                      write_dgus_vp(0x94A4, (uint8_t *)&synthesisCollection.AC_channel_1_Uab, 1);
1113   2              }
1114   1      }
1115          
1116          void p70Func(void)
1117          {
1118   1              {
1119   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1120   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1121   2                      if (variableChangedIndication.flag == 0x5A)
1122   2                      {
1123   3                              uint16_t variable[5];
1124   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1125   3                              switch (variableChangedIndication.addr)
1126   3                              {
1127   4                              case 0x9530:
1128   4                                      if (variable[0] == 1)
1129   4                                      {
1130   5                                              if (chargeModuleSet.moduleNum >= 1)
1131   5                                              {
1132   6                                                      static MMODBUS chargeModuleOnOff = {0x01, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9540, 0x06, NULL};
1133   6                                                      chargeModule[0].DI.onOffState = !chargeModule[0].DI.onOffState;
1134   6                                                      write_dgus_vp(0x9540, (uint8_t *)&chargeModule[0].DI, 1);
1135   6                                                      pushToEmergency(&chargeModuleOnOff);
1136   6                                              }
1137   5                                      }
1138   4                                      break;
1139   4                              case 0x9531:
1140   4                                      if (variable[0] == 1)
1141   4                                      {
1142   5                                              if (chargeModuleSet.moduleNum >= 2)
1143   5                                              {
1144   6                                                      static MMODBUS chargeModuleOnOff = {0x02, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9541, 0x06, NULL};
1145   6                                                      chargeModule[1].DI.onOffState = !chargeModule[1].DI.onOffState;
1146   6                                                      write_dgus_vp(0x9541, (uint8_t *)&chargeModule[1].DI, 1);
1147   6                                                      pushToEmergency(&chargeModuleOnOff);
1148   6                                              }
1149   5                                      }
1150   4                                      break;
1151   4                              case 0x9532:
1152   4                                      if (variable[0] == 1)
1153   4                                      {
1154   5                                              if (chargeModuleSet.moduleNum >= 3)
1155   5                                              {
1156   6                                                      static MMODBUS chargeModuleOnOff = {0x03, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9542, 0x06, NULL};
1157   6                                                      chargeModule[2].DI.onOffState = !chargeModule[2].DI.onOffState;
1158   6                                                      write_dgus_vp(0x9542, (uint8_t *)&chargeModule[2].DI, 1);
1159   6                                                      pushToEmergency(&chargeModuleOnOff);
1160   6                                              }
1161   5                                      }
1162   4                                      break;
1163   4                              case 0x9533:
1164   4                                      if (variable[0] == 1)
1165   4                                      {
1166   5                                              if (chargeModuleSet.moduleNum >= 4)
1167   5                                              {
1168   6                                                      static MMODBUS chargeModuleOnOff = {0x04, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9543, 0x06, NULL};
1169   6                                                      chargeModule[3].DI.onOffState = !chargeModule[3].DI.onOffState;
1170   6                                                      write_dgus_vp(0x9543, (uint8_t *)&chargeModule[3].DI, 1);
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 20  

1171   6                                                      pushToEmergency(&chargeModuleOnOff);
1172   6                                              }
1173   5                                      }
1174   4                                      break;
1175   4                              case 0x9534:
1176   4                                      if (variable[0] == 1)
1177   4                                      {
1178   5                                              if (chargeModuleSet.moduleNum >= 5)
1179   5                                              {
1180   6                                                      static MMODBUS chargeModuleOnOff = {0x05, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9544, 0x06, NULL};
1181   6                                                      chargeModule[4].DI.onOffState = !chargeModule[4].DI.onOffState;
1182   6                                                      write_dgus_vp(0x9544, (uint8_t *)&chargeModule[4].DI, 1);
1183   6                                                      pushToEmergency(&chargeModuleOnOff);
1184   6                                              }
1185   5                                      }
1186   4                                      break;
1187   4                              case 0x9535:
1188   4                                      if (variable[0] == 1)
1189   4                                      {
1190   5                                              if (chargeModuleSet.moduleNum >= 6)
1191   5                                              {
1192   6                                                      static MMODBUS chargeModuleOnOff = {0x06, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9545, 0x06, NULL};
1193   6                                                      chargeModule[5].DI.onOffState = !chargeModule[5].DI.onOffState;
1194   6                                                      write_dgus_vp(0x9545, (uint8_t *)&chargeModule[5].DI, 1);
1195   6                                                      pushToEmergency(&chargeModuleOnOff);
1196   6                                              }
1197   5                                      }
1198   4                                      break;
1199   4                              case 0x9536:
1200   4                                      if (variable[0] == 1)
1201   4                                      {
1202   5                                              if (chargeModuleSet.moduleNum >= 7)
1203   5                                              {
1204   6                                                      static MMODBUS chargeModuleOnOff = {0x07, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9546, 0x06, NULL};
1205   6                                                      chargeModule[6].DI.onOffState = !chargeModule[6].DI.onOffState;
1206   6                                                      write_dgus_vp(0x9546, (uint8_t *)&chargeModule[6].DI, 1);
1207   6                                                      pushToEmergency(&chargeModuleOnOff);
1208   6                                              }
1209   5                                      }
1210   4                                      break;
1211   4                              case 0x9537:
1212   4                                      if (variable[0] == 1)
1213   4                                      {
1214   5                                              if (chargeModuleSet.moduleNum >= 8)
1215   5                                              {
1216   6                                                      static MMODBUS chargeModuleOnOff = {0x08, 0x00, 0x00, 0x05, 0x01, 0x00, 1000, 0x9547, 0x06, NULL};
1217   6                                                      chargeModule[7].DI.onOffState = !chargeModule[7].DI.onOffState;
1218   6                                                      write_dgus_vp(0x9547, (uint8_t *)&chargeModule[7].DI, 1);
1219   6                                                      pushToEmergency(&chargeModuleOnOff);
1220   6                                              }
1221   5                                      }
1222   4                                      break;
1223   4      
1224   4                              default:
1225   4                                      break;
1226   4                              }
1227   3                              memset(variable, 0, 5);
1228   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1229   3                              variableChangedIndication.flag = 0;
1230   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1231   3                      }
1232   2              }
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 21  

1233   1              {
1234   2                      if (chargeModuleSet.moduleNum >= 1)
1235   2                      {
1236   3                              write_dgus_vp(0x9500, (uint8_t *)&chargeModule[0].outputVolt, 3);
1237   3                              write_dgus_vp(0x9503, (uint8_t *)&chargeModule[0].DI, 1);
1238   3                              // {
1239   3                              //      uint16_t temp = chargeModule.onOffState;
1240   3                              //      write_dgus_vp(0x9503, (uint8_t *)&temp, 1);
1241   3                              // }
1242   3                              {
1243   4                                      uint16_t temp = 0;
1244   4                                      write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1245   4                              }
1246   3                      }
1247   2                      else
1248   2                      {
1249   3                              uint16_t temp = 1;
1250   3                              write_dgus_vp(0x9520, (uint8_t *)&temp, 1);
1251   3                      }
1252   2                      if (chargeModuleSet.moduleNum >= 2)
1253   2                      {
1254   3                              write_dgus_vp(0x9504, (uint8_t *)&chargeModule[1].outputVolt, 3);
1255   3                              write_dgus_vp(0x9507, (uint8_t *)&chargeModule[1].DI, 1);
1256   3                              // {
1257   3                              //      uint16_t temp = chargeModule[1].DI.onOffState;
1258   3                              //      write_dgus_vp(0x9507, (uint8_t *)&temp, 1);
1259   3                              // }
1260   3                              {
1261   4                                      uint16_t temp = 0;
1262   4                                      write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
1263   4                              }
1264   3                      }
1265   2                      else
1266   2                      {
1267   3                              uint16_t temp = 1;
1268   3                              write_dgus_vp(0x9521, (uint8_t *)&temp, 1);
1269   3                      }
1270   2                      if (chargeModuleSet.moduleNum >= 3)
1271   2                      {
1272   3                              write_dgus_vp(0x9508, (uint8_t *)&chargeModule[2].outputVolt, 3);
1273   3                              write_dgus_vp(0x950B, (uint8_t *)&chargeModule[2].DI, 1);
1274   3                              // {
1275   3                              //      uint16_t temp = chargeModule[2].DI.onOffState;
1276   3                              //      write_dgus_vp(0x950B, (uint8_t *)&temp, 1);
1277   3                              // }
1278   3                              {
1279   4                                      uint16_t temp = 0;
1280   4                                      write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1281   4                              }
1282   3                      }
1283   2                      else
1284   2                      {
1285   3                              uint16_t temp = 1;
1286   3                              write_dgus_vp(0x9522, (uint8_t *)&temp, 1);
1287   3                      }
1288   2                      if (chargeModuleSet.moduleNum >= 4)
1289   2                      {
1290   3                              write_dgus_vp(0x950C, (uint8_t *)&chargeModule[3].outputVolt, 3);
1291   3                              write_dgus_vp(0x950F, (uint8_t *)&chargeModule[3].DI, 1);
1292   3                              // {
1293   3                              //      uint16_t temp = chargeModule[3].DI.onOffState;
1294   3                              //      write_dgus_vp(0x950F, (uint8_t *)&temp, 1);
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 22  

1295   3                              // }
1296   3                              {
1297   4                                      uint16_t temp = 0;
1298   4                                      write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1299   4                              }
1300   3                      }
1301   2                      else
1302   2                      {
1303   3                              uint16_t temp = 1;
1304   3                              write_dgus_vp(0x9523, (uint8_t *)&temp, 1);
1305   3                      }
1306   2                      if (chargeModuleSet.moduleNum >= 5)
1307   2                      {
1308   3                              write_dgus_vp(0x9510, (uint8_t *)&chargeModule[4].outputVolt, 3);
1309   3                              write_dgus_vp(0x9513, (uint8_t *)&chargeModule[4].DI, 1);
1310   3                              // {
1311   3                              //      uint16_t temp = chargeModule[4].DI.onOffState;
1312   3                              //      write_dgus_vp(0x9513, (uint8_t *)&temp, 1);
1313   3                              // }
1314   3                              {
1315   4                                      uint16_t temp = 0;
1316   4                                      write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1317   4                              }
1318   3                      }
1319   2                      else
1320   2                      {
1321   3                              uint16_t temp = 1;
1322   3                              write_dgus_vp(0x9524, (uint8_t *)&temp, 1);
1323   3                      }
1324   2                      if (chargeModuleSet.moduleNum >= 6)
1325   2                      {
1326   3                              write_dgus_vp(0x9514, (uint8_t *)&chargeModule[5].outputVolt, 3);
1327   3                              write_dgus_vp(0x9517, (uint8_t *)&chargeModule[5].DI, 1);
1328   3                              // {
1329   3                              //      uint16_t temp = chargeModule[5].DI.onOffState;
1330   3                              //      write_dgus_vp(0x9517, (uint8_t *)&temp, 1);
1331   3                              // }
1332   3                              {
1333   4                                      uint16_t temp = 0;
1334   4                                      write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1335   4                              }
1336   3                      }
1337   2                      else
1338   2                      {
1339   3                              uint16_t temp = 1;
1340   3                              write_dgus_vp(0x9525, (uint8_t *)&temp, 1);
1341   3                      }
1342   2                      if (chargeModuleSet.moduleNum >= 7)
1343   2                      {
1344   3                              write_dgus_vp(0x9518, (uint8_t *)&chargeModule[6].outputVolt, 3);
1345   3                              write_dgus_vp(0x951B, (uint8_t *)&chargeModule[6].DI, 1);
1346   3                              // {
1347   3                              //      uint16_t temp = chargeModule[6].DI.onOffState;
1348   3                              //      write_dgus_vp(0x951B, (uint8_t *)&temp, 1);
1349   3                              // }
1350   3                              {
1351   4                                      uint16_t temp = 0;
1352   4                                      write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1353   4                              }
1354   3                      }
1355   2                      else
1356   2                      {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 23  

1357   3                              uint16_t temp = 1;
1358   3                              write_dgus_vp(0x9526, (uint8_t *)&temp, 1);
1359   3                      }
1360   2                      if (chargeModuleSet.moduleNum >= 8)
1361   2                      {
1362   3                              write_dgus_vp(0x951C, (uint8_t *)&chargeModule[7].outputVolt, 3);
1363   3                              write_dgus_vp(0x951F, (uint8_t *)&chargeModule[7].DI, 1);
1364   3                              // {
1365   3                              //      uint16_t temp = chargeModule[7].DI.onOffState;
1366   3                              //      write_dgus_vp(0x951F, (uint8_t *)&temp, 1);
1367   3                              // }
1368   3                              {
1369   4                                      uint16_t temp = 0;
1370   4                                      write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
1371   4                              }
1372   3                      }
1373   2                      else
1374   2                      {
1375   3                              uint16_t temp = 1;
1376   3                              write_dgus_vp(0x9527, (uint8_t *)&temp, 1);
1377   3                      }
1378   2              }
1379   1      }
1380          
1381          void p72Func(void)
1382          {
1383   1              uint16_t swState;
1384   1              uint16_t i;
1385   1              for (i = 0; i < switchModuleSet.synthesisCollection.alarmChannelNum; i++)
1386   1              {
1387   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1388   2                      {
1389   3                              swState = FAULT;
1390   3                      }
1391   2                      else
1392   2                      {
1393   3                              swState = NORMAL;
1394   3                      }
1395   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1396   2              }
1397   1              for (; i < 12; i++)
1398   1              {
1399   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1400   2                      {
1401   3                              swState = CLOSING;
1402   3                      }
1403   2                      else
1404   2                      {
1405   3                              swState = OPENING;
1406   3                      }
1407   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1408   2              }
1409   1              for (; i < 13; i++)
1410   1              {
1411   2                      if (((synthesisCollection.sw_01to16 >> i) & 0x0001) == switchModuleSet.synthesisCollection.switchAccessM
             -ode)
1412   2                      {
1413   3                              swState = FAULT;
1414   3                      }
1415   2                      else
1416   2                      {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 24  

1417   3                              swState = NORMAL;
1418   3                      }
1419   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1420   2              }
1421   1              for (; i < 15; i++)
1422   1              {
1423   2                      if ((synthesisCollection.sw_01to16 >> i) & 0x0001)
1424   2                      {
1425   3                              swState = CLOSING;
1426   3                      }
1427   2                      else
1428   2                      {
1429   3                              swState = OPENING;
1430   3                      }
1431   2                      write_dgus_vp(0x95A0 + i, (uint8_t *)&swState, 1);
1432   2              }
1433   1      }
1434          
1435          void p75Func(void)
1436          {
1437   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1438   1              {
1439   2                      uint16_t i;
1440   2                      for (i = 0; i < 16; i++)
1441   2                      {
1442   3                              uint16_t swState;
1443   3                              swState = (remoteControlModule_ARD[0].sw1to16 >> i) & 0x01;
1444   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1445   3                      }
1446   2              }
1447   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1448   1              {
1449   2                      uint16_t i;
1450   2                      for (i = 0; i < 16; i++)
1451   2                      {
1452   3                              uint16_t swState;
1453   3                              swState = (remoteControlModule_TH[0].sw1to16 >> i) & 0x01;
1454   3                              write_dgus_vp(0x9750 + i, (uint8_t *)&swState, 1);
1455   3                      }
1456   2              }
1457   1              {
1458   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1459   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1460   2                      if (variableChangedIndication.flag == 0x5A)
1461   2                      {
1462   3                              uint16_t variable[5];
1463   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1464   3                              switch (variableChangedIndication.addr)
1465   3                              {
1466   4                              case 0x9760:
1467   4                              case 0x9761:
1468   4                              case 0x9762:
1469   4                              case 0x9763:
1470   4                              case 0x9764:
1471   4                              case 0x9765:
1472   4                              case 0x9766:
1473   4                              case 0x9767:
1474   4                              case 0x9768:
1475   4                              case 0x9769:
1476   4                              case 0x976A:
1477   4                              case 0x976B:
1478   4                              case 0x976C:
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 25  

1479   4                              case 0x976D:
1480   4                              case 0x976E:
1481   4                              case 0x976F:
1482   4                              {
1483   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1484   5                                      {
1485   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
1486   6                                              if (variable[0] == 0)
1487   6                                              {
1488   7                                                      static MMODBUS rtuSwOff[16];
1489   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1490   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
1491   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1492   7                                                      rtuSwOff[offset].mode = 0x00;
1493   7                                                      rtuSwOff[offset].flag = 0x00;
1494   7                                                      rtuSwOff[offset].Order = 0x06;
1495   7                                                      rtuSwOff[offset].Length = 0x01;
1496   7                                                      rtuSwOff[offset].reserved = 0x00;
1497   7                                                      rtuSwOff[offset].waitTime = 1000;
1498   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
1499   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
1500   7                                                      rtuSwOff[offset].databuff = NULL;
1501   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1502   7                                                      pushToEmergency(rtuSwOff + offset);
1503   7                                              }
1504   6                                              else if (variable[0] == 1)
1505   6                                              {
1506   7                                                      static MMODBUS rtuSwOn[16];
1507   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1508   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
1509   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1510   7                                                      rtuSwOn[offset].mode = 0x00;
1511   7                                                      rtuSwOn[offset].flag = 0x00;
1512   7                                                      rtuSwOn[offset].Order = 0x06;
1513   7                                                      rtuSwOn[offset].Length = 0x01;
1514   7                                                      rtuSwOn[offset].reserved = 0x00;
1515   7                                                      rtuSwOn[offset].waitTime = 1000;
1516   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1517   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
1518   7                                                      rtuSwOn[offset].databuff = NULL;
1519   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&remoteControlModule_ARD[0].sw1to16, 1);
1520   7                                                      pushToEmergency(rtuSwOn + offset);
1521   7                                              }
1522   6                                      }
1523   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1524   5                                      {
1525   6                                              if (variable[0] == 0)
1526   6                                              {
1527   7                                                      static MMODBUS rtuSwOff[16];
1528   7                                                      uint16_t OffVal = 0x0000;
1529   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1530   7                                                      rtuSwOff[offset].SlaveAddr = 0xD0;
1531   7                                                      rtuSwOff[offset].mode = 0x00;
1532   7                                                      rtuSwOff[offset].flag = 0x00;
1533   7                                                      rtuSwOff[offset].Order = 0x06;
1534   7                                                      rtuSwOff[offset].Length = 0x01;
1535   7                                                      rtuSwOff[offset].reserved = 0x00;
1536   7                                                      rtuSwOff[offset].waitTime = 1000;
1537   7                                                      rtuSwOff[offset].VPaddr = 0x9780 + offset;
1538   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
1539   7                                                      rtuSwOff[offset].databuff = NULL;
1540   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OffVal, 1);
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 26  

1541   7                                                      pushToEmergency(rtuSwOff + offset);
1542   7                                              }
1543   6                                              else if (variable[0] == 1)
1544   6                                              {
1545   7                                                      static MMODBUS rtuSwOn[16];
1546   7                                                      uint16_t OnVal = 0xFFFF;
1547   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x9760);
1548   7                                                      rtuSwOn[offset].SlaveAddr = 0xD0;
1549   7                                                      rtuSwOn[offset].mode = 0x00;
1550   7                                                      rtuSwOn[offset].flag = 0x00;
1551   7                                                      rtuSwOn[offset].Order = 0x06;
1552   7                                                      rtuSwOn[offset].Length = 0x01;
1553   7                                                      rtuSwOn[offset].reserved = 0x00;
1554   7                                                      rtuSwOn[offset].waitTime = 1000;
1555   7                                                      rtuSwOn[offset].VPaddr = 0x9780 + offset;
1556   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
1557   7                                                      rtuSwOn[offset].databuff = NULL;
1558   7                                                      write_dgus_vp(0x9780 + offset, (uint8_t *)&OnVal, 1);
1559   7                                                      pushToEmergency(rtuSwOn + offset);
1560   7                                              }
1561   6                                      }
1562   5                              }
1563   4                              break;
1564   4      
1565   4                              default:
1566   4                                      break;
1567   4                              }
1568   3                              memset(variable, 0, 5);
1569   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1570   3                              variableChangedIndication.flag = 0;
1571   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
1572   3                      }
1573   2              }
1574   1      }
1575          
1576          void p76Func(void)
1577          {
1578   1              uint16_t swState;
1579   1              uint16_t i;
1580   1              for (i = 0; i < 30; i++)
1581   1              {
1582   2                      if (i < switchModuleSet.switchModule.sw_1_AlarmChannelNum)
1583   2                      {
1584   3                              if ((switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.sw_1_AccessMo
             -de)
1585   3                              {
1586   4                                      swState = FAULT;
1587   4                              }
1588   3                              else
1589   3                              {
1590   4                                      swState = NORMAL;
1591   4                              }
1592   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1593   3                      }
1594   2                      else
1595   2                      {
1596   3                              if (switchModule[0].sw_u16[i / 16] >> (i % 16) & 0x0001)
1597   3                              {
1598   4                                      swState = CLOSING;
1599   4                              }
1600   3                              else
1601   3                              {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 27  

1602   4                                      swState = OPENING;
1603   4                              }
1604   3                              write_dgus_vp(0x9600 + i, (uint8_t *)&swState, 1);
1605   3                      }
1606   2              }
1607   1      }
1608          void p77Func(void)
1609          {
1610   1              uint16_t swState;
1611   1              uint16_t i;
1612   1              for (i = 0; i < 30; i++)
1613   1              {
1614   2                      if (i < switchModuleSet.switchModule.sw_2_AlarmChannelNum)
1615   2                      {
1616   3      
1617   3                              if ((switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.sw_2_AccessMo
             -de)
1618   3                              {
1619   4                                      swState = FAULT;
1620   4                              }
1621   3                              else
1622   3                              {
1623   4                                      swState = NORMAL;
1624   4                              }
1625   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1626   3                      }
1627   2                      else
1628   2                      {
1629   3                              if (switchModule[1].sw_u16[i / 16] >> (i % 16) & 0x0001)
1630   3                              {
1631   4                                      swState = CLOSING;
1632   4                              }
1633   3                              else
1634   3                              {
1635   4                                      swState = OPENING;
1636   4                              }
1637   3                              write_dgus_vp(0x9650 + i, (uint8_t *)&swState, 1);
1638   3                      }
1639   2              }
1640   1      }
1641          void p78Func(void)
1642          {
1643   1              uint16_t swState;
1644   1              uint16_t i;
1645   1              for (i = 0; i < 30; i++)
1646   1              {
1647   2                      if (i < switchModuleSet.switchModule.sw_3_AlarmChannelNum)
1648   2                      {
1649   3      
1650   3                              if ((switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.sw_3_AccessMo
             -de)
1651   3                              {
1652   4                                      swState = FAULT;
1653   4                              }
1654   3                              else
1655   3                              {
1656   4                                      swState = NORMAL;
1657   4                              }
1658   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1659   3                      }
1660   2                      else
1661   2                      {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 28  

1662   3                              if (switchModule[2].sw_u16[i / 16] >> (i % 16) & 0x0001)
1663   3                              {
1664   4                                      swState = CLOSING;
1665   4                              }
1666   3                              else
1667   3                              {
1668   4                                      swState = OPENING;
1669   4                              }
1670   3                              write_dgus_vp(0x96A0 + i, (uint8_t *)&swState, 1);
1671   3                      }
1672   2              }
1673   1      }
1674          void p79Func(void)
1675          {
1676   1              uint16_t swState;
1677   1              uint16_t i;
1678   1              for (i = 0; i < 30; i++)
1679   1              {
1680   2                      if (i < switchModuleSet.switchModule.sw_4_AlarmChannelNum)
1681   2                      {
1682   3      
1683   3                              if ((switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001) == switchModuleSet.switchModule.sw_4_AccessMo
             -de)
1684   3                              {
1685   4                                      swState = FAULT;
1686   4                              }
1687   3                              else
1688   3                              {
1689   4                                      swState = NORMAL;
1690   4                              }
1691   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
1692   3                      }
1693   2                      else
1694   2                      {
1695   3                              if (switchModule[3].sw_u16[i / 16] >> (i % 16) & 0x0001)
1696   3                              {
1697   4                                      swState = CLOSING;
1698   4                              }
1699   3                              else
1700   3                              {
1701   4                                      swState = OPENING;
1702   4                              }
1703   3                              write_dgus_vp(0x9700 + i, (uint8_t *)&swState, 1);
1704   3                      }
1705   2              }
1706   1      }
1707          
1708          void p80Func(void)
1709          {
1710   1              write_dgus_vp(0x9800, (uint8_t *)&synthesisCollection.closeBusVolt, 1);
1711   1      
1712   1              write_dgus_vp(0x9801, (uint8_t *)&synthesisCollection.controlBusVolt, 1);
1713   1      
1714   1              write_dgus_vp(0x9802, (uint8_t *)&synthesisCollection.controlBusCurr, 1);
1715   1      
1716   1              write_dgus_vp(0x9803, (uint8_t *)&synthesisCollection.batteryVolt, 1);
1717   1      
1718   1              write_dgus_vp(0x9804, (uint8_t *)&synthesisCollection.batteryCurr, 1);
1719   1      }
1720          
1721          void p82Func(void)
1722          {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 29  

1723   1              if (UPS_INV_Set.UPS_Num >= 1)
1724   1              {
1725   2                      write_dgus_vp(0x9850, (uint8_t *)&ups[0].remoteMeasurement, 11);
1726   2                      write_dgus_vp(0x985B, (uint8_t *)&ups[0].remoteSignal, 1);
1727   2              }
1728   1              if (UPS_INV_Set.UPS_Num >= 2)
1729   1              {
1730   2                      write_dgus_vp(0x9860, (uint8_t *)&ups[1].remoteMeasurement, 11);
1731   2                      write_dgus_vp(0x986B, (uint8_t *)&ups[1].remoteSignal, 1);
1732   2              }
1733   1              {
1734   2                      uint16_t ups2Hide;
1735   2                      ups2Hide = (UPS_INV_Set.UPS_Num < 2) ? 1 : 0;
1736   2                      write_dgus_vp(0x9880, (uint8_t *)&ups2Hide, 1);
1737   2              }
1738   1      }
1739          
1740          void p85Func(void)
1741          {
1742   1              if (UPS_INV_Set.INV_Num >= 1)
1743   1              {
1744   2                      write_dgus_vp(0x98A0, (uint8_t *)&inv[0], 21);
1745   2              }
1746   1              if (UPS_INV_Set.INV_Num >= 2)
1747   1              {
1748   2                      write_dgus_vp(0x98C0, (uint8_t *)&inv[1], 21);
1749   2              }
1750   1              {
1751   2                      uint16_t inv2Hide;
1752   2                      inv2Hide = (UPS_INV_Set.INV_Num < 2) ? 1 : 0;
1753   2                      write_dgus_vp(0x98E0, (uint8_t *)&inv2Hide, 1);
1754   2              }
1755   1      }
1756          
1757          void p86Func(void)
1758          {
1759   1              uint16_t i;
1760   1              for (i = 0; i < DC_ConverterSet.Num; i++)
1761   1              {
1762   2                      uint16_t faultSta;
1763   2                      uint16_t protectSta;
1764   2                      write_dgus_vp(0x9900 + i, (uint8_t *)&dc_4850_Module[i].outputVolt, 1);
1765   2                      write_dgus_vp(0x9910 + i, (uint8_t *)&dc_4850_Module[i].outputCurr, 1);
1766   2                      faultSta = dc_4850_Module[i].DI.faultState;
1767   2                      write_dgus_vp(0x9920 + i, (uint8_t *)&faultSta, 1);
1768   2                      protectSta = dc_4850_Module[i].DI.protectState;
1769   2                      write_dgus_vp(0x9930 + i, (uint8_t *)&protectSta, 1);
1770   2              }
1771   1              for (i = 0; i < DC4850MODULE_MAX; i++)
1772   1              {
1773   2                      uint16_t DC_hide;
1774   2                      DC_hide = (i >= DC_ConverterSet.Num) ? 1 : 0;
1775   2                      write_dgus_vp(0x9940 + i, (uint8_t *)&DC_hide, 1);
1776   2              }
1777   1      }
1778          
1779          void p87Func(void)
1780          {
1781   1              uint16_t i;
1782   1              for (i = 0; i < 30; i++)
1783   1              {
1784   2                      int16_t insulationRes;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 30  

1785   2                      insulationRes = branchInsulation[0].res[i];
1786   2                      insulationRes += i < insulationSet.DC.closeBus_1_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
1787   2                      write_dgus_vp(0x9950 + i, (uint8_t *)&insulationRes, 1);
1788   2              }
1789   1      
1790   1              if (sysInfoSet.siliconChain == 1)
1791   1              {
1792   2                      int16_t temp;
1793   2                      temp = branchInsulation[0].closeBusToGroundVolt - branchInsulation[0].busToGroundVolt;
1794   2                      write_dgus_vp(0x9970, (uint8_t *)&temp, 1);
1795   2      
1796   2                      temp = branchInsulation[0].controlBusToGroundVolt - branchInsulation[0].busToGroundVolt;
1797   2                      write_dgus_vp(0x9971, (uint8_t *)&temp, 1);
1798   2              }
1799   1              else if (sysInfoSet.siliconChain == 0)
1800   1              {
1801   2                      int32_t batteryVoltSum;   // 电池巡检电压总和
1802   2                      int32_t chargeModuleVolt; // 充电模块电压
1803   2                      int16_t displayVolt;
1804   2                      uint16_t i;
1805   2      
1806   2                      // if (batterySet.batteryType == XJ24)
1807   2                      // {
1808   2                      //      batteryVoltSum = 0;
1809   2                      //      for (i = 0; i < batterySet.xj24.cellNum; i++)
1810   2                      //      {
1811   2                      //              batteryVoltSum += battery_xj24[i / 24].volt[i % 24];
1812   2                      //      }
1813   2                      // }
1814   2                      // else if (batterySet.batteryType == XJ55)
1815   2                      // {
1816   2                      //      batteryVoltSum = 0;
1817   2                      //      for (i = 0; i < batterySet.xj55.cellNum; i++)
1818   2                      //      {
1819   2                      //              batteryVoltSum += battery_xj55[i / 55].volt[i % 55];
1820   2                      //      }
1821   2                      // }
1822   2                      read_dgus_vp(0xb020, (uint8_t *)&batteryVoltSum, 1);
1823   2      
1824   2                      chargeModuleVolt = 0;
1825   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
1826   2                      {
1827   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
1828   3                              {
1829   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
1830   4                              }
1831   3                      }
1832   2      
1833   2                      displayVolt = MAX(batteryVoltSum, chargeModuleVolt) - branchInsulation[0].controlBusToGroundVolt;
1834   2                      write_dgus_vp(0x9970, (uint8_t *)&displayVolt, 1);
1835   2                      write_dgus_vp(0x9971, (uint8_t *)&displayVolt, 1);
1836   2              }
1837   1              write_dgus_vp(0x9972, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
1838   1      }
1839          
1840          void p88Func(void)
1841          {
1842   1              uint16_t i;
1843   1              for (i = 0; i < 30; i++)
1844   1              {
1845   2                      uint16_t insulationRes;
1846   2                      insulationRes = branchInsulation[1].res[i];
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 31  

1847   2                      insulationRes += i < insulationSet.DC.closeBus_2_ChannelNum ? 1000 : 0; // 如果为合母路数，数值加100.0
1848   2                      write_dgus_vp(0x99A0 + i, (uint8_t *)&insulationRes, 1);
1849   2              }
1850   1      
1851   1              if (sysInfoSet.siliconChain == 1)
1852   1              {
1853   2                      int16_t temp;
1854   2                      temp = branchInsulation[0].closeBusToGroundVolt - branchInsulation[0].closeBusToGroundVolt;
1855   2                      write_dgus_vp(0x9970, (uint8_t *)&temp, 1);
1856   2      
1857   2                      temp = branchInsulation[0].controlBusToGroundVolt - branchInsulation[0].controlBusToGroundVolt;
1858   2                      write_dgus_vp(0x9971, (uint8_t *)&temp, 1);
1859   2              }
1860   1              else if (sysInfoSet.siliconChain == 0)
1861   1              {
1862   2                      int16_t batteryVoltSum;   // 电池巡检电压总和
1863   2                      int16_t chargeModuleVolt; // 充电模块电压
1864   2                      int16_t displayVolt;
1865   2                      uint16_t i;
1866   2                      // if (batterySet.batteryType == XJ24)
1867   2                      // {
1868   2                      //      batteryVoltSum = 0;
1869   2                      //      for (i = 0; i < batterySet.xj24.cellNum; i++)
1870   2                      //      {
1871   2                      //              batteryVoltSum += battery_xj24[i / 24].volt[i % 24];
1872   2                      //      }
1873   2                      // }
1874   2                      // else if (batterySet.batteryType == XJ55)
1875   2                      // {
1876   2                      //      batteryVoltSum = 0;
1877   2                      //      for (i = 0; i < batterySet.xj55.cellNum; i++)
1878   2                      //      {
1879   2                      //              batteryVoltSum += battery_xj55[i / 55].volt[i % 55];
1880   2                      //      }
1881   2                      // }
1882   2                      read_dgus_vp(0xb020, (uint8_t *)&batteryVoltSum, 1);
1883   2      
1884   2                      chargeModuleVolt = 0;
1885   2                      for (i = 0; i < chargeModuleSet.moduleNum; i++)
1886   2                      {
1887   3                              if (chargeModuleVolt < chargeModule[i].outputVolt)
1888   3                              {
1889   4                                      chargeModuleVolt = chargeModule[i].outputVolt;
1890   4                              }
1891   3                      }
1892   2      
1893   2                      displayVolt = MAX(batteryVoltSum, chargeModuleVolt) - branchInsulation[0].controlBusToGroundVolt;
1894   2                      write_dgus_vp(0x9970, (uint8_t *)&displayVolt, 1);
1895   2                      write_dgus_vp(0x9971, (uint8_t *)&displayVolt, 1);
1896   2              }
1897   1              write_dgus_vp(0x9972, (uint8_t *)&synthesisCollection.busToGroundVolt, 1);
1898   1      }
1899          
1900          void p94Func(void)
1901          {
1902   1              uint16_t i;
1903   1              if (batterySet.batteryType == XJ24)
1904   1              {
1905   2                      for (i = 0; i < 60; i++)
1906   2                      {
1907   3                              if (i < batterySet.xj24.cellNum)
1908   3                              {
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 32  

1909   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
1910   4                              }
1911   3                              else
1912   3                              {
1913   4                                      uint16_t temp = 0;
1914   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
1915   4                              }
1916   3                      }
1917   2              }
1918   1              else if (batterySet.batteryType == XJ55)
1919   1              {
1920   2                      for (i = 0; i < 60; i++)
1921   2                      {
1922   3                              if (i < batterySet.xj24.cellNum)
1923   3                              {
1924   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
1925   4                              }
1926   3                              else
1927   3                              {
1928   4                                      uint16_t temp = 0;
1929   4                                      write_dgus_vp(0xA000 + i, (uint8_t *)&temp, 1);
1930   4                              }
1931   3                      }
1932   2              }
1933   1      }
1934          
1935          void p113Func(void)
1936          {
1937   1              uint16_t i;
1938   1              if (batterySet.batteryType == XJ24)
1939   1              {
1940   2                      for (i = 60; i < 120; i++)
1941   2                      {
1942   3                              if (i < batterySet.xj24.cellNum)
1943   3                              {
1944   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj24[i / 24].volt[i % 24], 1);
1945   4                              }
1946   3                              else
1947   3                              {
1948   4                                      uint16_t temp = 0;
1949   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
1950   4                              }
1951   3                      }
1952   2              }
1953   1              else if (batterySet.batteryType == XJ55)
1954   1              {
1955   2                      for (i = 60; i < 120; i++)
1956   2                      {
1957   3                              if (i < batterySet.xj24.cellNum)
1958   3                              {
1959   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&battery_xj55[i / 55].volt[i % 55], 1);
1960   4                              }
1961   3                              else
1962   3                              {
1963   4                                      uint16_t temp = 0;
1964   4                                      write_dgus_vp(0xA050 + (i - 60), (uint8_t *)&temp, 1);
1965   4                              }
1966   3                      }
1967   2              }
1968   1      }
1969          
1970          void p114Func()
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 33  

1971          {
1972   1              if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
1973   1              {
1974   2                      uint16_t i;
1975   2                      for (i = 0; i < 16; i++)
1976   2                      {
1977   3                              uint16_t swState;
1978   3                              swState = (remoteControlModule_ARD[1].sw1to16 >> i) & 0x01;
1979   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
1980   3                      }
1981   2              }
1982   1              else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
1983   1              {
1984   2                      uint16_t i;
1985   2                      for (i = 0; i < 16; i++)
1986   2                      {
1987   3                              uint16_t swState;
1988   3                              swState = (remoteControlModule_TH[1].sw1to16 >> i) & 0x01;
1989   3                              write_dgus_vp(0x97A0 + i, (uint8_t *)&swState, 1);
1990   3                      }
1991   2              }
1992   1              {
1993   2                      VariableChangedIndicationTypeDef variableChangedIndication;
1994   2                      read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
1995   2                      if (variableChangedIndication.flag == 0x5A)
1996   2                      {
1997   3                              uint16_t variable[5];
1998   3                              read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
1999   3                              switch (variableChangedIndication.addr)
2000   3                              {
2001   4                              case 0x97B0:
2002   4                              case 0x97B1:
2003   4                              case 0x97B2:
2004   4                              case 0x97B3:
2005   4                              case 0x97B4:
2006   4                              case 0x97B5:
2007   4                              case 0x97B6:
2008   4                              case 0x97B7:
2009   4                              case 0x97B8:
2010   4                              case 0x97B9:
2011   4                              case 0x97BA:
2012   4                              case 0x97BB:
2013   4                              case 0x97BC:
2014   4                              case 0x97BD:
2015   4                              case 0x97BE:
2016   4                              case 0x97BF:
2017   4                              {
2018   5                                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
2019   5                                      {
2020   6                                              // 根据销售描述，开关为0x02寄存器，感觉不大对，可能需要重构
2021   6                                              if (variable[0] == 0)
2022   6                                              {
2023   7                                                      static MMODBUS rtuSwOff[16];
2024   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2025   7                                                      remoteControlModule_ARD[0].sw1to16 &= ~(0x0001 << offset);
2026   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2027   7                                                      rtuSwOff[offset].mode = 0x00;
2028   7                                                      rtuSwOff[offset].flag = 0x00;
2029   7                                                      rtuSwOff[offset].Order = 0x06;
2030   7                                                      rtuSwOff[offset].Length = 0x01;
2031   7                                                      rtuSwOff[offset].reserved = 0x00;
2032   7                                                      rtuSwOff[offset].waitTime = 1000;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 34  

2033   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2034   7                                                      rtuSwOff[offset].ModbusReg = 0x0002;
2035   7                                                      rtuSwOff[offset].databuff = NULL;
2036   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2037   7                                                      pushToEmergency(rtuSwOff + offset);
2038   7                                              }
2039   6                                              else if (variable[0] == 1)
2040   6                                              {
2041   7                                                      static MMODBUS rtuSwOn[16];
2042   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2043   7                                                      remoteControlModule_ARD[0].sw1to16 |= 0x0001 << offset;
2044   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2045   7                                                      rtuSwOn[offset].mode = 0x00;
2046   7                                                      rtuSwOn[offset].flag = 0x00;
2047   7                                                      rtuSwOn[offset].Order = 0x06;
2048   7                                                      rtuSwOn[offset].Length = 0x01;
2049   7                                                      rtuSwOn[offset].reserved = 0x00;
2050   7                                                      rtuSwOn[offset].waitTime = 1000;
2051   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2052   7                                                      rtuSwOn[offset].ModbusReg = 0x0002;
2053   7                                                      rtuSwOn[offset].databuff = NULL;
2054   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&remoteControlModule_ARD[1].sw1to16, 1);
2055   7                                                      pushToEmergency(rtuSwOn + offset);
2056   7                                              }
2057   6                                      }
2058   5                                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
2059   5                                      {
2060   6                                              if (variable[0] == 0)
2061   6                                              {
2062   7                                                      static MMODBUS rtuSwOff[16];
2063   7                                                      uint16_t OffVal = 0x0000;
2064   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2065   7                                                      rtuSwOff[offset].SlaveAddr = 0xD1;
2066   7                                                      rtuSwOff[offset].mode = 0x00;
2067   7                                                      rtuSwOff[offset].flag = 0x00;
2068   7                                                      rtuSwOff[offset].Order = 0x06;
2069   7                                                      rtuSwOff[offset].Length = 0x01;
2070   7                                                      rtuSwOff[offset].reserved = 0x00;
2071   7                                                      rtuSwOff[offset].waitTime = 1000;
2072   7                                                      rtuSwOff[offset].VPaddr = 0x97D0 + offset;
2073   7                                                      rtuSwOff[offset].ModbusReg = 0x0002 + offset;
2074   7                                                      rtuSwOff[offset].databuff = NULL;
2075   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OffVal, 1);
2076   7                                                      pushToEmergency(rtuSwOff + offset);
2077   7                                              }
2078   6                                              else if (variable[0] == 1)
2079   6                                              {
2080   7                                                      static MMODBUS rtuSwOn[16];
2081   7                                                      uint16_t OnVal = 0xFFFF;
2082   7                                                      uint16_t offset = (variableChangedIndication.addr - 0x97B0);
2083   7                                                      rtuSwOn[offset].SlaveAddr = 0xD1;
2084   7                                                      rtuSwOn[offset].mode = 0x00;
2085   7                                                      rtuSwOn[offset].flag = 0x00;
2086   7                                                      rtuSwOn[offset].Order = 0x06;
2087   7                                                      rtuSwOn[offset].Length = 0x01;
2088   7                                                      rtuSwOn[offset].reserved = 0x00;
2089   7                                                      rtuSwOn[offset].waitTime = 1000;
2090   7                                                      rtuSwOn[offset].VPaddr = 0x97D0 + offset;
2091   7                                                      rtuSwOn[offset].ModbusReg = 0x0002 + offset;
2092   7                                                      rtuSwOn[offset].databuff = NULL;
2093   7                                                      write_dgus_vp(0x97D0 + offset, (uint8_t *)&OnVal, 1);
2094   7                                                      pushToEmergency(rtuSwOn + offset);
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 35  

2095   7                                              }
2096   6                                      }
2097   5                              }
2098   4                              break;
2099   4      
2100   4                              default:
2101   4                                      break;
2102   4                              }
2103   3                              memset(variable, 0, 5);
2104   3                              write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.len);
2105   3                              variableChangedIndication.flag = 0;
2106   3                              write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
2107   3                      }
2108   2              }
2109   1      }
2110          
2111          code void (*PagePointer[])(void) = {
2112                  P0Func,
2113                  NULL,
2114                  P2Func,
2115                  NULL,
2116                  NULL,
2117                  NULL,
2118                  NULL,
2119                  NULL,
2120                  NULL,
2121                  NULL,
2122                  NULL,
2123                  P11Func,
2124                  P12Func,
2125                  NULL,                             // 13
2126                  NULL,                             // 14
2127                  NULL,                             // 15
2128                  NULL,                             // 16
2129                  NULL,                             // 17
2130                  P18Func,                          // 18
2131                  NULL,                             // 19
2132                  NULL,                             // 20
2133                  NULL,                             // 21
2134                  P22Func,                          // 22
2135                  NULL,                             // 23
2136                  NULL,                             // 24
2137                  NULL,                             // 25
2138                  P26Func,                          // 26
2139                  NULL,                             // 27
2140                  NULL,                             // 28
2141                  P29Func,                          // 29
2142                  NULL,                             // 30
2143                  NULL,                             // 31
2144                  NULL,                             // 32
2145                  P33Func,                          // 33
2146                  NULL,                             // 34
2147                  P35Func,                          // 35
2148                  NULL,                             // 36
2149                  NULL,                             // 37
2150                  NULL,                             // 38
2151                  P39Func,                          // 39
2152                  NULL,                             // 40
2153                  NULL,                             // 41
2154                  p42Func,                          // 42
2155                  NULL,                             // 43
2156                  p44Func,                          // 44
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 36  

2157                  NULL,                             // 45
2158                  NULL,                             // 46
2159                  NULL,                             // 47
2160                  p48Func,                          // 48
2161                  NULL,                             // 49
2162                  p50Func,                          // 50
2163                  NULL,                             // 51
2164                  p52Func,                          // 52
2165                  NULL,                             // 53
2166                  NULL,                             // 54
2167                  NULL,                             // 55
2168                  NULL,                             // 56
2169                  NULL,                             // 57
2170                  NULL,                             // 58
2171                  realTimeAlarmDisplay, // 59
2172                  NULL,                             // 60
2173                  historyAlarmDisplay,  // 61
2174                  NULL,                             // 62
2175                  NULL,                             // 63
2176                  NULL,                             // 64
2177                  NULL,                             // 65
2178                  NULL,                             // 66
2179                  NULL,                             // 67
2180                  p68Func,                          // 68
2181                  NULL,                             // 69
2182                  p70Func,                          // 70
2183                  NULL,                             // 71
2184                  p72Func,                          // 72
2185                  NULL,                             // 73
2186                  NULL,                             // 74
2187                  p75Func,                          // 75
2188                  p76Func,                          // 76
2189                  p77Func,                          // 77
2190                  p78Func,                          // 78
2191                  p79Func,                          // 79
2192                  p80Func,                          // 80
2193                  NULL,                             // 81
2194                  p82Func,                          // 82
2195                  NULL,                             // 83
2196                  NULL,                             // 84
2197                  p85Func,                          // 85
2198                  p86Func,                          // 86
2199                  p87Func,                          // 87
2200                  p88Func,                          // 88
2201                  NULL,                             // 89
2202                  NULL,                             // 90
2203                  NULL,                             // 91
2204                  NULL,                             // 92
2205                  NULL,                             // 93
2206                  p94Func,                          // 94
2207                  NULL,                             // 95
2208                  NULL,                             // 96
2209                  NULL,                             // 97
2210                  NULL,                             // 98
2211                  NULL,                             // 99
2212                  permissionLogin,          // 100
2213                  NULL,                             // 101
2214                  passwordModify,           // 102
2215                  NULL,                             // 103
2216                  NULL,                             // 104
2217                  NULL,                             // 105
2218                  NULL,                             // 106
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 37  

2219                  NULL,                             // 107
2220                  NULL,                             // 108
2221                  NULL,                             // 109
2222                  NULL,                             // 110
2223                  NULL,                             // 111
2224                  NULL,                             // 112
2225                  p113Func,                         // 113
2226                  p114Func,                         // 114
2227                  NULL,                             // 115s
2228          };
2229          
2230          // code void (*pageOpenTreat[])(void) =
2231          // {
2232          
2233          // }
2234          
2235          /**
2236           * @brief 打开某页时执行的功能，主要为更新一次当前页的数据
2237           *
2238           * @param page
2239           */
2240          void pageOpenTreat(uint16_t page)
2241          {
2242   1              switch (page)
2243   1              {
2244   2              case 11:
2245   2                      write_dgus_vp(SYS_INFO_VP, (uint8_t *)&sysInfoSet, SYS_INFO_SIZE); // 进入页面时刷新数据
2246   2                      break;
2247   2              case 12:
2248   2                      write_dgus_vp(AC_INFO_VP, (uint8_t *)&AC_InfoSet, AC_INFO_SIZE);
2249   2                      break;
2250   2              case 18:
2251   2                      write_dgus_vp(DC_INFO_VP, (uint8_t *)&DC_InfoSet, DC_INFO_SIZE);
2252   2                      break;
2253   2              case 22:
2254   2                      write_dgus_vp(BATTERY_INFO_VP, (uint8_t *)&batteryInfoSet, BATTERY_SET_SIZE);
2255   2                      break;
2256   2              case 29:
2257   2                      write_dgus_vp(SPECIAL_PARA_VP, (uint8_t *)&specialParaSet, BATTERY_SET_SIZE);
2258   2                      break;
2259   2              case 33:
2260   2              {
2261   3                      uint8_t rtc[6];
2262   3                      memcpy(rtc, RTCdata, 3);
2263   3                      memcpy(rtc + 3, RTCdata + 4, 3);
2264   3                      write_dgus_vp(0x9D, (uint8_t *)&rtc, 3);
2265   3                      write_dgus_vp(BACKLIGHT_TIME_SET_VP, (uint8_t *)&backLightTime, 1);
2266   3              }
2267   2              break;
2268   2              case 35:
2269   2                      write_dgus_vp(SWITCH_MODULE_SET_VP, (uint8_t *)&switchModuleSet, SWITCH_MODULE_SIZE);
2270   2                      break;
2271   2              case 39:
2272   2                      write_dgus_vp(BATTERY_SET_VP, (uint8_t *)&batterySet, BATTERY_SET_SIZE);
2273   2                      break;
2274   2              case 42:
2275   2                      write_dgus_vp(INSULATION_SET_VP, (uint8_t *)&insulationSet, INSULATION_SET_SIZE);
2276   2                      break;
2277   2              case 44:
2278   2                      write_dgus_vp(CHARGE_MODULE_SET_VP, (uint8_t *)&chargeModuleSet, CHARGE_MODULE_SET_SIZE);
2279   2                      break;
2280   2              case 48:
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 38  

2281   2                      write_dgus_vp(DC_CONVERTER_SET_VP, (uint8_t *)&DC_ConverterSet, DC_CONVERTER_SET_SIZE);
2282   2                      break;
2283   2      
2284   2              default:
2285   2                      break;
2286   2              }
2287   1      }
2288          void PageFunction(void)
2289          {
2290   1              u16 pageid;
2291   1      
2292   1              static uint16_t oldPageid = 0;
2293   1      
2294   1              // EA = 0;
2295   1              ADR_H = 0x00;
2296   1              ADR_M = 0x00;
2297   1              ADR_L = 0x0a;
2298   1              ADR_INC = 1;
2299   1              RAMMODE = 0xAF;
2300   1              while (!APP_ACK)
2301   1                      ;
2302   1              APP_EN = 1;
2303   1              while (APP_EN)
2304   1                      ;
2305   1              pageid = DATA3;
2306   1              pageid <<= 8;
2307   1              pageid |= DATA2;
2308   1              RAMMODE = 0;
2309   1              EA = 1;
2310   1              if (PagePointer[pageid] != 0)
2311   1              {
2312   2                      PagePointer[pageid]();
2313   2              }
2314   1      
2315   1              if (pageid != oldPageid)
2316   1              {
2317   2                      pageOpenTreat(pageid);
2318   2                      oldPageid = pageid;
2319   2              }
2320   1      }
2321          
2322          /**
2323           * @brief 打开屏保，CFG未设置屏保的情况下，可以通过该代码设置
2324           *
2325           */
2326          void openScreenProtection(void)
2327          {
2328   1              // 打开屏保
2329   1              uint16_t data_0x80[2];
2330   1              data_0x80[0] = 0x5A00;
2331   1              read_dgus_vp(0x81, (uint8_t *)(data_0x80 + 1), 1);
2332   1              data_0x80[1] |= 0x01 << 2;
2333   1              write_dgus_vp(0x80, (uint8_t *)data_0x80, 2);
2334   1      
2335   1              { // 设置屏保亮度
2336   2                      struct
2337   2                      {
2338   2                              uint8_t OpenLuminance;           // 开启亮度
2339   2                              uint8_t protectionLuminance; // 屏保亮度
2340   2                      } screenLuminance;                               // 屏幕亮度
2341   2                      read_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2342   2                      screenLuminance.protectionLuminance = 0;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 39  

2343   2                      write_dgus_vp(0x82, (uint8_t *)&screenLuminance, 1);
2344   2              }
2345   1      }
2346          
2347          void weekDisplay(void)
2348          {
2349   1              uint16_t weekday = RTCdata[3];
2350   1              write_dgus_vp(0xB000, (uint8_t *)&weekday, 1);
2351   1      }
2352          
2353          /**
2354           * @brief 充电模式切换为浮充或均充
2355           *
2356           * @param chargeMode ：FLOAT_CHARGE/EQUALIZE_CHARGE
2357           */
2358          void chargeModeSwitch(uint16_t chargeMode)
2359          {
2360   1              static MMODBUS chargeCmd;
2361   1              if (chargeMode == FLOAT_CHARGE)
2362   1              {
2363   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2364   2                      chargeCmd.mode = 0x00;
2365   2                      chargeCmd.flag = 0x00;
2366   2                      chargeCmd.Order = 0x06;
2367   2                      chargeCmd.Length = 1;
2368   2                      chargeCmd.reserved = 0x00;
2369   2                      chargeCmd.waitTime = 1000;
2370   2                      chargeCmd.VPaddr = 0;
2371   2                      chargeCmd.ModbusReg = 0X0000;
2372   2                      chargeCmd.databuff = &batteryInfoSet.floatChargeVolt;
2373   2                      synthesisCollection.closeBusVolt = batteryInfoSet.floatChargeVolt; // 防止重复发送数据
2374   2              }
2375   1              else if (chargeMode == EQUALIZE_CHARGE)
2376   1              {
2377   2                      chargeCmd.SlaveAddr = 0xFF; // 广播
2378   2                      chargeCmd.mode = 0x00;
2379   2                      chargeCmd.flag = 0x00;
2380   2                      chargeCmd.Order = 0x06;
2381   2                      chargeCmd.Length = 1;
2382   2                      chargeCmd.reserved = 0x00;
2383   2                      chargeCmd.waitTime = 1000;
2384   2                      chargeCmd.VPaddr = 0;
2385   2                      chargeCmd.ModbusReg = 0X0000;
2386   2                      chargeCmd.databuff = &batteryInfoSet.equalizeChargeVolt;
2387   2                      synthesisCollection.closeBusVolt = batteryInfoSet.equalizeChargeVolt;
2388   2              }
2389   1              pushToEmergency(&chargeCmd);
2390   1      }
2391          void batteryManage(void)
2392          {
2393   1              static int32_t totalSecond = 0;
2394   1              static uint16_t chargeState = FLOAT_CHARGE; // 充电状态：均充/浮充
2395   1              int16_t batteryCurr;                                            // 霍尔变比后电池组电流
2396   1      
2397   1              batteryCurr = (int32_t)synthesisCollection.batteryCurr * (int32_t)DC_InfoSet.batteryHallRatio / 100;
2398   1      
2399   1              {
2400   2                      if (batteryCurr < 0)
2401   2                      {
2402   3                              chargeState = DISCHARGE;
2403   3                              KillTimer(CHARGE_TIMER);
2404   3                              totalSecond = 0;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 40  

2405   3                      }
2406   2                      else if (batteryCurr >= 0)
2407   2                      {
2408   3                              if (synthesisCollection.closeBusVolt >= batteryInfoSet.equalizeChargeVolt)
2409   3                              { // 根据电压判断均充浮充
2410   4                                      if (chargeState != EQUALIZE_CHARGE)
2411   4                                      {
2412   5                                              chargeState = EQUALIZE_CHARGE;
2413   5                                              StartTimer(CHARGE_TIMER, 1000);
2414   5                                              totalSecond = (int32_t)batteryInfoSet.equalizeChargeHour * 60 * 60;
2415   5                                      }
2416   4                              }
2417   3                              else if (synthesisCollection.closeBusVolt <= batteryInfoSet.floatChargeVolt)
2418   3                              {
2419   4                                      if (chargeState != FLOAT_CHARGE)
2420   4                                      {
2421   5                                              chargeState = FLOAT_CHARGE;
2422   5                                              StartTimer(CHARGE_TIMER, 1000);
2423   5                                              totalSecond = (int32_t)batteryInfoSet.floatChargeDay * 24 * 60 * 60;
2424   5                                      }
2425   4                              }
2426   3      
2427   3                              {
2428   4                                      int32_t equalizeCurr; // 均充电流
2429   4                                      int32_t floatCurr;        // 浮充电流
2430   4                                      equalizeCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.floatToEqualizeChargeCur / 100
             -0;
2431   4                                      floatCurr = (int32_t)batteryInfoSet.nominalCapacity * batteryInfoSet.equalizeToFloatChargeCur / 1000;
2432   4                                      if (batteryCurr >= equalizeCurr)
2433   4                                      {
2434   5                                              if (chargeState != EQUALIZE_CHARGE)
2435   5                                              {
2436   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2437   6                                              }
2438   5                                      }
2439   4                                      else if (batteryCurr <= floatCurr)
2440   4                                      {
2441   5                                              if (chargeState != FLOAT_CHARGE)
2442   5                                              {
2443   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2444   6                                              }
2445   5                                      }
2446   4                              }
2447   3      
2448   3                              if (GetTimeOutFlag(CHARGE_TIMER))
2449   3                              {
2450   4                                      totalSecond--;
2451   4                                      if (totalSecond <= 0)
2452   4                                      {
2453   5                                              if (chargeState == FLOAT_CHARGE)
2454   5                                              {
2455   6                                                      chargeModeSwitch(EQUALIZE_CHARGE);
2456   6                                              }
2457   5                                              else if (chargeState == EQUALIZE_CHARGE)
2458   5                                              {
2459   6                                                      chargeModeSwitch(FLOAT_CHARGE);
2460   6                                              }
2461   5                                      }
2462   4                                      StartTimer(CHARGE_TIMER, 1000);
2463   4                                      {
2464   5                                              timeTypeDef chargeTime;
2465   5                                              chargeTime.day = totalSecond / 60 / 60 / 24;
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 41  

2466   5                                              chargeTime.hour = totalSecond / 60 / 60 % 24;
2467   5                                              chargeTime.minite = totalSecond / 60 % 60;
2468   5                                              chargeTime.second = totalSecond % 60;
2469   5                                              write_dgus_vp(0xB010, (uint8_t *)&chargeTime, 10);
2470   5                                      }
2471   4                              }
2472   3                      }
2473   2                      write_dgus_vp(0xB002, (uint8_t *)&chargeState, 1);
2474   2              }
2475   1      }
2476          
2477          void batteryVoltDisplay()
2478          {
2479   1              int16_t batteryVoltSum;
2480   1              uint16_t i;
2481   1              if (batterySet.xj24.cellNum > 0)
2482   1              {
2483   2                      if (batterySet.batteryType == XJ24)
2484   2                      {
2485   3                              batteryVoltSum = 0;
2486   3                              for (i = 0; i < batterySet.xj24.cellNum; i++)
2487   3                              {
2488   4                                      batteryVoltSum += battery_xj24[i / 24].volt[i % 24];
2489   4                              }
2490   3                      }
2491   2                      else if (batterySet.batteryType == XJ55)
2492   2                      {
2493   3                              batteryVoltSum = 0;
2494   3                              for (i = 0; i < batterySet.xj55.cellNum; i++)
2495   3                              {
2496   4                                      batteryVoltSum += battery_xj55[i / 55].volt[i % 55];
2497   4                              }
2498   3                      }
2499   2              }
2500   1              else if (batterySet.xj24.cellNum == 0)
2501   1              {
2502   2                      batteryVoltSum = synthesisCollection.batteryVolt;
2503   2              }
2504   1              write_dgus_vp(0xB020, (uint8_t *)&batteryVoltSum, 1);
2505   1      }
2506          
2507          void batteryCurrDisplay(void)
2508          {
2509   1              write_dgus_vp(0xB022, (uint8_t *)&synthesisCollection.batteryCurr, 1);
2510   1      }
2511          
2512          void publicUI(void)
2513          {
2514   1              weekDisplay();
2515   1              batteryVoltDisplay();
2516   1              batteryCurrDisplay();
2517   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  18024    ----
   CONSTANT SIZE    =    353    ----
   XDATA SIZE       =   2081     380
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.60.7.0   UI                                                                04/28/2023 11:33:24 PAGE 42  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
