C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE CONST
OBJECT MODULE PLACED IN .\Objects\const.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\const.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.
                    -\lib) DEBUG OBJECTEXTEND PRINT(.\Listings\const.lst) OBJECT(.\Objects\const.obj)

line level    source

   1          #include "const.h"
   2          #include "norflash.h"
   3          #include "data.h"
   4          #include "ui.h"
   5          #include "debug.h"
   6          #include "modbus.h"
   7          
   8          void modbusCenerate(void)
   9          {
  10   1          uint16_t num = 0;
  11   1          {                                        // 综合采样单元
  12   2              pageModbusReg[num].SlaveAddr = 0x61; // 97
  13   2              pageModbusReg[num].mode = 0x00;
  14   2              pageModbusReg[num].flag = 0x00;
  15   2              pageModbusReg[num].Order = 0x03;
  16   2              pageModbusReg[num].Length = 0x12;
  17   2              pageModbusReg[num].reserved = 0x00;
  18   2              pageModbusReg[num].waitTime = 1000;
  19   2              pageModbusReg[num].VPaddr = 0;
  20   2              pageModbusReg[num].ModbusReg = 0x0000;
  21   2              pageModbusReg[num].databuff = (uint16_t *)&synthesisCollection;
  22   2              num++;
  23   2          }
  24   1          { // 支路绝缘
  25   2              uint16_t i;
  26   2              for (i = 0; i < insulationSet.DC.Num; i++)
  27   2              {
  28   3                  if (num < PAGE_MAX_NUM)
  29   3                  {
  30   4                      if (i == 0)
  31   4                      {
  32   5                          pageModbusReg[num].SlaveAddr = 0x60;
  33   5                      }
  34   4                      else if (i >= 1)
  35   4                      {
  36   5                          pageModbusReg[num].SlaveAddr = 0x60 + i + 1; // 跳过0x61，0x61为综合采集单元
  37   5                      }
  38   4                      pageModbusReg[num].mode = 0x00;
  39   4                      pageModbusReg[num].flag = 0x00;
  40   4                      pageModbusReg[num].Order = 0x03;
  41   4                      pageModbusReg[num].Length = 0x21;
  42   4                      pageModbusReg[num].reserved = 0x00;
  43   4                      pageModbusReg[num].waitTime = 1000;
  44   4                      pageModbusReg[num].VPaddr = 0;
  45   4                      pageModbusReg[num].ModbusReg = 0x0000;
  46   4                      pageModbusReg[num].databuff = (uint16_t *)(DC_Insulation + i);
  47   4                      num++;
  48   4                  }
  49   3              }
  50   2          }
  51   1          { // 开关量
  52   2              uint16_t i;
  53   2              // DEBUGINFO("switchModuleSet.switchModule.switchNum = %d \n", (uint16_t)switchModuleSet.switchMod
             -ule.switchNum);
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 2   

  54   2              for (i = 0; i < switchModuleSet.switchModule.switchNum; i++)
  55   2              {                           // u8 SlaveAddr;u8 mode;u8 flag;u8 Order;u8 Length;u8 reserved;u16 wai
             -tTime;u16 VPaddr;u16 ModbusReg;
  56   3                  if (num < PAGE_MAX_NUM) // 越界保护
  57   3                  {
  58   4                      pageModbusReg[num].SlaveAddr = 0xA0 + i;
  59   4                      pageModbusReg[num].mode = 0x00;
  60   4                      pageModbusReg[num].flag = 0x00;
  61   4                      pageModbusReg[num].Order = 0x03;
  62   4                      pageModbusReg[num].Length = 0x03;
  63   4                      pageModbusReg[num].reserved = 0x00;
  64   4                      pageModbusReg[num].waitTime = 1000;
  65   4                      pageModbusReg[num].VPaddr = 0;
  66   4                      pageModbusReg[num].ModbusReg = 0x0000;
  67   4                      pageModbusReg[num].databuff = (uint16_t *)(switchModule + i);
  68   4                      num++;
  69   4                  }
  70   3              }
  71   2              // DEBUGINFO("switchModuleSet.switchModule.switchNum = %d \n", (uint16_t)switchModuleSet.switchMod
             -ule.switchNum);
  72   2              // DEBUGINFO("%d \n", (uint16_t)num);
  73   2          }
  74   1          if (batterySet.batteryType == XJ24)
  75   1          { // XJ24
  76   2              uint16_t i;
  77   2              for (i = 0; i < batterySet.xj24.batteryModuleNum; i++)
  78   2              {
  79   3                  if (num < PAGE_MAX_NUM)
  80   3                  {
  81   4                      pageModbusReg[num].SlaveAddr = 0x70 + i;
  82   4                      pageModbusReg[num].mode = 0x00;
  83   4                      pageModbusReg[num].flag = 0x00;
  84   4                      pageModbusReg[num].Order = 0x03;
  85   4                      pageModbusReg[num].Length = 0x19;
  86   4                      pageModbusReg[num].reserved = 0x00;
  87   4                      pageModbusReg[num].waitTime = 1000;
  88   4                      pageModbusReg[num].VPaddr = 0;
  89   4                      pageModbusReg[num].ModbusReg = 0x0000;
  90   4                      pageModbusReg[num].databuff = (uint16_t *)(battery_xj24 + i);
  91   4                      num++;
  92   4                  }
  93   3              }
  94   2          }
  95   1          else if (batterySet.batteryType == XJ55)
  96   1          { // XJ55
  97   2              uint16_t i;
  98   2              for (i = 0; i < batterySet.xj55.batteryModuleNum; i++)
  99   2              {
 100   3                  if (num < PAGE_MAX_NUM)
 101   3                  {
 102   4                      pageModbusReg[num].SlaveAddr = 0x70 + i;
 103   4                      pageModbusReg[num].mode = 0x00;
 104   4                      pageModbusReg[num].flag = 0x00;
 105   4                      pageModbusReg[num].Order = 0x03;
 106   4                      pageModbusReg[num].Length = 0x37;
 107   4                      pageModbusReg[num].reserved = 0x00;
 108   4                      pageModbusReg[num].waitTime = 1000;
 109   4                      pageModbusReg[num].VPaddr = 0;
 110   4                      pageModbusReg[num].ModbusReg = 0x0000;
 111   4                      pageModbusReg[num].databuff = (uint16_t *)(battery_xj55 + i);
 112   4                      num++;
 113   4                  }
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 3   

 114   3              }
 115   2          }
 116   1      
 117   1          { // DC4850模块
 118   2              uint16_t i;
 119   2              for (i = 0; i < DC_ConverterSet.Num; i++)
 120   2              {
 121   3                  if (num < PAGE_MAX_NUM)
 122   3                  {
 123   4                      pageModbusReg[num].SlaveAddr = 0x90 + i;
 124   4                      pageModbusReg[num].mode = 0x00;
 125   4                      pageModbusReg[num].flag = 0x00;
 126   4                      pageModbusReg[num].Order = 0x03;
 127   4                      pageModbusReg[num].Length = 0x07;
 128   4                      pageModbusReg[num].reserved = 0x00;
 129   4                      pageModbusReg[num].waitTime = 1000;
 130   4                      pageModbusReg[num].VPaddr = 0;
 131   4                      pageModbusReg[num].ModbusReg = 0x0000;
 132   4                      pageModbusReg[num].databuff = (uint16_t *)(dc_4850_Module + i);
 133   4                      num++;
 134   4                  }
 135   3              }
 136   2          }
 137   1      
 138   1          { // 远控单元
 139   2              uint16_t i;
 140   2              for (i = 0; i < switchModuleSet.synthesisCollection.remoteControlNum; i++)
 141   2              {
 142   3                  if (num < PAGE_MAX_NUM)
 143   3                  {
 144   4                      if (switchModuleSet.synthesisCollection.remoteControlType == ARD)
 145   4                      {
 146   5                          pageModbusReg[num].SlaveAddr = 0xD0 + i;
 147   5                          pageModbusReg[num].mode = 0x00;
 148   5                          pageModbusReg[num].flag = 0x00;
 149   5                          pageModbusReg[num].Order = 0x03;
 150   5                          pageModbusReg[num].Length = 0x01;
 151   5                          pageModbusReg[num].reserved = 0x00;
 152   5                          pageModbusReg[num].waitTime = 1000;
 153   5                          pageModbusReg[num].VPaddr = 0;
 154   5                          pageModbusReg[num].ModbusReg = 0x0002;
 155   5                          pageModbusReg[num].databuff = (uint16_t *)(remoteControlModule_ARD + i);
 156   5                          num++;
 157   5                      }
 158   4                      else if (switchModuleSet.synthesisCollection.remoteControlType == TH)
 159   4                      {
 160   5                          pageModbusReg[num].SlaveAddr = 0xD0 + i;
 161   5                          pageModbusReg[num].mode = 0x00;
 162   5                          pageModbusReg[num].flag = 0x00;
 163   5                          pageModbusReg[num].Order = 0x03;
 164   5                          pageModbusReg[num].Length = 0x02;
 165   5                          pageModbusReg[num].reserved = 0x00;
 166   5                          pageModbusReg[num].waitTime = 1000;
 167   5                          pageModbusReg[num].VPaddr = 0;
 168   5                          pageModbusReg[num].ModbusReg = 0x0000;
 169   5                          pageModbusReg[num].databuff = (uint16_t *)(remoteControlModule_TH + i);
 170   5                          num++;
 171   5                      }
 172   4                  }
 173   3              }
 174   2          }
 175   1      
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 4   

 176   1          { // 充电模块
 177   2              uint16_t i;
 178   2              for (i = 0; i < chargeModuleSet.moduleNum; i++)
 179   2              {
 180   3                  if (num < PAGE_MAX_NUM)
 181   3                  {
 182   4                      pageModbusReg[num].SlaveAddr = 0x01 + i;
 183   4                      pageModbusReg[num].mode = 0x00;
 184   4                      pageModbusReg[num].flag = 0x00;
 185   4                      pageModbusReg[num].Order = 0x03;
 186   4                      pageModbusReg[num].Length = 0x08;
 187   4                      pageModbusReg[num].reserved = 0x00;
 188   4                      pageModbusReg[num].waitTime = 1000;
 189   4                      pageModbusReg[num].VPaddr = 0;
 190   4                      pageModbusReg[num].ModbusReg = 0x0000;
 191   4                      pageModbusReg[num].databuff = (uint16_t *)(chargeModule + i);
 192   4                      num++;
 193   4                  }
 194   3              }
 195   2          }
 196   1      
 197   1          {
 198   2              uint16_t i;
 199   2              for (i = 0; i < UPS_INV_Set.UPS_Num; i++)
 200   2              {
 201   3                  if (num < PAGE_MAX_NUM)
 202   3                  {
 203   4                      pageModbusReg[num].SlaveAddr = 26 + i;
 204   4                      pageModbusReg[num].mode = 0x00;
 205   4                      pageModbusReg[num].flag = 0x00;
 206   4                      pageModbusReg[num].Order = 0x03;
 207   4                      pageModbusReg[num].Length = 0x0B;
 208   4                      pageModbusReg[num].reserved = 0x00;
 209   4                      pageModbusReg[num].waitTime = 1000;
 210   4                      pageModbusReg[num].VPaddr = 0;
 211   4                      pageModbusReg[num].ModbusReg = 0x0000;
 212   4                      pageModbusReg[num].databuff = (uint16_t *)(&ups[i].remoteMeasurement);
 213   4                      num++;
 214   4                  }
 215   3              }
 216   2          }
 217   1          {
 218   2              uint16_t i;
 219   2              for (i = 0; i < UPS_INV_Set.UPS_Num; i++)
 220   2              {
 221   3                  if (num < PAGE_MAX_NUM)
 222   3                  {
 223   4                      pageModbusReg[num].SlaveAddr = 26 + i;
 224   4                      pageModbusReg[num].mode = 0x00;
 225   4                      pageModbusReg[num].flag = 0x00;
 226   4                      pageModbusReg[num].Order = 0x02;
 227   4                      pageModbusReg[num].Length = 0x10;
 228   4                      pageModbusReg[num].reserved = 0x00;
 229   4                      pageModbusReg[num].waitTime = 1000;
 230   4                      pageModbusReg[num].VPaddr = 0;
 231   4                      pageModbusReg[num].ModbusReg = 0x0300;
 232   4                      pageModbusReg[num].databuff = (uint16_t *)(&ups[i].remoteSignal);
 233   4                      num++;
 234   4                  }
 235   3              }
 236   2          }
 237   1          {
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 5   

 238   2              uint16_t i;
 239   2              for (i = 0; i < UPS_INV_Set.INV_Num; i++)
 240   2              {
 241   3                  if (num < PAGE_MAX_NUM)
 242   3                  {
 243   4                      pageModbusReg[num].SlaveAddr = 0x80 + i;
 244   4                      pageModbusReg[num].mode = 0x00;
 245   4                      pageModbusReg[num].flag = 0x00;
 246   4                      pageModbusReg[num].Order = 0x03;
 247   4                      pageModbusReg[num].Length = 21;
 248   4                      pageModbusReg[num].reserved = 0x00;
 249   4                      pageModbusReg[num].waitTime = 1000;
 250   4                      pageModbusReg[num].VPaddr = 0;
 251   4                      pageModbusReg[num].ModbusReg = 0x0001;
 252   4                      pageModbusReg[num].databuff = (uint16_t *)(&inv[i]);
 253   4                      num++;
 254   4                  }
 255   3              }
 256   2          }
 257   1          {
 258   2              if (num < PAGE_MAX_NUM)
 259   2              {
 260   3                  pageModbusReg[num].SlaveAddr = 0x32;
 261   3                  pageModbusReg[num].mode = 0x00;
 262   3                  pageModbusReg[num].flag = 0x00;
 263   3                  pageModbusReg[num].Order = 0x03;
 264   3                  pageModbusReg[num].Length = 4;
 265   3                  pageModbusReg[num].reserved = 0x00;
 266   3                  pageModbusReg[num].waitTime = 1000;
 267   3                  pageModbusReg[num].VPaddr = 0;
 268   3                  pageModbusReg[num].ModbusReg = 0x0000;
 269   3                  pageModbusReg[num].databuff = (uint16_t *)(&AC_Insulation);
 270   3                  num++;
 271   3              }
 272   2          }
 273   1          modbusNum = num;
 274   1      }
 275          
 276          struct
 277          {
 278              uint16_t closeBusVolt;       // 合闸母线电压
 279              uint16_t controlBusVolt;     // 控母电压
 280              uint16_t busToGroundVolt;    // 母线对地电压
 281              uint16_t batteryVolt;        // 电池组电压
 282              uint16_t controlBusCurr;     // 控母电流
 283              int16_t batteryCurr;         // 电池电流
 284              uint16_t AC_channel_1_Uab;   // 交流1路Uab
 285              uint16_t AC_channel_1_Ubc;   // 交流1路Ubc
 286              uint16_t AC_channel_1_Uca;   // 交流1路Uca
 287              uint16_t AC_channel_2_Uab;   // 交流2路Uab
 288              uint16_t AC_channel_2_Ubc;   // 交流2路Ubc
 289              uint16_t AC_channel_2_Uca;   // 交流2路Uca
 290              uint16_t AC_Curr;            // 交流电流
 291              uint16_t reserve1;           // 保留
 292              uint16_t reserve2;           // 保留
 293              uint16_t batteryTemperature; // 电池温度
 294              uint16_t sw_01to16;          // 开关量1到16路
 295              uint16_t sw_17to24;          // 开关量17到24路
 296              // uint16_t sw1 : 1;            // 开关量第1路
 297              // uint16_t sw2 : 1;            // 开关量第2路
 298              // uint16_t sw3 : 1;            // 开关量第3路
 299              // uint16_t sw4 : 1;            // 开关量第4路
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 6   

 300              // uint16_t sw5 : 1;            // 开关量第5路
 301              // uint16_t sw6 : 1;            // 开关量第6路
 302              // uint16_t sw7 : 1;            // 开关量第7路
 303              // uint16_t sw8 : 1;
 304              // uint16_t sw9 : 1;
 305              // uint16_t sw10 : 1;
 306              // uint16_t sw11 : 1;
 307              // uint16_t sw12 : 1;
 308              // uint16_t sw13 : 1;
 309              // uint16_t sw14 : 1;
 310              // uint16_t sw15 : 1;
 311              // uint16_t sw16 : 1;
 312              // uint16_t sw17 : 1;
 313              // uint16_t sw18 : 1;
 314              // uint16_t sw19 : 1;
 315              // uint16_t sw20 : 1;
 316              // uint16_t sw21 : 1;
 317              // uint16_t sw22 : 1;
 318              // uint16_t sw23 : 1;
 319              // uint16_t sw24 : 1;
 320              // uint16_t reserve3 : 8;
 321          } synthesisCollection; // 综合采样
*** WARNING C231 IN LINE 321 OF source\const.c: 'synthesisCollection': redefinition
 322          
 323          struct
 324          {
 325              uint16_t closeBusToGroundVolt;   // 合母对地电压
 326              uint16_t controlBusToGroundVolt; // 控制母对地电压
 327              uint16_t busToGroundVolt;        // 母线对地电压
 328              uint16_t res[30];                // 绝缘电路值30路
 329              // uint16_t channel_1_Res;                // 第1路绝缘漏电阻值
 330              // uint16_t channel_2_Res;                // 第2路绝缘漏电阻值
 331              // uint16_t channel_3_Res;                // 第3路绝缘漏电阻值
 332              // uint16_t channel_4_Res;                // 第4路绝缘漏电阻值
 333              // uint16_t channel_5_Res;                // 第5路绝缘漏电阻值
 334              // uint16_t channel_6_Res;                // 第6路绝缘漏电阻值
 335              // uint16_t channel_7_Res;                // 第7路绝缘漏电阻值
 336              // uint16_t channel_8_Res;                // 第8路绝缘漏电阻值
 337              // uint16_t channel_9_Res;                // 第9路绝缘漏电阻值
 338              // uint16_t channel_10_Res;               // 第10路绝缘漏电阻值
 339              // uint16_t channel_11_Res;               // 第11路绝缘漏电阻值
 340              // uint16_t channel_12_Res;               // 第12路绝缘漏电阻值
 341              // uint16_t channel_13_Res;               // 第13路绝缘漏电阻值
 342              // uint16_t channel_14_Res;               // 第14路绝缘漏电阻值
 343              // uint16_t channel_15_Res;               // 第15路绝缘漏电阻值
 344              // uint16_t channel_16_Res;               // 第16路绝缘漏电阻值
 345              // uint16_t channel_17_Res;               // 第17路绝缘漏电阻值
 346              // uint16_t channel_18_Res;               // 第18路绝缘漏电阻值
 347              // uint16_t channel_19_Res;               // 第19路绝缘漏电阻值
 348              // uint16_t channel_20_Res;               // 第20路绝缘漏电阻值
 349              // uint16_t channel_21_Res;               // 第21路绝缘漏电阻值
 350              // uint16_t channel_22_Res;               // 第22路绝缘漏电阻值
 351              // uint16_t channel_23_Res;               // 第23路绝缘漏电阻值
 352              // uint16_t channel_24_Res;               // 第24路绝缘漏电阻值
 353              // uint16_t channel_25_Res;               // 第25路绝缘漏电阻值
 354              // uint16_t channel_26_Res;               // 第26路绝缘漏电阻值
 355              // uint16_t channel_27_Res;               // 第27路绝缘漏电阻值
 356              // uint16_t channel_28_Res;               // 第28路绝缘漏电阻值
 357              // uint16_t channel_29_Res;               // 第29路绝缘漏电阻值
 358              // uint16_t channel_30_Res;               // 第30路绝缘漏电阻值
 359          } DC_Insulation[DC_INSULATION_MAX]; // DC支路绝缘
 360          
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 7   

 361          struct
 362          {
 363              uint16_t sw_u16[3];
 364          } switchModule[SWITCH_MODULE_MAX]; // 开关量
 365          
 366          struct
 367          {
 368              int16_t volt[24];    // 24节电池电压
 369              int16_t temperature; // 温度
 370              // uint16_t No_1_Volt;  // 第1节电池电压
 371              // uint16_t No_2_Volt;  // 第2节电池电压
 372              // uint16_t No_3_Volt;  // 第3节电池电压
 373              // uint16_t No_4_Volt;  // 第4节电池电压
 374              // uint16_t No_5_Volt;  // 第5节电池电压
 375              // uint16_t No_6_Volt;  // 第6节电池电压
 376              // uint16_t No_7_Volt;  // 第7节电池电压
 377              // uint16_t No_8_Volt;  // 第8节电池电压
 378              // uint16_t No_9_Volt;  // 第9节电池电压
 379              // uint16_t No_10_Volt; // 第10节电池电压
 380              // uint16_t No_11_Volt; // 第11节电池电压
 381              // uint16_t No_12_Volt; // 第12节电池电压
 382              // uint16_t No_13_Volt; // 第13节电池电压
 383              // uint16_t No_14_Volt; // 第14节电池电压
 384              // uint16_t No_15_Volt; // 第15节电池电压
 385              // uint16_t No_16_Volt; // 第16节电池电压
 386              // uint16_t No_17_Volt; // 第17节电池电压
 387              // uint16_t No_18_Volt; // 第18节电池电压
 388              // uint16_t No_19_Volt; // 第19节电池电压
 389              // uint16_t No_20_Volt; // 第20节电池电压
 390              // uint16_t No_21_Volt; // 第21节电池电压
 391              // uint16_t No_22_Volt; // 第22节电池电压
 392              // uint16_t No_23_Volt; // 第23节电池电压
 393              // uint16_t No_24_Volt; // 第24节电池电压
 394          } battery_xj24[BATTERY_XJ24_MAX];
 395          
 396          struct
 397          {
 398              int16_t volt[55]; // 55节电池电压
 399              // uint16_t No_1_Volt;  // 第1节电池电压
 400              // uint16_t No_2_Volt;  // 第2节电池电压
 401              // uint16_t No_3_Volt;  // 第3节电池电压
 402              // uint16_t No_4_Volt;  // 第4节电池电压
 403              // uint16_t No_5_Volt;  // 第5节电池电压
 404              // uint16_t No_6_Volt;  // 第6节电池电压
 405              // uint16_t No_7_Volt;  // 第7节电池电压
 406              // uint16_t No_8_Volt;  // 第8节电池电压
 407              // uint16_t No_9_Volt;  // 第9节电池电压
 408              // uint16_t No_10_Volt; // 第10节电池电压
 409              // uint16_t No_11_Volt; // 第11节电池电压
 410              // uint16_t No_12_Volt; // 第12节电池电压
 411              // uint16_t No_13_Volt; // 第13节电池电压
 412              // uint16_t No_14_Volt; // 第14节电池电压
 413              // uint16_t No_15_Volt; // 第15节电池电压
 414              // uint16_t No_16_Volt; // 第16节电池电压
 415              // uint16_t No_17_Volt; // 第17节电池电压
 416              // uint16_t No_18_Volt; // 第18节电池电压
 417              // uint16_t No_19_Volt; // 第19节电池电压
 418              // uint16_t No_20_Volt; // 第20节电池电压
 419              // uint16_t No_21_Volt; // 第21节电池电压
 420              // uint16_t No_22_Volt; // 第22节电池电压
 421              // uint16_t No_23_Volt; // 第23节电池电压
 422              // uint16_t No_24_Volt; // 第24节电池电压
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 8   

 423              // uint16_t No_25_Volt; // 第25节电池电压
 424              // uint16_t No_26_Volt; // 第26节电池电压
 425              // uint16_t No_27_Volt; // 第27节电池电压
 426              // uint16_t No_28_Volt; // 第28节电池电压
 427              // uint16_t No_29_Volt; // 第29节电池电压
 428              // uint16_t No_30_Volt; // 第30节电池电压
 429              // uint16_t No_31_Volt; // 第31节电池电压
 430              // uint16_t No_32_Volt; // 第32节电池电压
 431              // uint16_t No_33_Volt; // 第33节电池电压
 432              // uint16_t No_34_Volt; // 第34节电池电压
 433              // uint16_t No_35_Volt; // 第35节电池电压
 434              // uint16_t No_36_Volt; // 第36节电池电压
 435              // uint16_t No_37_Volt; // 第37节电池电压
 436              // uint16_t No_38_Volt; // 第38节电池电压
 437              // uint16_t No_39_Volt; // 第39节电池电压
 438              // uint16_t No_40_Volt; // 第40节电池电压
 439              // uint16_t No_41_Volt; // 第41节电池电压
 440              // uint16_t No_42_Volt; // 第42节电池电压
 441              // uint16_t No_43_Volt; // 第43节电池电压
 442              // uint16_t No_44_Volt; // 第44节电池电压
 443              // uint16_t No_45_Volt; // 第45节电池电压
 444              // uint16_t No_46_Volt; // 第46节电池电压
 445              // uint16_t No_47_Volt; // 第47节电池电压
 446              // uint16_t No_48_Volt; // 第48节电池电压
 447              // uint16_t No_49_Volt; // 第49节电池电压
 448              // uint16_t No_50_Volt; // 第50节电池电压
 449              // uint16_t No_51_Volt; // 第51节电池电压
 450              // uint16_t No_52_Volt; // 第52节电池电压
 451              // uint16_t No_53_Volt; // 第53节电池电压
 452              // uint16_t No_54_Volt; // 第54节电池电压
 453              // uint16_t No_55_Volt; // 第55节电池电压
 454          } battery_xj55[BATTERY_XJ55_MAX];
 455          
 456          struct
 457          {
 458              uint16_t outputVolt;          // 模块输出电压
 459              uint16_t outputCurr;          // 模块输出电流
 460              uint16_t currLimitPercentage; // 模块限流点百分数
 461              uint16_t voltMax;             // 模块输出电压上限
 462              uint16_t voltMin;             // 模块输出电压下限
 463              struct
 464              {
 465                  uint16_t onOffState : 1;   // 1：关机状态，0：开机状态
 466                  uint16_t autoOrManual : 1; // 1：手动，0：自动
 467                  uint16_t protectState : 1; // 1：保护，0：正常
 468                  uint16_t faultState : 1;   // 1：故障，0：正常
 469                  uint16_t reserve : 12;
 470              } DI;                        // 模块开关状态量DI
 471              uint16_t floatChargeVolt;    // 模块浮充电压
 472              uint16_t equalizeChargeVolt; // 模块均充电压
 473          } dc_4850_Module[DC4850MODULE_MAX];
 474          
 475          struct
 476          {
 477              uint16_t sw1to16; // 开入状态1-16
 478          } remoteControlModule_ARD[REMOTE_CONTROL_MODULE_MAX];
 479          
 480          struct
 481          {
 482              uint16_t channel1to16State; // 1-16路状态
 483              uint16_t sw1to16;           // 1-16路继电器状态
 484          } remoteControlModule_TH[REMOTE_CONTROL_MODULE_MAX];
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 9   

 485          
 486          struct
 487          {
 488              uint16_t outputVolt;          // 模块输出电压
 489              uint16_t outputCurr;          // 模块输出电流
 490              uint16_t currLimitPercentage; // 模块限流点百分数
 491              uint16_t voltMax;             // 模块输出电压上限
 492              uint16_t voltMin;             // 模块输出电压下限
 493              struct
 494              {
 495                  uint16_t onOffState : 1;   // 1：关机状态，0：开机状态
 496                  uint16_t autoOrManual : 1; // 1：手动，0：自动
 497                  uint16_t protectState : 1; // 1：保护，0：正常
 498                  uint16_t faultState : 1;   // 1：故障，0：正常
 499                  uint16_t reserve : 12;
 500              } DI;                        // 模块开关状态量DI
 501              uint16_t floatChargeVolt;    // 模块浮充电压
 502              uint16_t equalizeChargeVolt; // 模块均充电压
 503          } chargeModule[CHARGER_MODULE_MAX];
 504          
 505          struct
 506          {
 507              struct
 508              {
 509                  uint16_t interval_Uab;      // 主路AB线电压（三相输入）/主路电压（单相输入）
 510                  uint16_t interval_Ubc;      // 主路BC线电压（三相输入）
 511                  uint16_t interval_Uca;      // 主路CA线电压（三相输入）
 512                  uint16_t interval_Freq;     // 主路输入频率
 513                  uint16_t bypassVolt;        // 旁路输入电压
 514                  uint16_t bypassFreq;        // 旁路输入频率
 515                  uint16_t outputVolt;        // 输出电压
 516                  uint16_t outputFreq;        // 输出频率
 517                  uint16_t DC_Volt;           // 直流电压
 518                  uint16_t outputCurr;        // 输出电流
 519                  uint16_t insideTemperature; // 机内温度
 520              } remoteMeasurement;            // 遥测
 521              struct
 522              {
 523                  uint16_t bypassOut : 1;          // 旁路输出
 524                  uint16_t rectifyInverterOut : 1; // 整流逆变输出
 525                  uint16_t DC_InverterOut : 1;     // 直流逆变输出
 526                  uint16_t overTemperature : 1;    // 过温
 527                  uint16_t overload : 1;           // 过载
 528                  uint16_t bypassFault : 1;        // 旁路故障
 529                  uint16_t mainFault : 1;          // 主路故障
 530                  uint16_t batteryHighVolt : 1;    // 电池高压
 531                  uint16_t battertLowVolt : 1;     // 电池低压
 532                  uint16_t reserve : 7;
 533              } remoteSignal; // 遥信
 534          } ups[UPS_MAX];
 535          
 536          struct
 537          {
 538              uint16_t outVolt;           // 逆变模块模块输出电压
 539              uint16_t outCurr;           // 逆变模块模块输出电流
 540              uint16_t outFreq;           // 逆变模块输出频率
 541              uint16_t outPowerFactor;    // 输出功率因数
 542              uint16_t inverterVolt;      // 逆变模块逆变电压
 543              uint16_t bypassInputVolt;   // 旁路输入电压
 544              uint16_t bypassInputFreq;   // 旁路输入频率
 545              uint16_t batteryInputVolt;  // 电池输入电压
 546              uint16_t outActivePower;    // 逆变模块输出有功功率
C51 COMPILER V9.60.7.0   CONST                                                             05/11/2023 11:48:28 PAGE 10  

 547              uint16_t outApparentPowper; // 输出视在功率
 548              uint16_t outLoadRate;       // 逆变模块输出负载率
 549              uint16_t temperature;       // 模块温度
 550              uint16_t capacityPercent;   // 模块容量降额比
 551              uint16_t bypassMaxVolt;     // 旁路电压上限
 552              uint16_t bypassMinVolt;     // 旁路电压下限
 553              struct
 554              {
 555                  uint16_t onOffState : 1;      // 1：关机状态，0：开机状态
 556                  uint16_t workMode : 1;        // 逆变器工作方式
 557                  uint16_t faultState : 1;      // 1：故障，0：正常
 558                  uint16_t overload : 1;        // 过载状态
 559                  uint16_t overTemperature : 1; // 过温
 560                  uint16_t battertLowVolt : 1;  // 电池低压
 561                  uint16_t bypassState : 1;     // 旁路输入状态
 562                  uint16_t outputMode : 1;      // 输出方式
 563                  uint16_t reserve : 8;
 564              } DI;               // 模块开关状态量DI
 565              uint16_t config;    // 配置寄寄存器
 566              uint16_t rectify;   // 校准寄存器
 567              uint16_t mainsVolt; // 市电电压
 568              uint16_t mainsFreq; // 市电频率
 569              uint16_t mainsCurr; // 市电电流
 570          } inv[INV_MAX];
 571          
 572          struct
 573          {
 574              int16_t positiveBusToGroundVolt; // 正母线交流对地电压
 575              int16_t negativeBusToGroundVolt; // 负母线交流对地电压
 576              int16_t positiveBusAlarm : 1;    // 正母线告警
 577              int16_t Reserve : 7;
 578              int16_t negativeBusAlarm : 1; // 负母线告警
 579              int16_t Reserve1 : 7;
 580              int16_t alarmValue; // 母线对地交流电压告警设置值
 581          } AC_Insulation;        // AC绝缘


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4271    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1006       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
