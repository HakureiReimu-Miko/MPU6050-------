C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ALARM
OBJECT MODULE PLACED IN .\Objects\alarm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\alarm.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source;.
                    -\lib) DEBUG OBJECTEXTEND PRINT(.\Listings\alarm.lst) OBJECT(.\Objects\alarm.obj)

line level    source

   1          #include "alarm.h"
   2          #include "const.h"
   3          #include "data.h"
   4          #include <STDLIB.H>
   5          #include <STRING.H>
   6          #include "rtc.h"
   7          #include "norflash.h"
   8          #include "debug.h"
   9          #include "ui.h"
  10          
  11          #define P_HISTORY_ALARM_NORFLASH_ADDR 0x800 // ÀúÊ·±¨¾¯¶ÓÁÐÍ·Î²Ö¸Õë´¢´æÎ»ÖÃ
  12          #define HISTORY_ALARM_NORFLASH_ADDR 0x810   // ÀúÊ·±¨¾¯norflash´¢´æÎ»ÖÃ
  13          #define ALARM_SIZE (sizeof(AlarmTypeDef) / 2 + sizeof(AlarmTypeDef) % 2)
  14          #define HISTORY_ALARM_NUM 1000
  15          
  16          #define HISTORY_ALARM_DATA_VP 0x10000 // flash¶ÁÈ¡»ºÂý£¬Ê¹ÓÃVP×÷ÎªÀúÊ·±¨¾¯Êý¾Ý»º³åÇø½øÐÐÏÔÊ¾
  17          #define REAL_TIME_ALARM_DATA_VP 0x1A000
  18          
  19          struct
  20          {
  21              uint16_t head;
  22              uint16_t tail;
  23          } pHistoryAlarm = {0}; // ÀúÊ·±¨¾¯¶ÓÁÐÍ·Î²Ö¸Õë
  24          
  25          void pHistoryAlarmMove()
  26          {
  27   1          pHistoryAlarm.tail = (pHistoryAlarm.tail + 1) % HISTORY_ALARM_NUM;
  28   1          if (pHistoryAlarm.tail == pHistoryAlarm.head)
  29   1          {
  30   2              pHistoryAlarm.head = (pHistoryAlarm.head + 1) % HISTORY_ALARM_NUM;
  31   2          }
  32   1          Nor_Flash_write(P_HISTORY_ALARM_NORFLASH_ADDR, (uint8_t *)&pHistoryAlarm, 2);
  33   1      }
  34          
  35          AlarmTypeDef realTimeAlarmHeader = {0};
  36          uint16_t listLen = 0; // ¶ÓÁÐ³¤¶È
  37          
  38          /**
  39           * @brief Í·²å·¨
  40           *
  41           * @param list
  42           * @param node
  43           */
  44          void listInsertHead(/* AlarmTypeDef *list */ AlarmTypeDef *node)
  45          {
  46   1          node->nextVP = realTimeAlarmHeader.nextVP;
  47   1          realTimeAlarmHeader.nextVP = node->curVP;
  48   1      
  49   1          write_dgus_vp(node->curVP, (uint8_t *)node, sizeof(AlarmTypeDef) / 2);
  50   1          listLen++;
  51   1      }
  52          
  53          void listDelete(/* AlarmTypeDef *list */ uint32_t VP /* , AlarmTypeDef *node */)
  54          {
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 2   

  55   1          AlarmTypeDef prevNode;
  56   1          AlarmTypeDef curNode;
  57   1          DEBUGINFO("listDelete\n");
  58   1          prevNode = realTimeAlarmHeader;
  59   1          while (prevNode.nextVP != VP && prevNode.nextVP != 0)
  60   1          {
  61   2              read_dgus_vp(prevNode.nextVP, (uint8_t *)&prevNode, sizeof(AlarmTypeDef) / 2);
  62   2          }
  63   1          if (prevNode.nextVP == 0)
  64   1          {
  65   2              return;
  66   2          }
  67   1          read_dgus_vp(VP, (uint8_t *)&curNode, sizeof(AlarmTypeDef) / 2);
  68   1          prevNode.nextVP = curNode.nextVP;
  69   1          write_dgus_vp(prevNode.curVP, (uint8_t *)&prevNode, sizeof(AlarmTypeDef) / 2);
  70   1          curNode.nextVP = 0;
  71   1          write_dgus_vp(curNode.curVP, (uint8_t *)&curNode, sizeof(AlarmTypeDef) / 2);
  72   1          listLen--;
  73   1      }
  74          
  75          // uint16_t getListLenth(/* AlarmTypeDef *list */)
  76          // {
  77          //     AlarmTypeDef temp;
  78          //     uint16_t i = 0;
  79          //     temp = realTimeAlarmHeader;
  80          //     // DEBUGINFO("i = %d\n",i);
  81          //     while (temp.nextVP != 0)
  82          //     {
  83          //         // DEBUGINFO("temp.nextVP = %ld\n",temp.nextVP);
  84          //         read_dgus_vp(temp.nextVP, (uint8_t *)&temp, sizeof(AlarmTypeDef) / 2);
  85          //         // DEBUGINFO("i = %d\n",i);
  86          //         i++;
  87          //     }
  88          //     return i;
  89          // }
  90          
  91          void startTimeRecord(AlarmTypeDef *node)
  92          {
  93   1          memcpy(&node->startTime.year, RTCdata, 3);
  94   1          memcpy(&node->startTime.hour, RTCdata + 4, 3);
  95   1      }
  96          void endTimeRecord(AlarmTypeDef *node)
  97          {
  98   1          memcpy(&node->endTime.year, RTCdata, 3);
  99   1          memcpy(&node->endTime.hour, RTCdata + 4, 3);
 100   1      }
 101          
 102          void saveStartAlarm(AlarmTypeDef alarm)
 103          {
 104   1          memset(&alarm.endTime, 0, 6);
 105   1          Nor_Flash_write(HISTORY_ALARM_NORFLASH_ADDR + alarm.saveSerialNum * ALARM_SIZE, (uint8_t *)&alarm, ALA
             -RM_SIZE);
 106   1          write_dgus_vp(HISTORY_ALARM_DATA_VP + alarm.saveSerialNum * ALARM_SIZE, (uint8_t *)&alarm, ALARM_SIZE)
             -;
 107   1          pHistoryAlarmMove();
 108   1          Nor_Flash_write(P_HISTORY_ALARM_NORFLASH_ADDR, (uint8_t *)&pHistoryAlarm, 2);
 109   1      }
 110          
 111          void saveEndAlarm(AlarmTypeDef alarm)
 112          {
 113   1          Nor_Flash_write(HISTORY_ALARM_NORFLASH_ADDR + alarm.saveSerialNum * ALARM_SIZE, (uint8_t *)&alarm, ALA
             -RM_SIZE);
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 3   

 114   1          write_dgus_vp(HISTORY_ALARM_DATA_VP + alarm.saveSerialNum * ALARM_SIZE, (uint8_t *)&alarm, ALARM_SIZE)
             -;
 115   1      }
 116          
 117          void alarmStart(AlarmTypeDef *alarmData, uint32_t VP, uint8_t *alarmMessage)
 118          {
 119   1          alarmData->flag = ALARM;
 120   1          // DEBUGINFO("alarmData->flag = %d",alarmData->flag);
 121   1          alarmData->curVP = VP;
 122   1          startTimeRecord(alarmData);
 123   1          strncpy(alarmData->message, alarmMessage, 40);
 124   1          listInsertHead(alarmData);
 125   1          alarmData->saveSerialNum = pHistoryAlarm.tail;
 126   1          saveStartAlarm(*alarmData);
 127   1      }
 128          
 129          void alarmEnd(AlarmTypeDef *alarmData)
 130          {
 131   1          alarmData->flag = NO_ALARM;
 132   1          endTimeRecord(alarmData);
 133   1          saveEndAlarm(*alarmData);
 134   1          listDelete(alarmData->curVP);
 135   1      }
 136          /**
 137           * @brief ·â×°±¨¾¯¹¦ÄÜ£¬½ÚÊ¡ÄÚ´æ
 138           *
 139           * @param condition ±¨¾¯´¥·¢Ìõ¼þ
 140           * @param VP ±¨¾¯Êý¾Ý»º³åµØÖ·
 141           * @param alarmMessage ±¨¾¯ÐÅÏ¢
 142           */
 143          void alarm(uint16_t condition, uint32_t VP, uint8_t *alarmMessage)
 144          {
 145   1          AlarmTypeDef alarmData;
 146   1          read_dgus_vp(VP, (uint8_t *)&alarmData, sizeof(AlarmTypeDef) / 2);
 147   1          // DEBUGINFO("alarmData.flag = %d\n",alarmData.flag);
 148   1          // DEBUGINFO("VP = %ld\n",VP);
 149   1          if (condition)
 150   1          {
 151   2              if (alarmData.flag != ALARM)
 152   2              {
 153   3                  alarmStart(&alarmData, VP, alarmMessage);
 154   3              }
 155   2          }
 156   1          else
 157   1          {
 158   2              if (alarmData.flag == ALARM)
 159   2              {
 160   3                  alarmEnd(&alarmData);
 161   3              }
 162   2          }
 163   1      }
 164          
 165          void alarmTreat()
 166          {
 167   1          uint16_t i, j;
 168   1          uint16_t num = 0;
 169   1      
 170   1          { // µ¥Ïàµ¥Ïà½»Á÷µçÑ¹±¨¾¯£¬page12
 171   2              if (AC_InfoSet.AC_InputChannel == SINGLE_PHASE)
 172   2              {
 173   3                  if (AC_InfoSet.AC_InputChannel >= 1) // 1Â·
 174   3                  {
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 4   

 175   4                      {
 176   5                          alarm(synthesisCollection.AC_channel_1_Uab > AC_InfoSet.singlePhaseAC_VolMax,
 177   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 1, "µ¥Ïà1Â·½»Á÷¹ý\xFDÑ¹\xFF\xFF");
 178   5                      }
 179   4                      {
 180   5                          alarm(synthesisCollection.AC_channel_1_Uab < AC_InfoSet.singlePhaseAC_VolMin,
 181   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 2, "µ¥Ïà1Â·½»Á÷Ç·Ñ¹\xFF\xFF");
 182   5                      }
 183   4                  }
 184   3                  if (AC_InfoSet.AC_InputChannel >= 2) // 2Â·
 185   3                  {
 186   4                      {
 187   5                          alarm(synthesisCollection.AC_channel_2_Uab > AC_InfoSet.singlePhaseAC_VolMax,
 188   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 3, "µ¥Ïà2Â·½»Á÷¹ý\xFDÑ¹\xFF\xFF");
 189   5                      }
 190   4                      {
 191   5                          alarm(synthesisCollection.AC_channel_2_Uab < AC_InfoSet.singlePhaseAC_VolMin,
 192   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 4, "µ¥Ïà2Â·½»Á÷Ç·Ñ¹\xFF\xFF");
 193   5                      }
 194   4                  }
 195   3              }
 196   2      
 197   2              else if (AC_InfoSet.AC_InputChannel == THREE_PHASE) // ÈýÏà
 198   2              {
 199   3                  if (AC_InfoSet.AC_InputChannel >= 1) // 1Â·
 200   3                  {
 201   4                      {
 202   5                          alarm(synthesisCollection.AC_channel_1_Uab > AC_InfoSet.threePhaseAC_VolMax,
 203   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 5, "ÈýÏà½»Á÷1Â·AÏà¹ý\xFDÑ¹\xFF\xFF");
 204   5                      }
 205   4                      {
 206   5                          alarm(synthesisCollection.AC_channel_1_Ubc > AC_InfoSet.threePhaseAC_VolMax,
 207   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 6, "ÈýÏà½»Á÷1Â·BÏà¹ý\xFDÑ¹\xFF\xFF");
 208   5                      }
 209   4                      {
 210   5                          alarm(synthesisCollection.AC_channel_1_Uca > AC_InfoSet.threePhaseAC_VolMax,
 211   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 7, "ÈýÏà½»Á÷1Â·CÏà¹ý\xFDÑ¹\xFF\xFF");
 212   5                      }
 213   4                      {
 214   5                          alarm(synthesisCollection.AC_channel_1_Uab < AC_InfoSet.threePhaseAC_VolMin,
 215   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 8, "ÈýÏà½»Á÷1Â·AÏàÇ·Ñ¹\xFF\xFF");
 216   5                      }
 217   4                      {
 218   5                          alarm(synthesisCollection.AC_channel_1_Ubc < AC_InfoSet.threePhaseAC_VolMin,
 219   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 9, "ÈýÏà½»Á÷1Â·BÏàÇ·Ñ¹\xFF\xFF");
 220   5                      }
 221   4                      {
 222   5                          alarm(synthesisCollection.AC_channel_1_Uca < AC_InfoSet.threePhaseAC_VolMin,
 223   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 10, "ÈýÏà½»Á÷1Â·CÏàÇ·Ñ¹\xFF\xFF");
 224   5                      }
 225   4                  }
 226   3                  if (AC_InfoSet.AC_InputChannel >= 2) // 2Â·
 227   3                  {
 228   4                      {
 229   5                          alarm(synthesisCollection.AC_channel_2_Uab > AC_InfoSet.threePhaseAC_VolMax,
 230   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 11, "ÈýÏà½»Á÷2Â·AÏà¹ýÑ¹\xFF\xFF");
 231   5                      }
 232   4                      {
 233   5                          alarm(synthesisCollection.AC_channel_2_Ubc > AC_InfoSet.threePhaseAC_VolMax,
 234   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 12, "ÈýÏà½»Á÷2Â·BÏà¹ý\xFDÑ¹\xFF\xFF");
 235   5                      }
 236   4                      {
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 5   

 237   5                          alarm(synthesisCollection.AC_channel_2_Uca > AC_InfoSet.threePhaseAC_VolMax,
 238   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 13, "ÈýÏà½»Á÷2Â·CÏà¹ý\xFDÑ¹\xFF\xFF");
 239   5                      }
 240   4                      {
 241   5                          alarm(synthesisCollection.AC_channel_2_Uab < AC_InfoSet.threePhaseAC_VolMin,
 242   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 14, "ÈýÏà½»Á÷2Â·AÏàÇ·Ñ¹\xFF\xFF");
 243   5                      }
 244   4                      {
 245   5                          alarm(synthesisCollection.AC_channel_2_Ubc < AC_InfoSet.threePhaseAC_VolMin,
 246   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 15, "ÈýÏà½»Á÷2Â·BÏàÇ·Ñ¹\xFF\xFF");
 247   5                      }
 248   4                      {
 249   5                          alarm(synthesisCollection.AC_channel_2_Uca < AC_InfoSet.threePhaseAC_VolMin,
 250   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 16, "ÈýÏà½»Á÷2Â·CÏàÇ·Ñ¹\xFF\xFF");
 251   5                      }
 252   4                  }
 253   3              }
 254   2          }
 255   1      
 256   1          {
 257   2              if (sysInfoSet.siliconChain == 0) // ÎÞ¹èÁ´
 258   2              {
 259   3                  {
 260   4                      alarm(synthesisCollection.closeBusVolt > DC_InfoSet.closeBusVoltMax,
 261   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 17, "Ä¸Ïß¹ý\xFDÑ¹\xFF\xFF");
 262   4                  }
 263   3                  {
 264   4                      alarm(synthesisCollection.closeBusVolt < DC_InfoSet.closeBusVoltMax,
 265   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 18, "Ä¸ÏßÇ·Ñ¹\xFF\xFF");
 266   4                  }
 267   3                  {
 268   4                      alarm(synthesisCollection.controlBusVolt > DC_InfoSet.controlBusVoltMax,
 269   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 19, "Ä£¿é¹ý\xFDÑ¹\xFF\xFF");
 270   4                  }
 271   3                  {
 272   4                      alarm(synthesisCollection.controlBusVolt > DC_InfoSet.controlBusVoltMin,
 273   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 20, "Ä£¿éÇ·Ñ¹\xFF\xFF");
 274   4                  }
 275   3              }
 276   2              else if (sysInfoSet.siliconChain == 1) // ÓÐ¹èÁ´
 277   2              {
 278   3                  {
 279   4                      alarm(synthesisCollection.closeBusVolt > DC_InfoSet.closeBusVoltMax,
 280   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 21, "ºÏÄ¸¹ý\xFDÑ¹\xFF\xFF");
 281   4                  }
 282   3                  {
 283   4                      alarm(synthesisCollection.closeBusVolt < DC_InfoSet.closeBusVoltMax,
 284   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 22, "ºÏÄ¸Ç·Ñ¹\xFF\xFF");
 285   4                  }
 286   3                  {
 287   4                      alarm(synthesisCollection.controlBusVolt > DC_InfoSet.controlBusVoltMax,
 288   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 23, "¿ØÄ¸¹ý\xFDÑ¹\xFF\xFF");
 289   4                  }
 290   3                  {
 291   4                      alarm(synthesisCollection.controlBusVolt > DC_InfoSet.controlBusVoltMin,
 292   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 24, "¿ØÄ¸Ç·Ñ¹\xFF\xFF");
 293   4                  }
 294   3              }
 295   2          }
 296   1      
 297   1          {
 298   2              extern int16_t batteryVoltSum;
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 6   

 299   2              {
 300   3                  alarm(batteryVoltSum > batteryInfoSet.batteryVoltMax,
 301   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 25, "µç³Ø×é¹ý\xFDÑ¹\xFF\xFF");
 302   3              }
 303   2              {
 304   3                  alarm(batteryVoltSum < batteryInfoSet.batteryVoltMin,
 305   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 26, "µç³Ø×éÇ·Ñ¹\xFF\xFF");
 306   3              }
 307   2          }
 308   1          { // ×ÛºÏ²âÁ¿¼ÌµçÆ÷Êä³ö
 309   2              for (i = 0; i < switchModuleSet.synthesisCollection.alarmChannelNum; i++)
 310   2              {
 311   3                  uint8_t message[30];
 312   3                  sprintf(message, "×ÛºÏ²É¼¯¿ª¹Ø%d¹ÊÕÏ\xFF\xFF", i + 1);
 313   3                  alarm((synthesisCollection.sw_01to16 >> i) & 0x0001 != switchModuleSet.synthesisCollection.swi
             -tchAccessMode,
 314   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (27 + i), message);
 315   3              }
 316   2              {
 317   3                  alarm((synthesisCollection.sw_01to16 >> (13 - 1)) & 0x0001 != switchModuleSet.synthesisCollect
             -ion.switchAccessMode,
 318   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 39, "×ÛºÏ²É¼¯¿ª¹Ø13¹ÊÕÏ\xFF\xFF");
 319   3              }
 320   2          }
 321   1          { // ¿ª¹ØÁ¿
 322   2              for (i = 0; i < switchModuleSet.switchModule.switchNum; i++)
 323   2              {
 324   3                  for (j = 0; j < switchModuleSet.switchModule.alarmChannelNum[i]; i++)
 325   3                  {
 326   4                      uint8_t message[20];
 327   4                      sprintf(message, "%d#¿ª¹ØµÚ%dÂ·¹ÊÕÏ\xFF\xFF", i + 1, j + 1);
 328   4                      alarm(switchModule[i].sw_u16[j / 16] >> j % 16 != switchModuleSet.switchModule.accessMode[
             -i],
 329   4                            REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (40 + i * 30 + j), message);
 330   4                  }
 331   3              }
 332   2          }
 333   1      
 334   1          if (batterySet.batteryType == XJ24)
 335   1          {
 336   2              for (i = 0; i < batterySet.xj24.cellNum - batterySet.xj24.endCellNum; i++)
 337   2              {
 338   3                  uint8_t message[20];
 339   3                  sprintf(message, "µ¥Ìåµç³Ø%d#Ç·Ñ¹\xFF\xFF", i + 1);
 340   3                  alarm(battery_xj24[i / 24].volt[i % 24] < batterySet.xj24.singleCellVoltMin,
 341   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (160 + i * 2), message);
 342   3                  sprintf(message, "µ¥Ìåµç³Ø%d#¹ý\xFDÑ¹\xFF\xFF", i + 1);
 343   3                  alarm(battery_xj24[i / 24].volt[i % 24] > batterySet.xj24.singleCellVoltMax,
 344   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (161 + i * 2), message);
 345   3              }
 346   2              for (; i < batterySet.xj24.cellNum; i++)
 347   2              {
 348   3                  uint8_t message[20];
 349   3                  sprintf(message, "Ä©¶Ëµç³Ø%d#Ç·Ñ¹\xFF\xFF", i + 1);
 350   3                  alarm(battery_xj24[i / 24].volt[i % 24] < batterySet.xj24.endCellVoltMin,
 351   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (160 + i * 2), message);
 352   3                  sprintf(message, "Ä©¶Ëµç³Ø%d#¹ý\xFDÑ¹\xFF\xFF", i + 1);
 353   3                  alarm(battery_xj24[i / 24].volt[i % 24] > batterySet.xj24.endCellVoltMax,
 354   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (161 + i * 2), message);
 355   3              }
 356   2          }
 357   1          else if (batterySet.batteryType == XJ55)
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 7   

 358   1          {
 359   2              for (i = 0; i < batterySet.xj55.cellNum - batterySet.xj55.endCellNum; i++)
 360   2              {
 361   3                  uint8_t message[20];
 362   3                  sprintf(message, "µ¥Ìåµç³Ø%d#Ç·Ñ¹\xFF\xFF", i + 1);
 363   3                  alarm(battery_xj55[i / 55].volt[i % 55] < batterySet.xj55.singleCellVoltMin,
 364   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (300 + i * 2), message);
 365   3                  sprintf(message, "µ¥Ìåµç³Ø%d#¹ý\xFDÑ¹\xFF\xFF", i + 1);
 366   3                  alarm(battery_xj55[i / 55].volt[i % 55] > batterySet.xj55.singleCellVoltMax,
 367   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (301 + i * 2), message);
 368   3              }
 369   2              for (; i < batterySet.xj55.cellNum; i++)
 370   2              {
 371   3                  uint8_t message[20];
 372   3                  sprintf(message, "Ä©¶Ëµç³Ø%d#Ç·Ñ¹\xFF\xFF", i + 1);
 373   3                  alarm(battery_xj55[i / 55].volt[i % 55] < batterySet.xj55.endCellVoltMin,
 374   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (300 + i * 2), message);
 375   3                  sprintf(message, "Ä©¶Ëµç³Ø%d#¹ý\xFDÑ¹\xFF\xFF", i + 1);
 376   3                  alarm(battery_xj55[i / 55].volt[i % 55] > batterySet.xj55.endCellVoltMax,
 377   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (301 + i * 2), message);
 378   3              }
 379   2          }
 380   1      
 381   1          {
 382   2              if (AC_Insulation.negativeBusAlarm || AC_Insulation.positiveBusAlarm)
 383   2              {
 384   3                  for (i = 0; i < insulationSet.DC.Num; i++)
 385   3                  {
 386   4                      for (j = 0; j < 30; i++)
 387   4                      {
 388   5                          int16_t insulationRes;
 389   5                          uint8_t message[20];
 390   5                          sprintf(message, "Ä¸Ïß¾øÔµ%d#%dÂ·\xFF\xFF", i + 1, j + 1);
 391   5                          insulationRes = DC_Insulation[i].res[j];
 392   5                          insulationRes += i < insulationSet.DC.closeBus_1_ChannelNum ? 1000 : 0; // Èç¹ûÎªºÏÄ¸Â
             -·Êý£¬ÊýÖµ¼Ó100.0
 393   5                          alarm(insulationRes <= insulationSet.DC.resAlarm,
 394   5                                REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (540 + i * 30 + j), message);
 395   5                      }
 396   4                  }
 397   3              }
 398   2          }
 399   1      
 400   1          {
 401   2              alarm(AC_Insulation.positiveBusAlarm,
 402   2                    REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 600, "Ä¸Ïß¾øÔµ-Õý¶ÔµØ\xFF\xFF");
 403   2              alarm(AC_Insulation.negativeBusAlarm,
 404   2                    REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * 601, "Ä¸Ïß¾øÔµ-¸º¶ÔµØ\xFF\xFF");
 405   2          }
 406   1      
 407   1          {
 408   2              uint8_t message[20];
 409   2              for (i = 0; i < 8; i++)
 410   2              {
 411   3                  sprintf(message, "%d#Ä£¿é¹ÊÕÏ", i + 1);
 412   3                  alarm(chargeModule[i].DI.faultState == 1,
 413   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (602 + i), message);
 414   3              }
 415   2              for (i = 0; i < 8; i++)
 416   2              {
 417   3                  sprintf(message, "%d#Ä£¿é±£»¤", i + 1);
 418   3                  alarm(chargeModule[i].DI.protectState == 1,
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 8   

 419   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (610 + i), message);
 420   3              }
 421   2              // for (i = 0; i < 8; i++)
 422   2              // {
 423   2              //     sprintf(message, "%d#Êä³ö¹ý\xFDÑ¹", i + 1);
 424   2              //     alarm(chargeModule[i].outputVolt >= chargeModuleSet.,
 425   2              //           REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (618 + i), message);
 426   2              // }
 427   2              // for (i = 0; i < 8; i++)
 428   2              // {
 429   2              //     sprintf(message, "%d#Êä³öÇ·Ñ¹", i + 1);
 430   2              //     alarm(chargeModule[i].outputVolt >= chargeModuleSet.,
 431   2              //           REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (626 + i), message);
 432   2              // }
 433   2              // for (i = 0; i < 8; i++)
 434   2              // {
 435   2              //     sprintf(message, "%d#½»Á÷¹ý\xFDÑ¹", i + 1);
 436   2              //     alarm(,
 437   2              //           REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (634 + i), message);
 438   2              // }
 439   2              // for (i = 0; i < 8; i++)
 440   2              // {
 441   2              //     sprintf(message, "%d#½»Á÷Ç·Ñ¹", i + 1);
 442   2              //     alarm(,
 443   2              //           REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (642 + i), message);
 444   2              // }
 445   2              // for (i = 0; i < 8; i++)
 446   2              // {
 447   2              //     sprintf(message, "%d#½»Á÷È±Ïà", i + 1);
 448   2              //     alarm(,
 449   2              //           REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (650 + i), message);
 450   2              // }
 451   2          }
 452   1          {
 453   2              uint8_t message[20];
 454   2              for (i = 0; i < UPS_INV_Set.UPS_Num; i++)
 455   2              {
 456   3                  sprintf(message, "%d#Ò£ÐÅµãÅÔÂ·Êä³ö\xFF\xFF", i + 1);
 457   3                  alarm(ups[i].remoteSignal.bypassOut,
 458   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (658 + 9 * i), message);
 459   3      
 460   3                  sprintf(message, "%d#Ò£ÐÅµãÕûÁ÷Äæ±äÊä³ö\xFF\xFF", i + 1);
 461   3                  alarm(ups[i].remoteSignal.rectifyInverterOut,
 462   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (659 + 9 * i), message);
 463   3      
 464   3                  sprintf(message, "%d#Ò£ÐÅµãÖ±Á÷Äæ±äÊä³ö\xFF\xFF", i + 1);
 465   3                  alarm(ups[i].remoteSignal.DC_InverterOut,
 466   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (660 + 9 * i), message);
 467   3      
 468   3                  sprintf(message, "%d#Ò£ÐÅµã¹ýÎÂ\xFF\xFF", i + 1);
 469   3                  alarm(ups[i].remoteSignal.overTemperature,
 470   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (661 + 9 * i), message);
 471   3      
 472   3                  sprintf(message, "%d#Ò£ÐÅµã¹ýÔØ\xFF\xFF", i + 1);
 473   3                  alarm(ups[i].remoteSignal.overload,
 474   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (662 + 9 * i), message);
 475   3      
 476   3                  sprintf(message, "%d#Ò£ÐÅµãÅÔÂ·¹ÊÕÏ\xFF\xFF", i + 1);
 477   3                  alarm(ups[i].remoteSignal.bypassFault,
 478   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (663 + 9 * i), message);
 479   3      
 480   3                  sprintf(message, "%d#Ò£ÐÅµãÖ÷Â·¹ÊÕÏ\xFF\xFF", i + 1);
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 9   

 481   3                  alarm(ups[i].remoteSignal.mainFault,
 482   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (664 + 9 * i), message);
 483   3      
 484   3                  sprintf(message, "%d#Ò£ÐÅµãµç³Ø¸ßÑ¹\xFF\xFF", i + 1);
 485   3                  alarm(ups[i].remoteSignal.batteryHighVolt,
 486   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (665 + 9 * i), message);
 487   3      
 488   3                  sprintf(message, "%d#Ò£ÐÅµãµç³ØµÍÑ¹\xFF\xFF", i + 1);
 489   3                  alarm(ups[i].remoteSignal.battertLowVolt,
 490   3                        REAL_TIME_ALARM_DATA_VP + ALARM_SIZE * (666 + 9 * i), message);
 491   3              }
 492   2          }
 493   1      }
 494          
 495          #define ROW_NUM 14 // ±í¸ñÐÐÊý
 496          void realTimeAlarmDisplay()
 497          {
 498   1          uint16_t curPage = 0; // ±í¸ñµ±Ç°Ò³Âë
 499   1          uint16_t curPageDisplay;
 500   1          uint16_t alarmNum;
 501   1          uint16_t maxPage;
 502   1          // DEBUGINFO("realTimeAlarmDisplay");
 503   1          alarmNum = listLen;
 504   1          // DEBUGINFO("getListLenth");
 505   1          DEBUGINFO("alarmNum = %d\n", alarmNum);
 506   1          maxPage = alarmNum ? (alarmNum - 1) / ROW_NUM : 0;
 507   1          // DEBUGINFO("%d\n", maxPage);
 508   1          read_dgus_vp(0xA600, (uint8_t *)&curPage, 1);
 509   1          if (curPage > maxPage)
 510   1          {
 511   2              curPage = maxPage;
 512   2              write_dgus_vp(0xA600, (uint8_t *)&curPage, 1);
 513   2          }
 514   1          curPageDisplay = curPage + 1;
 515   1          write_dgus_vp(0xA601, (uint8_t *)&curPageDisplay, 1);
 516   1          {
 517   2              uint16_t i = 0;
 518   2              AlarmTypeDef tempNode;
 519   2              tempNode.curVP = realTimeAlarmHeader.nextVP;
 520   2              read_dgus_vp(tempNode.curVP, (uint8_t *)&tempNode, sizeof(AlarmTypeDef) / 2);
 521   2              while (i < curPage * 14)
 522   2              {
 523   3                  read_dgus_vp(tempNode.nextVP, (uint8_t *)&tempNode, sizeof(AlarmTypeDef) / 2);
 524   3                  i++;
 525   3              }
 526   2      
 527   2              for (i = 0; i < 14; i++)
 528   2              {
 529   3                  struct
 530   3                  {
 531   3                      uint8_t date[0x20];
 532   3                      uint8_t time[0x20];
 533   3                      uint8_t message[50];
 534   3                  } alarmBuff = {0};
 535   3                  if (tempNode.curVP != 0)
 536   3                  {
 537   4                      sprintf(alarmBuff.date, "20%02bd-%02bd-%02bd\xFF\xFF", tempNode.startTime.year, tempNode.s
             -tartTime.month, tempNode.startTime.day);
 538   4                      sprintf(alarmBuff.time, "%02bd:%02bd:%02bd\xFF\xFF", tempNode.startTime.hour, tempNode.sta
             -rtTime.minute, tempNode.startTime.second);
 539   4                      strncpy(alarmBuff.message, tempNode.message, 50);
 540   4                      read_dgus_vp(tempNode.nextVP, (uint8_t *)&tempNode, sizeof(AlarmTypeDef) / 2);
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 10  

 541   4                  }
 542   3                  write_dgus_vp(0xA100 + 0x50 * i, (uint8_t *)&alarmBuff, 45);
 543   3              }
 544   2          }
 545   1      }
 546          
 547          void historyAlarmDisplay()
 548          {
 549   1          uint16_t curPage = 0;    // ±í¸ñµ±Ç°Ò³Âë
 550   1          uint16_t curPageDisplay; // µ±Ç°Ò³ÏÔÊ¾ÓÃ
 551   1          uint16_t alarmNum;
 552   1          uint16_t maxPage;
 553   1          uint16_t i;
 554   1          alarmNum = pHistoryAlarm.head < pHistoryAlarm.tail ? pHistoryAlarm.tail - pHistoryAlarm.head : pHistor
             -yAlarm.tail + HISTORY_ALARM_NUM - pHistoryAlarm.head;
 555   1          maxPage = alarmNum ? (alarmNum - 1) / ROW_NUM : 0;
 556   1          // DEBUGINFO("maxPage = %d\n", maxPage);
 557   1          read_dgus_vp(0xAC00, (uint8_t *)&curPage, 1);
 558   1          if (curPage > maxPage)
 559   1          {
 560   2              curPage = maxPage;
 561   2              write_dgus_vp(0xAC00, (uint8_t *)&curPage, 1);
 562   2          }
 563   1          curPageDisplay = curPage + 1;
 564   1          // DEBUGINFO("%d\n", curPageDisplay);
 565   1          write_dgus_vp(0xAC01, (uint8_t *)&curPageDisplay, 1);
 566   1          {
 567   2              AlarmTypeDef alarmData = {0};
 568   2              int16_t dispalyNum;
 569   2      
 570   2              if (pHistoryAlarm.head <= pHistoryAlarm.tail)
 571   2              {
 572   3                  for (i = 0; i < 14; i++)
 573   3                  {
 574   4                      struct
 575   4                      {
 576   4                          uint8_t date[0x20];
 577   4                          uint8_t time[0x20];
 578   4                          uint8_t message[0x40];
 579   4                          uint8_t endTime[0x20];
 580   4                      } alarmTxt = {0};
 581   4                      dispalyNum = pHistoryAlarm.tail - 1 - i - curPage * 14;
 582   4                      if (((int16_t)pHistoryAlarm.head <= (int16_t)dispalyNum))
 583   4                      {
 584   5                          read_dgus_vp(HISTORY_ALARM_DATA_VP + dispalyNum * ALARM_SIZE, (uint8_t *)&alarmData, A
             -LARM_SIZE);
 585   5                          sprintf(alarmTxt.date, "20%02bd-%02bd-%02bd\xFF\xFF", alarmData.startTime.year, alarmD
             -ata.startTime.month, alarmData.startTime.day);
 586   5                          sprintf(alarmTxt.time, "%02bd:%02bd:%02bd\xFF\xFF", alarmData.startTime.hour, alarmDat
             -a.startTime.minute, alarmData.startTime.second);
 587   5                          strncpy(alarmTxt.message, alarmData.message, 40);
 588   5                          if (memcmp(&alarmData.endTime, "\x00\x00\x00\x00\x00\x00", 6) != 0) // ÓÐ½áÊøÊ±¼äÏÔÊ¾½
             -áÊøÊ±¼ä
 589   5                          {
 590   6                              sprintf(alarmTxt.endTime, "20%02bd-%02bd-%02bd %02bd:%02bd:%02bd\xFF\xFF", alarmDa
             -ta.endTime.year, alarmData.endTime.month,
 591   6                                      alarmData.endTime.day, alarmData.endTime.hour, alarmData.endTime.minute, a
             -larmData.endTime.second);
 592   6                          }
 593   5                      }
 594   4                      write_dgus_vp(0xA700 + 0x50 * i, (uint8_t *)&alarmTxt, 0x50);
 595   4                  }
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 11  

 596   3              }
 597   2              else if (pHistoryAlarm.head > pHistoryAlarm.tail)
 598   2              {
 599   3                  for (i = 0; i < 14; i++)
 600   3                  {
 601   4                      struct
 602   4                      {
 603   4                          uint8_t date[0x20];
 604   4                          uint8_t time[0x20];
 605   4                          uint8_t message[0x40];
 606   4                          uint8_t endTime[0x20];
 607   4                      } alarmTxt = {0};
 608   4                      dispalyNum = (pHistoryAlarm.tail - 1 - i - curPage * 14 + HISTORY_ALARM_NUM) % HISTORY_ALA
             -RM_NUM;
 609   4                      if ((0 <= (int16_t)dispalyNum && (int16_t)dispalyNum <= pHistoryAlarm.tail) ||
 610   4                          (pHistoryAlarm.head <= dispalyNum && dispalyNum <= HISTORY_ALARM_NUM - 1))
 611   4                      {
 612   5                          read_dgus_vp(HISTORY_ALARM_DATA_VP + dispalyNum * ALARM_SIZE, (uint8_t *)&alarmData, A
             -LARM_SIZE);
 613   5                          sprintf(alarmTxt.date, "20%02bd-%02bd-%02bd\xFF\xFF", alarmData.startTime.year, alarmD
             -ata.startTime.month, alarmData.startTime.day);
 614   5                          sprintf(alarmTxt.time, "%02bd:%02bd:%02bd\xFF\xFF", alarmData.startTime.hour, alarmDat
             -a.startTime.minute, alarmData.startTime.second);
 615   5                          strncpy(alarmTxt.message, alarmData.message, 40);
 616   5                          if (memcmp(&alarmData.endTime, "\x00\x00\x00\x00\x00\x00", 6) != 0) // ÓÐ½áÊøÊ±¼äÏÔÊ¾½
             -áÊøÊ±¼ä
 617   5                          {
 618   6                              sprintf(alarmTxt.endTime, "20%02bd-%02bd-%02bd %02bd:%02bd:%02bd\xFF\xFF", alarmDa
             -ta.endTime.year, alarmData.endTime.month,
 619   6                                      alarmData.endTime.day, alarmData.endTime.hour, alarmData.endTime.minute, a
             -larmData.endTime.second);
 620   6                          }
 621   5                      }
 622   4                      write_dgus_vp(0xA700 + 0x50 * i, (uint8_t *)&alarmTxt, 0x50);
 623   4                  }
 624   3              }
 625   2          }
 626   1      
 627   1          {
 628   2              VariableChangedIndicationTypeDef variableChangedIndication;
 629   2              read_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 2);
 630   2              if (variableChangedIndication.flag == 0x5A)
 631   2              {
 632   3                  uint16_t variable[5];
 633   3                  read_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.l
             -en);
 634   3                  switch (variableChangedIndication.addr)
 635   3                  {
 636   4                  case 0xAC02:
 637   4                  {
 638   5                      variable[0] -= 1;
 639   5                      write_dgus_vp(0xAC00, (uint8_t *)&variable[0], 1);
 640   5                  }
 641   4                  break;
 642   4      
 643   4                  case 0xAC05: // Çå³þÀúÊ·±¨¾¯
 644   4                      pHistoryAlarm.head = pHistoryAlarm.tail = 0;
 645   4                      Nor_Flash_write(P_HISTORY_ALARM_NORFLASH_ADDR, (uint8_t *)&pHistoryAlarm, 2);
 646   4                      break;
 647   4                  default:
 648   4                      break;
 649   4                  }
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 12  

 650   3                  memset(variable, 0, 5);
 651   3                  write_dgus_vp(variableChangedIndication.addr, (uint8_t *)&variable, variableChangedIndication.
             -len);
 652   3      
 653   3                  variableChangedIndication.flag = 0;
 654   3                  write_dgus_vp(0x0F00, (uint8_t *)&variableChangedIndication, 1);
 655   3              }
 656   2          }
 657   1      }
 658          
 659          void historyAlarmRead()
 660          {
 661   1          Nor_Flash_read(P_HISTORY_ALARM_NORFLASH_ADDR, (uint8_t *)&pHistoryAlarm, 2);
 662   1          // DEBUGINFO("%d %d\n", pHistoryAlarm.head, pHistoryAlarm.tail);
 663   1          if (pHistoryAlarm.head <= HISTORY_ALARM_NUM && pHistoryAlarm.tail <= HISTORY_ALARM_NUM)
 664   1          {
 665   2              uint16_t i;
 666   2              AlarmTypeDef buff;
 667   2              if (pHistoryAlarm.head <= pHistoryAlarm.tail)
 668   2              {
 669   3                  for (i = pHistoryAlarm.head; i < pHistoryAlarm.tail; i++)
 670   3                  {
 671   4                      Nor_Flash_read(HISTORY_ALARM_NORFLASH_ADDR + i * ALARM_SIZE,
 672   4                                     (uint8_t *)&buff, ALARM_SIZE);
 673   4                      write_dgus_vp(HISTORY_ALARM_DATA_VP + i * ALARM_SIZE,
 674   4                                    (uint8_t *)&buff, ALARM_SIZE);
 675   4                  }
 676   3              }
 677   2              else if (pHistoryAlarm.head > pHistoryAlarm.tail)
 678   2              {
 679   3                  // norFlashToDgus(HISTORY_ALARM_NORFLASH_ADDR + pHistoryAlarm.head * ALARM_SIZE,
 680   3                  //                HISTORY_ALARM_DATA_VP + pHistoryAlarm.head * ALARM_SIZE,
 681   3                  //                (HISTORY_ALARM_NUM - pHistoryAlarm.head) * ALARM_SIZE);
 682   3                  // norFlashToDgus(HISTORY_ALARM_NORFLASH_ADDR,
 683   3                  //                HISTORY_ALARM_DATA_VP,
 684   3                  //                pHistoryAlarm.tail * ALARM_SIZE);
 685   3      
 686   3                  for (i = pHistoryAlarm.head; i < HISTORY_ALARM_NUM; i++)
 687   3                  {
 688   4                      Nor_Flash_read(HISTORY_ALARM_NORFLASH_ADDR + i * ALARM_SIZE,
 689   4                                     (uint8_t *)&buff, ALARM_SIZE);
 690   4                      write_dgus_vp(HISTORY_ALARM_DATA_VP + i * ALARM_SIZE,
 691   4                                    (uint8_t *)&buff, ALARM_SIZE);
 692   4                  }
 693   3                  for (i = 0; i < pHistoryAlarm.tail; i++)
 694   3                  {
 695   4                      Nor_Flash_read(HISTORY_ALARM_NORFLASH_ADDR + i * ALARM_SIZE,
 696   4                                     (uint8_t *)&buff, ALARM_SIZE);
 697   4                      write_dgus_vp(HISTORY_ALARM_DATA_VP + i * ALARM_SIZE,
 698   4                                    (uint8_t *)&buff, ALARM_SIZE);
 699   4                  }
 700   3              }
 701   2          }
 702   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10403    ----
   CONSTANT SIZE    =   1428    ----
   XDATA SIZE       =     70     876
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.60.7.0   ALARM                                                             05/06/2023 14:45:51 PAGE 13  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
