C51 COMPILER V9.57.0.0   R11                                                               07/09/2021 11:30:36 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE R11
OBJECT MODULE PLACED IN .\Objects\R11.obj
COMPILER INVOKED BY: D:\Program Files\keil\C51\BIN\C51.EXE source\R11.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.
                    -\source;.\lib) DEBUG OBJECTEXTEND PRINT(.\Listings\R11.lst) TABS(2) OBJECT(.\Objects\R11.obj)

line level    source

   1          #include "R11.h"
   2          #include "timer.h"
   3          #include "umath.h"
   4          #include "uart_r11.h"
   5          
   6          u8 framenum;//帧编号
   7          u8 HandShakeFlagFlash;//握手R11成功标志   0未成功  1成功
   8          u8 HandShakeFlagTF;//握手R11成功标志   0未成功  1成功
   9          u8 HandShakeFlagUSB;//握手R11成功标志   0未成功  1成功
  10          
  11          /*
  12          保存数据到R11，写入数据长度固定68字节 1cmd+1type+4addr+62data
  13          */
  14          u8 SaveDataToR11(u32 Address, u8 *buf)
  15          {
  16   1          u8 tmp[104];
  17   1          u8 r11ack[12];
  18   1          u8 i,ackvalue;
  19   1      
  20   1          tmp[0] = 0x10;//帧头
  21   1          tmp[1]=framenum++;//帧编号
  22   1          tmp[2] = 1+1+4+64;//长度固定
  23   1          tmp[3] = 0x01;//cmd写入数据到指定的设备及地址
  24   1          tmp[4] = DeviceType;//设备类型//保存到内部flash
  25   1          *(u32*)&tmp[5] = Address;//地址
  26   1          StrCopy(&tmp[9],buf,62);
  27   1          *(u16*)&tmp[71] = 0X0D0A;//需要保存的数据
  28   1          
  29   1          Calculate_CRC16R11(&tmp[1],tmp[2]+2,1); 
  30   1          for(i=0;i<3;i++)
  31   1          {
  32   2              SendToR11(tmp);
  33   2              StartTimer(1,500);
  34   2              while(1)
  35   2              {
  36   3                  ackvalue = GetR11Ack(r11ack,12);
  37   3                  if(ackvalue)
  38   3                  {
  39   4                      if(0x81==r11ack[3])
  40   4                      {
  41   5                          if(0xAA==r11ack[9])
  42   5                              return SUCCESS_ACTION;
  43   5                          else
  44   5                              break;
  45   5                      }
  46   4                  }
  47   3                  if(GetTimeOutFlag(1))//超时后结束接收
  48   3                      break;
  49   3                  delay_ms(10);
  50   3              }
  51   2          }
  52   1          return FAIL_ACTION;
  53   1      }
  54          
C51 COMPILER V9.57.0.0   R11                                                               07/09/2021 11:30:36 PAGE 2   

  55          
  56          
  57          /*
  58          读取R11flash数据,每次固定读取64字节
  59          */
  60          u8 ReadDatafromR11(u32 Address, u8 *buf)
  61          {
  62   1          u8 tmp[12];
  63   1          u8 i,ackvalue;
  64   1      
  65   1          tmp[0] = 0x10;//帧头
  66   1          tmp[1]=framenum++;//帧编号
  67   1          tmp[2] = 1+1+4+1;//长度固定
  68   1          tmp[3] = 0x03;//cmd写入数据到指定的设备及地址
  69   1          tmp[4] = DeviceType;//设备类型
  70   1          *(u32*)&tmp[5] = Address;//地址
  71   1          tmp[9] = 64;
  72   1          
  73   1          Calculate_CRC16R11(&tmp[1],tmp[2]+2,1);
  74   1          
  75   1          for(i=0;i<3;i++)
  76   1          {
  77   2              SendToR11(tmp); 
  78   2              StartTimer(1,500);
  79   2              while(1)
  80   2              {
  81   3                  ackvalue = GetR11Ack(buf,76);
  82   3                  if(ackvalue)
  83   3                  {
  84   4                      if(0x83==buf[3])
  85   4                      {
  86   5                          if(0!=buf[9])
  87   5                              return SUCCESS_ACTION;
  88   5                          else
  89   5                              break;
  90   5                      }
  91   4                  }
  92   3                  if(GetTimeOutFlag(1))//超时后结束接收
  93   3                      break;
  94   3                  delay_ms(10);
  95   3              }
  96   2          }
  97   1          return FAIL_ACTION;
  98   1      }
  99          
 100          /*
 101          从R11flash导出数据，固定导出1M
 102          address 256M的起始地址
 103          len 导出长度
 104          name 导出名称，以日期命名比如2021031100，长度固定为10
 105          */
 106          u8 ExportDatafromR11(u32 Address, u32 len, u8 *name)
 107          {
 108   1          u8 tmp[16];
 109   1          u8 r11ack[13];
 110   1          u8 i,ackvalue;
 111   1      
 112   1          tmp[0] = 0x10;//帧头
 113   1          tmp[1]=framenum++;//帧编号
 114   1          tmp[2] = 1+1+4+4+1;//长度固定
 115   1          tmp[3] = 0x06;//cmd写入数据到指定的设备及地址
 116   1          tmp[4] = 0x01;//读取内部flash数据
C51 COMPILER V9.57.0.0   R11                                                               07/09/2021 11:30:36 PAGE 3   

 117   1          *(u32*)&tmp[5] = Address;//地址
 118   1          *(u32*)&tmp[9] = len;
 119   1          //StrCopy(&tmp[13],name,10);
 120   1          tmp[13]=*name;
 121   1          
 122   1          Calculate_CRC16R11(&tmp[1],tmp[2]+2,1);
 123   1      
 124   1          for(i=0;i<3;i++)
 125   1          {
 126   2              SendToR11(tmp);
 127   2              StartTimer(1,10000);
 128   2              while(1)
 129   2              {
 130   3                  ackvalue = GetR11Ack(r11ack,13);
 131   3                  if(ackvalue)
 132   3                  {
 133   4                      if(0x86==r11ack[3])
 134   4                      {
 135   5                          if(0xAA==r11ack[9])
 136   5                              return SUCCESS_ACTION;
 137   5                          else
 138   5                              break;
 139   5                      }
 140   4                  }
 141   3                  if(GetTimeOutFlag(1))//超时后结束接收
 142   3                      break;
 143   3                  delay_ms(10);
 144   3              }
 145   2          }
 146   1          return FAIL_ACTION;
 147   1      }
 148          
 149          
 150          u8 DeleteAllR11Data(void)
 151          {
 152   1        u8 tmp[8];
 153   1        u8 r11ack[8];//10 00 03 82 01 AA CRC CRC  回复信息
 154   1        u8 i,ackvalue;
 155   1        
 156   1        tmp[0] = 0x10;//帧头
 157   1          tmp[1]=framenum++;//帧编号
 158   1          tmp[2] = 1+1+1;//长度固定
 159   1          tmp[3] = 0x02;//cmd清空指定设备的全部数据
 160   1        tmp[4] = DeviceType;//设备类型
 161   1          tmp[5] = 0x00;//设备清空时填入的数据
 162   1          
 163   1          Calculate_CRC16R11(&tmp[1],tmp[2]+2,1);
 164   1          for(i=0;i<3;i++)
 165   1          {
 166   2              SendToR11(tmp);
 167   2              StartTimer(1,500);
 168   2              while(1)
 169   2              {
 170   3                  ackvalue = GetR11Ack(r11ack,8);//10 00 03 82 01 AA CRC CRC  回复信息
 171   3                  if(ackvalue)
 172   3                  {
 173   4                      if(0x82==r11ack[3])
 174   4                      {
 175   5                          if(0xAA==r11ack[5])
 176   5                              return SUCCESS_ACTION;
 177   5                          else
 178   5                              break;
C51 COMPILER V9.57.0.0   R11                                                               07/09/2021 11:30:36 PAGE 4   

 179   5                      }
 180   4                  }
 181   3                  if(GetTimeOutFlag(1))//超时后结束接收
 182   3                      break;
 183   3                  delay_ms(10);
 184   3              }
 185   2          }
 186   1          return FAIL_ACTION;
 187   1      }
 188          
 189          
 190          u8 R11OnlineCheck(void)
 191          {
 192   1        u8 tmp[6];
 193   1        u8 r11ack[9];//10 00 04 a0 aa aa aa CRC CRC  回复信息
 194   1        u8 i,ackvalue;
 195   1        
 196   1        tmp[0] = 0x10;//帧头
 197   1          tmp[1]=framenum++;//帧编号
 198   1          tmp[2] = 1;//长度固定
 199   1          tmp[3] = 0x20;//cmd是否在线
 200   1          
 201   1          Calculate_CRC16R11(&tmp[1],tmp[2]+2,1);
 202   1          for(i=0;i<3;i++)
 203   1          {
 204   2              SendToR11(tmp);
 205   2              StartTimer(1,500);
 206   2              while(1)
 207   2              {
 208   3                  ackvalue = GetR11Ack(r11ack,9);//10 00 04 a0 aa aa aa CRC CRC  回复信息
 209   3                  if(ackvalue)
 210   3                  {
 211   4                      if(0xa0==r11ack[3])
 212   4                      {
 213   5                          if(HANDSHANK==r11ack[4] || HANDSHANK==r11ack[5] || HANDSHANK==r11ack[6])
 214   5                {
 215   6                  if(HANDSHANK==r11ack[4])
 216   6                  {
 217   7                    HandShakeFlagFlash=1;
 218   7                  }
 219   6                  
 220   6                  if(HANDSHANK==r11ack[5])
 221   6                  {
 222   7                    HandShakeFlagTF=1;
 223   7                  }
 224   6                  
 225   6                  if(HANDSHANK==r11ack[6])
 226   6                  {
 227   7                    HandShakeFlagUSB=1;
 228   7                  }
 229   6                  
 230   6                  return SUCCESS_ACTION;
 231   6                }
 232   5                              
 233   5                          else
 234   5                              break;
 235   5                      }
 236   4                  }
 237   3                  if(GetTimeOutFlag(1))//超时后结束接收
 238   3                      break;
 239   3                  delay_ms(10);
 240   3              }
C51 COMPILER V9.57.0.0   R11                                                               07/09/2021 11:30:36 PAGE 5   

 241   2          }
 242   1          return FAIL_ACTION;
 243   1      }
 244          
 245          
 246          // #define OPEAN_DISK 0
 247          // #define CLOSE_DISK 1
 248          // #define EXPORT_PDF 2
 249          u8 UdiskAction(u8 Action)
 250          {
 251   1          u8 tmp[8];
 252   1        u8 r11ack[8];//10 00 02 87 AA CRC CRC  回复信息
 253   1        u8 i,ackvalue;
 254   1        
 255   1        tmp[0] = 0x10;//帧头
 256   1          tmp[1]=framenum++;//帧编号
 257   1          tmp[2] = 1+1;//长度固定
 258   1          tmp[3] = 0x07;//U盘相关操作
 259   1        tmp[4] = Action;//设备类型0 1 2
 260   1          
 261   1          Calculate_CRC16R11(&tmp[1],tmp[2]+2,1);
 262   1          for(i=0;i<3;i++)
 263   1          {
 264   2              SendToR11(tmp);
 265   2              StartTimer(1,500);
 266   2              while(1)
 267   2              {
 268   3                  ackvalue = GetR11Ack(r11ack,7);//10 00 02 87 AA CRC CRC  回复信息
 269   3                  if(ackvalue)
 270   3                  {
 271   4                      if(0x87==r11ack[3])
 272   4                      {
 273   5                          if(0xAA==r11ack[5])
 274   5                              return SUCCESS_ACTION;
 275   5                          else
 276   5                              break;
 277   5                      }
 278   4                  }
 279   3                  if(GetTimeOutFlag(1))//超时后结束接收
 280   3                      break;
 281   3                  delay_ms(10);
 282   3              }
 283   2          }
 284   1          return FAIL_ACTION;
 285   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1071    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4     235
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
