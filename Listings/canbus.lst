C51 COMPILER V9.57.0.0   CANBUS                                                            10/19/2021 10:20:05 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE CANBUS
OBJECT MODULE PLACED IN .\Objects\canbus.obj
COMPILER INVOKED BY: D:\Program Files\keil\C51\BIN\C51.EXE driver\canbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\drive
                    -r;.\source;.\lib) DEBUG OBJECTEXTEND PRINT(.\Listings\canbus.lst) TABS(2) OBJECT(.\Objects\canbus.obj)

line level    source

   1          #include "canbus.h"
   2          #include "timer.h"
   3          //如果使用CAN，那么sys.h  必须增加如下宏定义  #define INTVPACTION
   4          
   5          /*CAN总线位时间参数的设定与调整
   6          1、 确定时间份额
   7              时间份额数量为8~25
   8              位时间=1/波特率           ( 250K           4us)
   9              时间份额=位时间/时间份额数量        
  10              BRP=时间份额/(2*tclk)=  时间份额/2*FOSC=206*200/2000=40      
  11          2、 设置时间段和采样点
  12              时间份额数量=1+T1+T2
  13              采样点80%最佳
  14              (1+T1)/(1+T1+T2)=0.8
  15              就可以确定T1  T2
  16              传播时间段和相位缓冲器段1  =T1
  17              相位缓冲器段2              =T2
  18          3、 确定同步跳转宽度和采样次数
  19              同步跳转宽度1~4  尽量大
  20          
  21          */
  22          CANBUSUNIT   CanData;
  23          //https://blog.csdn.net/weixin_44536482/article/details/89030152
  24          //125K{0x3F,0x40,0x72,0x00},250K{0x1F,0x40,0x72,0x00},500K{0x0F,0x40,0x72,0x00},1M{0x07,0x40,0x72,0x00}
  25          //根据T5L应用开发指南3.8对CAN接口进行初始化
  26          void CanBusInit(u8* RegCfg)
  27          {
  28   1        SetPinOut(0,2);
  29   1        SetPinIn(0,3);
  30   1        PinOutput(0,2,1);
  31   1        MUX_SEL |= 0x80;    //将CAN接口引出到P0.2,P0.3  
  32   1        ADR_H = 0xFF;
  33   1        ADR_M = 0x00;
  34   1        ADR_L = 0x60;
  35   1        ADR_INC = 1;
  36   1        RAMMODE = 0x8F;   //写操作
  37   1        while(!APP_ACK);
  38   1        #if 0
                DATA3 = 0x3f;
                DATA2 = 0x40;
                DATA1 = 0x72;
                DATA0 = 0x00; 
                #else
  44   1        DATA3 = RegCfg[0];
  45   1        DATA2 = RegCfg[1];
  46   1        DATA1 = RegCfg[2];
  47   1        DATA0 = RegCfg[3];      
  48   1        #endif    
  49   1        APP_EN = 1;
  50   1        while(APP_EN);
  51   1        DATA3 = 0;
  52   1        DATA2 = 0;
  53   1        DATA1 = 0;
  54   1        DATA0 = 0;      //配置验收寄存器ACR
C51 COMPILER V9.57.0.0   CANBUS                                                            10/19/2021 10:20:05 PAGE 2   

  55   1        APP_EN = 1;   
  56   1        while(APP_EN);
  57   1        DATA3 = 0xFF;
  58   1        DATA2 = 0xFF;
  59   1        DATA1 = 0xFF;
  60   1        DATA0 = 0xFF;   //配置AMR
  61   1        APP_EN = 1; 
  62   1        while(APP_EN);
  63   1        RAMMODE = 0;
  64   1        CAN_CR = 0xA0;
  65   1        while(CAN_CR&0x20); //执行配置FF0060-FF0062动作
  66   1        ECAN = 1;     //打开CAN中断 
  67   1      }
  68          
  69          
  70          /**************************************************************
  71          D3  1  CAN_RX_BUFFER  [7] IDE ，[6]RTR， [3:0]―DLC，帧数据长度。
  72          0xFF:0068
  73          D2:D0  3  未定义 
  74          ID  ID，扩展帧时 29bit 有效，标准帧时 11bit 有效。
  75          D3  1  ID 第一个字节，标准帧与扩展帧。
  76          D2  1  ID 第二个字节，[7:5]为标准帧的高 3bit，扩展帧第 2 字节。
  77          D1  1  ID 第三个字节，标准帧无效，扩展帧第 3 字节。
  78          0xFF:0069
  79          D0  1  ID 第四个字节，标准帧无效，[7:3]-扩展帧的高 5bit。
  80          0xFF:006A  D3:D0  4  数据  接收数据，DATA1-DATA4。
  81          0xFF:006B  D3:D0  4  数据  接收数据，DATA5-DATA8。
  82          ******************************************************************/
  83          //对于T5L1和T5L2必须在main函数，while(1)中调用
  84          void CanErrorReset(void)
  85          {
  86   1        // EA=0;
  87   1        if(CAN_ET&0X20)
  88   1        {
  89   2          CAN_ET &= 0XDF;
  90   2          CAN_CR |= 0X40;
  91   2          delay_us(1000);
  92   2          CAN_CR &= 0XBF;  
  93   2          CanData.CanTxFlag = 0;
  94   2        }
  95   1        // EA=1;
  96   1      }
  97          
  98          
  99          void LoadOneFrame(void)
 100          {
 101   1        ADR_H = 0xFF;
 102   1        ADR_M = 0x00;
 103   1        ADR_L = 0x64;
 104   1        ADR_INC = 1;
 105   1        RAMMODE = 0x8F;   //写操作
 106   1        while(!APP_ACK);
 107   1        DATA3 = CanData.BusTXbuf[CanData.CanTxTail].status;     //帧类长度型以及数据
 108   1        DATA2 = 0;
 109   1        DATA1 = 0;
 110   1        DATA0 = 0;      
 111   1        APP_EN = 1;
 112   1        while(APP_EN);    //写入RTR,IDE,DLC等数据
 113   1        DATA3 = (u8)(CanData.BusTXbuf[CanData.CanTxTail].ID>>24);
 114   1        DATA2 = (u8)(CanData.BusTXbuf[CanData.CanTxTail].ID>>16);
 115   1        DATA1 = (u8)(CanData.BusTXbuf[CanData.CanTxTail].ID>>8);
 116   1        DATA0 = (u8)(CanData.BusTXbuf[CanData.CanTxTail].ID);     
C51 COMPILER V9.57.0.0   CANBUS                                                            10/19/2021 10:20:05 PAGE 3   

 117   1        APP_EN = 1;
 118   1        while(APP_EN);    //写入ID数据
 119   1        DATA3 = CanData.BusTXbuf[CanData.CanTxTail].candata[0];
 120   1        DATA2 = CanData.BusTXbuf[CanData.CanTxTail].candata[1];
 121   1        DATA1 = CanData.BusTXbuf[CanData.CanTxTail].candata[2];
 122   1        DATA0 = CanData.BusTXbuf[CanData.CanTxTail].candata[3];     
 123   1        APP_EN = 1;
 124   1        while(APP_EN);    //写入发送数据前4字节
 125   1        DATA3 = CanData.BusTXbuf[CanData.CanTxTail].candata[4];
 126   1        DATA2 = CanData.BusTXbuf[CanData.CanTxTail].candata[5];
 127   1        DATA1 = CanData.BusTXbuf[CanData.CanTxTail].candata[6];
 128   1        DATA0 = CanData.BusTXbuf[CanData.CanTxTail].candata[7];     
 129   1        APP_EN = 1;
 130   1        while(APP_EN);    //写入发送数据后4字节
 131   1        CanData.CanTxTail++;
 132   1        RAMMODE = 0;
 133   1      }
 134          
 135          //status主要用于提供IDE 和 RTR状态，实际发送长度有len自动处理，大于8字节会自动拆分成多包
 136          /*主循环调用，将需要发送的数据放在缓存区即可，同时CAN发送会占用定时器7，其余位置则不能在使用*/
 137          void CanTx(u32 ID, u8 status, u16 len, const u8 *pData)
 138          {
 139   1        u8 i,j,k,framnum,framoffset;
 140   1        u32 idtmp,statustmp;
 141   1      
 142   1        if(len>2048)//发送长度大于队列长度
 143   1          return;
 144   1        if(status&0x80)//扩展帧
 145   1        {
 146   2          idtmp = ID << 3;
 147   2        }
 148   1        else
 149   1        {
 150   2          idtmp = ID << 21;
 151   2        }
 152   1        if(CanData.BusTXbuf[CanData.CanTxHead].status&0x40)//远程帧不需要发送数据
 153   1        {
 154   2          CanData.BusTXbuf[CanData.CanTxHead].ID = idtmp;
 155   2          CanData.BusTXbuf[CanData.CanTxHead].status = status&0xC0;//远程帧发送长度强制清零
 156   2          CanData.CanTxHead++;
 157   2        }
 158   1        else
 159   1        {
 160   2          framnum = len >> 3;
 161   2          framoffset = len % 8;
 162   2          k=0;
 163   2          statustmp = status&0xC0;
 164   2          for(i=0;i<framnum;i++)
 165   2          {
 166   3            CanData.BusTXbuf[CanData.CanTxHead].ID = idtmp;
 167   3            CanData.BusTXbuf[CanData.CanTxHead].status = statustmp | 0x08;
 168   3            for(j=0;j<8;j++)
 169   3            {
 170   4              CanData.BusTXbuf[CanData.CanTxHead].candata[j] = pData[k];
 171   4              k++;
 172   4            }
 173   3            CanData.CanTxHead++;
 174   3          }
 175   2          if(framoffset)
 176   2          {
 177   3            CanData.BusTXbuf[CanData.CanTxHead].ID = idtmp;
 178   3            CanData.BusTXbuf[CanData.CanTxHead].status = statustmp | framoffset;
C51 COMPILER V9.57.0.0   CANBUS                                                            10/19/2021 10:20:05 PAGE 4   

 179   3            for(j=0;j<framoffset;j++)
 180   3            {
 181   4              CanData.BusTXbuf[CanData.CanTxHead].candata[j] = pData[k];
 182   4              k++;
 183   4            }
 184   3            for(;j<8;j++)
 185   3              CanData.BusTXbuf[CanData.CanTxHead].candata[j] = 0;
 186   3            CanData.CanTxHead++;
 187   3          }
 188   2        }
 189   1        if(0==CanData.CanTxFlag)
 190   1        {
 191   2          EA = 0;
 192   2          LoadOneFrame();
 193   2          EA = 1;
 194   2          CanData.CanTxFlag = 1;
 195   2          StartTimer(7,3000);//3S还未发送出去，则清空发送标记
 196   2          CAN_CR |= 0x04;   //启动发送
 197   2        }
 198   1        if(CanData.CanTxFlag!=0)
 199   1        {
 200   2          if(GetTimeOutFlag(7))
 201   2          {
 202   3            CanData.CanTxFlag = 0;
 203   3          }
 204   2        }
 205   1      }
 206          
 207          void Can_Isr() interrupt 9
 208          {
 209   1        u8 status;
 210   1        
 211   1        EA = 0;
 212   1        if((CAN_IR&0x80) == 0x80)
 213   1        {
 214   2          CAN_IR &= 0x3F; //清空远程帧标记位      
 215   2        }
 216   1        if((CAN_IR&0x40) == 0x40)
 217   1        {
 218   2          CAN_IR &= 0xBF; //清空数据帧标记位
 219   2          ADR_H = 0xFF;
 220   2          ADR_M = 0x00;
 221   2          ADR_L = 0x68;
 222   2          ADR_INC = 1;
 223   2          RAMMODE = 0xAF;   //读操作
 224   2          while(!APP_ACK);
 225   2          APP_EN = 1;
 226   2          while(APP_EN);
 227   2          status = DATA3;
 228   2          CanData.BusRXbuf[CanData.CanRxHead].status = status;
 229   2          APP_EN = 1;
 230   2          while(APP_EN);      
 231   2          CanData.BusRXbuf[CanData.CanRxHead].ID <<= 8;
 232   2          CanData.BusRXbuf[CanData.CanRxHead].ID |= DATA3;
 233   2          CanData.BusRXbuf[CanData.CanRxHead].ID <<= 8;
 234   2          CanData.BusRXbuf[CanData.CanRxHead].ID |= DATA2;
 235   2          CanData.BusRXbuf[CanData.CanRxHead].ID <<= 8;
 236   2          CanData.BusRXbuf[CanData.CanRxHead].ID |= DATA1;
 237   2          CanData.BusRXbuf[CanData.CanRxHead].ID <<= 8;
 238   2          CanData.BusRXbuf[CanData.CanRxHead].ID |= DATA0;
 239   2          CanData.BusRXbuf[CanData.CanRxHead].ID=CanData.BusRXbuf[CanData.CanRxHead].ID>>3;
 240   2          if(0==(status&0x80))//标准帧ID还需要右移18位
C51 COMPILER V9.57.0.0   CANBUS                                                            10/19/2021 10:20:05 PAGE 5   

 241   2          {
 242   3            CanData.BusRXbuf[CanData.CanRxHead].ID >>= 18;
 243   3          }
 244   2          if(0==(status&0x40))//数据帧才需要读取数据
 245   2          {
 246   3            APP_EN = 1;
 247   3            while(APP_EN);
 248   3            CanData.BusRXbuf[CanData.CanRxHead].candata[0] = DATA3;
 249   3            CanData.BusRXbuf[CanData.CanRxHead].candata[1] = DATA2;
 250   3            CanData.BusRXbuf[CanData.CanRxHead].candata[2] = DATA1;
 251   3            CanData.BusRXbuf[CanData.CanRxHead].candata[3] = DATA0;
 252   3            APP_EN = 1;
 253   3            while(APP_EN);
 254   3            CanData.BusRXbuf[CanData.CanRxHead].candata[4] = DATA3;
 255   3            CanData.BusRXbuf[CanData.CanRxHead].candata[5] = DATA2;
 256   3            CanData.BusRXbuf[CanData.CanRxHead].candata[6] = DATA1;
 257   3            CanData.BusRXbuf[CanData.CanRxHead].candata[7] = DATA0; 
 258   3          }
 259   2          RAMMODE = 0;
 260   2          CanData.CanRxHead++;
 261   2        }
 262   1        if((CAN_IR&0x20) == 0x20)
 263   1        {
 264   2          CAN_IR &= ~(0x20);  //清空发送帧标记位
 265   2          if(CanData.CanTxTail != CanData.CanTxHead)
 266   2          {
 267   3            LoadOneFrame();
 268   3            CAN_CR |= 0x04;   //启动发送    
 269   3            StartTimer(7,3000);//3S还未发送出去，则清空发送标记
 270   3          }
 271   2          else
 272   2          {
 273   3            CanData.CanTxFlag = 0;//清空发送标记位
 274   3          }
 275   2        }
 276   1        if((CAN_IR&0x10) == 0x10)
 277   1        {
 278   2          CAN_IR &= 0xEF; //清空接收溢出标记位
 279   2        }
 280   1        if((CAN_IR&0x08) == 0x08)
 281   1        {
 282   2          CAN_IR &= 0xF7; //清空错误标记位
 283   2        }
 284   1        if((CAN_IR&0x04) == 0x04)
 285   1        {
 286   2          CAN_IR &= 0xFB; //清空仲裁失败标记位
 287   2          CAN_CR |= 0x04; //重新启动发送  
 288   2        }
 289   1        CAN_ET=0;
 290   1        EA = 1;  
 291   1      }
 292          
 293          
 294          /*主循环调用，将需要发送的数据放在缓存区即可，同时CAN发送会占用定时器7，其余位置则不能在使用*/
 295          // void CANTx(void)
 296          // {
 297          //  u32 tmp32;
 298          //  if((0==CanData.CanTxFlag)&&(CanData.CanTxTail != CanData.CanTxFlag))
 299          //  {
 300          //    EA = 0;
 301          //    tmp32=CanData.BusTXbuf[CanData.CanTxTail].ID;
 302          //    ADR_H = 0xFF;
C51 COMPILER V9.57.0.0   CANBUS                                                            10/19/2021 10:20:05 PAGE 6   

 303          //    ADR_M = 0x00;
 304          //    ADR_L = 0x64;
 305          //    ADR_INC = 1;
 306          //    RAMMODE = 0x8F;   //写操作
 307          //    while(!APP_ACK);
 308          //    DATA3 = CanData.BusTXbuf[CanData.CanTxTail].status;     //帧类长度型以及数据
 309          //    DATA2 = 0;
 310          //    DATA1 = 0;
 311          //    DATA0 = 0;      
 312          //    APP_EN = 1;
 313          //    while(APP_EN);    //写入RTR,IDE,DLC等数据
 314          //    DATA3 = (u8)(tmp32>>24);
 315          //    DATA2 = (u8)(tmp32>>16);
 316          //    DATA1 = (u8)(tmp32>>8);
 317          //    DATA0 = (u8)(tmp32>>0);     
 318          //    APP_EN = 1;
 319          //    while(APP_EN);    //写入ID数据
 320          //    DATA3 = CanData.BusTXbuf[CanData.CanTxTail].candata[0];
 321          //    DATA2 = CanData.BusTXbuf[CanData.CanTxTail].candata[1];
 322          //    DATA1 = CanData.BusTXbuf[CanData.CanTxTail].candata[2];
 323          //    DATA0 = CanData.BusTXbuf[CanData.CanTxTail].candata[3];     
 324          //    APP_EN = 1;
 325          //    while(APP_EN);    //写入发送数据前4字节
 326          //    DATA3 = CanData.BusTXbuf[CanData.CanTxTail].candata[4];
 327          //    DATA2 = CanData.BusTXbuf[CanData.CanTxTail].candata[5];
 328          //    DATA1 = CanData.BusTXbuf[CanData.CanTxTail].candata[6];
 329          //    DATA0 = CanData.BusTXbuf[CanData.CanTxTail].candata[7];     
 330          //    APP_EN = 1;
 331          //    while(APP_EN);    //写入发送数据后4字节
 332          //    CanData.CanTxTail++;
 333          //    CanData.CanTxFlag = 1;
 334          //    StartTimer(7,3000);//3S还未发送出去，则清空发送标记
 335          //    EA = 1;
 336          //    RAMMODE = 0;
 337          //    CAN_CR |= 0x04;   //启动发送    
 338          //  }
 339          //  if(CanData.CanTxFlag!=0)
 340          //  {
 341          //    if(GetTimeOutFlag(7))
 342          //    {
 343          //      CanData.CanTxFlag = 0;
 344          //    }
 345          //  }
 346          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2064    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   6661      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
